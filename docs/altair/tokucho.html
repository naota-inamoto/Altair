<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=Shift_JIS">
<TITLE>Characteristics of Altair</TITLE>
</HEAD>

<BODY>
<H1>Altairの特徴</H1>

第0.43版 2016年10月23日<BR>
第0.00版 1996年 2月11日<BR>

<HR>
<H3><A NAME="interactive">実行しながらインタラクティブに修正が可能</A></H3>
Altairの大きな特徴のひとつは、プログラムを実行しながらインタラクティブにプログラムを<BR>
修正して実行を続けることがほとんどの場合に可能なことです。<BR>
<BR>
通常の下工程のプログラム開発作業は、コーディングしてコンパイルして、プログラムを実行して、<BR>
期待通りに動かなかったらプログラムを止めて、間違いを探して、またコーディングをしての<BR>
繰り返しです。間違いが分からないときは、間違いを見つけるためのコードを入れるなどして<BR>
同じことを繰り返すことになります。コンパイルを通すのに時間がかかることが往々にしてあります。<BR>
また、プログラムがサーバーアプリケーションの場合、起動や終了に時間がかかって<BR>
１回の修正からその動作確認を行うまでのターンアラウンドタイムが長いことが多く、<BR>
これが生産性を低くしている原因になることがあります。<BR>
<BR>
Altairでは、ほとんどの場合、実行中のプログラムを止ないでインタラクティブに修正を続けながら<BR>
プログラムの実行を続けることができます。<BR>
アプリケーションの起動や終了の時間を待たずして修正の結果を確認することができます。<BR>
コンパイルというフェーズが存在しないのでコンパイルを通すことに時間をとられることもありません。<BR>
これは修正からプログラム修正から動作確認までのターンアラウンドタイムが<BR>
限りなく0に近いことを意味し、下工程のプログラム開発の生産性を上げます。<BR>
<BR>
よいソフトウェアを作成する場合、下流工程よりも上流設計が十分できていることが大切ですが、<BR>
明確な要求仕様がなく、仕様を決めるためにはある程度何かプロトタイプを作ってみて<BR>
それを評価してみなければ仕様が決められない事があります。<BR>
そのようなソフトの仕様を検討する場合でプロトタイプができるだけ早く欲しいという場合に<BR>
Altairは役に立ちます。<BR>
<BR>
評価してフィードバックという過程が欠落し、リソースを投入して作ってしまった後の<BR>
互換性にしばられ仕様を変更できないという状況に陥るとよいソフトはできにくいですが、<BR>
プロトタイプによる評価があればそれは緩和されると思われます。<BR>
<BR>
Altairは慣れれば上流工程での評価のため<BR>
少ないリソースでとりあえず作ってみるということに力を発揮します。<BR>
ターゲット環境で使用する上で品質に問題がなければ、<BR>
リソースを投入して別の言語やプラットホームで作り直すことをしなくても<BR>
プロトタイプがそのまま使えるという可能性もあります。<BR>

<HR>
<H3><A NAME="browser">クラスブラウザがそのままエディタ</A></H3>
Altairではクラスブラウザがそのままエディタになっています。<BR>
クラス階層を表わすウィンドウのクラス名上のダブルクリックで<BR>
そのクラスのメンバー一覧のウィンドウを出すことができ、<BR>
メンバー一覧のウィンドウのメンバー名上のダブルクリックで<BR>
メンバー関数の内容を表わすウィンドウを出すことができます。<BR>
<BR>
関数の中身をクラス名と関数名から検索する場合、通常C++では<BR>
ソースファイルすべてを対象としてクラス名::関数名で検索しなければ<BR>
なりませんが、Altairでは、この検索は不要です。<BR>
<BR>
ヘッダを書いて関数のインプリをするさい、C++では関数のスケルトンを<BR>
書くのに、綴り字を間違えたりしてヘッダを書いたのと同じぐらいの<BR>
時間がかかってしまいます。Altairでは、ヘッダを入力してしまえば<BR>
ヘッダ上のメンバー関数のダブルクリックですぐに関数の編集に入ること<BR>
ができますので、関数のスケルトン作成作業は不要です。<BR>

<HR>
<H3><A NAME="editor">構造エディタ</A></H3>
Altairでは、クラス一覧/メンバー一覧/メンバー関数の中身の部分を<BR>
編集するエディタが構造エディタになっています。入力されたテキストの<BR>
文法のチェックはその場で行われますので、コンパイルエラーを<BR>
バッチ的に取り除くという作業は存在しません。<BR>
<BR>
文法が間違っていた場合はじかれてしまいますが、入力したテキストは<BR>
残っていますのでそれを少し修正するだけで再入力を行うことができます。<BR>

<HR>
<H3><A NAME="no_wait">インタプリタなので待ち時間がない</A></H3>
Altairは、インタプリタなのでソースプログラムを編集しても<BR>
再実行までにかかる時間はゼロです。たとえヘッダを変更しても<BR>
再実行までにかかる時間はゼロです。<BR>
（C++で１００００行ぐらいのプログラムのヘッダを変更した場合、<BR>
通常再実行までに数１０分かかります。）<BR>
<BR>
Altairでは、プログラム実行中にプログラムを書き換えることが可能です。<BR>
実行中に適宜プリント文を挿入することによりデバッグを行うことが<BR>
できます。<BR>
<BR>
プレーンテキストファイルを編集してそれを実行の度にロードするような<BR>
インタプリタ処理系がありますが、これでは実行の度に発生するロードに<BR>
かなりの時間がかかり、インタプリタの対話性が<BR>
大きくそこなわれてしまいます。Altairでは、ロードは初回の１回きりで、<BR>
それ以後はプログラムの編集は内部表現のデータにダイレクトに<BR>
編集をかけますので、実行の度にテキストを読み込むようなことは<BR>
ありません。<BR>

<HR>
<H3><A NAME="memory_mgr">メモリ管理にいっさい気を使う必要がない</A></H3>
Altairでは、メモリ管理にいっさい気を使う必要がありません。<BR>
必要なオブジェクトは作りっぱなしで、不要になったオブジェクトは<BR>
自動的に回収されます。<BR>
<BR>
C/C++では、オブジェクトの作成/破壊はすべてプログラマの責任です。<BR>
破壊し忘れれば「メモリリーク」になるし、破壊してしまった<BR>
オブジェクトのポインタを参照しようとすると「２重フリー」や<BR>
「メモリ破壊」を起こしてしまい、そのデバッグに非常に多くの時間を<BR>
必要とします。<BR>
<BR>
LISP言語に見られるようなGC(ガーベージコレクション)を行うような<BR>
システムにすれば、メモリ管理に気を使う必要はなくなりますが、<BR>
GCにかかるコストを無視することはできません。特にフリーメモリ領域が<BR>
少なくなった場合。<BR>
<BR>
Altairでは、内部でref/unrefの参照カウンタを用いています。<BR>
どこからか参照されれば参照カウンタを1増やし、参照しなくなれば<BR>
1減らし、参照カウンタがゼロになったら回収します。<BR>
<BR>
参照カウンタ方式の欠点は、ループとなるような参照ができてしまった場合、<BR>
それを回収することができず、メモリリークを起こしてしまうことです。<BR>
Altairでは、原則としてループとなるような参照は作らないようにして<BR>
います。たとえ、ループとなる参照ができてしまう場合でも、<BR>
たいていの場合はAltairがベースとしている双方向グラフ構造データの<BR>
アークでこれを回避することができます。どうしてもループとなる参照が<BR>
できてしまう場合の便宜としてAltairはGCの機能を持っています。<BR>
これは、ループとなる参照ができていないかのチェックにも用いることが<BR>
できます。<BR>

<HR>
<H3><A NAME="error_level">C++レベルエラーとインタプリタレベルエラーを分離</A></H3>
アプリケーションを全部C++で書くとNULLポインタを参照するなどして<BR>
エラーとなることなどが頻繁に起こり得ます。そのその度ごとに原因を調べて<BR>
修正をしコンパイル/リンクをし直していたのでは開発に非常に時間がかかります。<BR>
Altairでは、NULLポインタ参照などのエラーの場合、インタプリタエラーとして<BR>
検出されますので、待ち時間無しで修正を行ってすぐさま実行することが<BR>
比較的簡単に行うことができます。<BR>

<HR>
<H3><A NAME="graph_data">双方向グラフデータ構造がベース</A></H3>
Altairでは、根底に「双方向グラフ構造データ」をベースに置き、<BR>
Altairで使用されるすべてのデータをこれで表現することに<BR>
統一しています。このメリットはデータ操作関数を共通化できること、<BR>
異なるコンポーネント間でのデータのやり取りが簡単になることなどです。<BR>
<BR>
なぜグラフかというと、世の中のほとんどすべてのデータは<BR>
グラフで表現できるからです。なぜ双方向かというと、アークを<BR>
双方向にたどれた方が便利な場合が多いからです。<BR>

<HR>
<H3><A NAME="file_io">ファイルIOが容易</A></H3>
Altairは、双方向グラフ構造データのファイル入出力を標準で備えています。<BR>
Altair中のデータは皆双方向グラフ構造データで表わされているので、<BR>
何も特別なことを考えなくてもプログラムで扱うデータのファイル入出力を<BR>
簡単に行うことができます。<BR>
<BR>
あるC++言語のファイル入出力では、新しいオブジェクトが加わるたびに<BR>
そのオブジェクトのクラスにそのオブジェクトのファイル入出力コードを<BR>
新たに書き加えなければなりません。Altairではそのようなこといっさい<BR>
不要です。<BR>

<HR>
<H3><A NAME="lib_mgr">ライブラリ管理可能</A></H3>
Altairでは、プログラムをライブラリに分け、ライブラリ単位で<BR>
ロード/セーブする機能をそなえています。複数のプロジェクトを<BR>
開くことができますが、メモリ節約のため同じ名前のライブラリは、<BR>
共有できるようになっています。<BR>

<HR>
<H3><A NAME="platform">マルチプラットホーム展開が比較的容易</A></H3>
AltairはWindows上に実現されていますが、Altairの表面には<BR>
初版ではWindows APIはいっさい現れませんでしたので、Altair本体を<BR>
Windows以外の他のプラットホームに移せばAltairのAPはそのまま動きました。<BR>
<BR>
その後の拡張によりWindowsに特有の機能(OLE/OCX、ウィンドウメッセージ等)が<BR>
入ったためこれらの機能を使っていればそのままでは他プラットホームでは<BR>
動きませんが、使っていなければAltair本体を他プラットホームに移植すれば<BR>
そのまま動きます。<BR>

<HR>
<H3><A NAME="relation">オブジェクト間の関係付けが容易</A></H3>
Altairでは、双方向グラフデータ構造のアークを張ることにより、<BR>
オブジェクト間の間に簡単に関係付けを行うことができます。<BR>
<BR>
C++のオブジェクトに何かのポインタを持たせようと思ったら、<BR>
派生クラスを作ってそのためのポインタフィールドを設けなければ<BR>
なりません。Altairでは、派生クラスを作ことなくその目的を満たせます。<BR>

<HR>
<H3><A NAME="n_n_relation">多対多の関係を容易に表現できる</A></H3>
Altairでは、双方向グラフデータ構造のアークを張ることにより、<BR>
多対多のオブジェクトの関係を簡単に実現することができます。<BR>
これは、グラフを基にした簡易知識ベースの作成を容易にします。<BR>

<HR>
<H3><A NAME="parallel">並列処理のシミュレーションが可能</A></H3>
Altairは、並列処理をシミュレーションする機能を有しています。<BR>
Windowsのメッセージループがアイドル状態になったときに、<BR>
複数プロセスがラウンドロビンで処理されるようになっています。<BR>
Occamという並列処理記述言語がありますが、並列処理記述に関して<BR>
Altairはそれとほぼ同等の記述能力を持っています<BR>
<BR>
本題とは直接関係ありませんが、並列処理のメリットに以下のようなものも<BR>
あります。GUI系のイベントループでコールバック関数の中で重たい処理を<BR>
させるとGUIが反応しなくなったり誤動作するようになります。Altairでは、<BR>
コールバック中の処理が重たいと分かっている場合は、サブプロセスを<BR>
生成し、コールバックからはすぐに抜けられるようになっています。<BR>
サブプロセスよりもコールバックの方が優先順位が高いのでGUIが遅く<BR>
なることはまずないです。<BR>

<HR>
</BODY>
</HTML>
