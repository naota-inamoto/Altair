$END_LIB
TEXT
AlObject
class AltairServer
class LogObj
end_class
class WaitObj
end_class
class WebServer
class HttpServerConnectionMgr
end_class
class HttpServerConnection
end_class
class HttpClientConnection
end_class
class HttpServlet
class WebUIServlet
end_class
end_class
class HttpRequest
end_class
class HttpResponse
end_class
class HttpSession
end_class
end_class
class MultipartSecureMessage
end_class
class ProxyServer
class ProxyServerConnectionMgr
end_class
class ProxyServerConnection
end_class
class ProxyClientConnection
end_class
end_class
class XmlUtility
class XmlSchemaLoader
end_class
class DtdLoader
class ExtendedDtdLoader
end_class
end_class
class DtdItr
end_class
class DtdHandler
class XmlComposerHandler
end_class
end_class
class XmlItr
end_class
class XmlValidator
class SimpleXml2Db
end_class
end_class
class XmlComposer
class SimpleDb2Xml
end_class
end_class
class XmlDataRetriver
end_class
class XmlDbAccessor
class XmlDbTableAccessor
end_class
end_class
class XmlDbObject
class XmlDbTableObject
end_class
end_class
class Csv1Data
class Csv1DataItr
end_class
end_class
end_class
class DbUtility
class DbConnection
class DbPoolConnection
end_class
end_class
class DbConnectionPool
end_class
class DbManager
end_class
end_class
class FileUtility
class FileItr
end_class
class RevFileItr
end_class
end_class
class Context
end_class
class InitDB
end_class
end_class
$END_CLASS
TEXT
AlObject
class AltairServer
member
public: static void start();
member
public: static void shutdown();
member
public: static void restart();
member
public: static void start_trace();
member
public: static void stop_trace();
member
public: static void remote_shutdown();
member
public: static void remote_restart();
member
public: static AltairServer appServer;
member
public: list startServer();
member
public: void shutdownServer();
member
public: list load_config();
member
public: list config;
member
public: list web_servers;
member
public: string pool_name;
member
public: void log(string filepath, string str);
member
public: void system_log(string level, string str);
member
public: string system_log_filepath;
member
public: string system_log_db;
member
public: LogObj logObj;
member
public: static integer getTime(string time);
member
public: void timeoutCheck();
member
public: integer timer_id;
member
public: integer gc_interval;
member
public: integer _gc_time;
member
public: void printStackTrace();
member
public: void connection_debug();
member
public: void xml_debug();
member
public: list debug;
member
public: list debug2;
member
public: list debug3;
member
public: string debug_log_file;
member
public: static void dump_graph(string msg, integer i, list n);
member
public: static void dump_graph(integer indent, integer i, list n);
class LogObj
member
public: void init();
member
public: void finalize();
member
public: void log(string filepath, string str);
member
public: list log_files;
member
public: static integer max_size;
end_class
class WaitObj
member
public: void wait();
member
public: void notify();
member
public: list notified;
member
public: list wait_obj;
member
public: list value;
member
public: list value2;
end_class
class WebServer
member
public: AltairServer ap_server;
member
public: string name;
member
public: integer port;
member
public: string documentRoot;
member
public: list content_types;
member
public: list servlet_list;
member
public: list upload_servlet_list;
member
public: list servlet_param_list;
member
public: list start();
member
public: void stop();
member
public: HttpServerConnectionMgr conn_mgr;
member
public: integer connectionTimeout;
member
public: string GetAbsPath(string path);
member
public: list sessions;
member
public: integer sessionTimeout;
member
public: integer maxMsgSize;
member
public: void access_log(string fromIP, string path, string code, string size);
member
public: string access_log_filepath;
member
public: string access_log_db;
member
public: void error_log(string str);
member
public: void timeoutCheck();
member
public: list ssl;
member
public: string ca_cert;
member
public: string cert;
member
public: string key;
member
public: integer clientAuth;
member
public: string dhparam;
member
public: string cipher;
class HttpServerConnectionMgr
member
public: void create(WebServer server);
member
public: void close();
member
public: WebServer server;
member
public: list connections;
member
public: list start();
member
public: integer server_socket_id;
member
public: integer hwnd;
member
public: integer msg;
member
public: void accepted();
end_class
class HttpServerConnection
member
public: void create(WebServer server, integer socket_id);
member
public: void close();
member
public: WebServer server;
member
public: integer socket_id;
member
public: integer hwnd;
member
public: integer msg;
member
public: integer _time;
member
public: void startReceiveCommand();
member
public: void startReceiveHeaders();
member
public: void startReceiveBlockSize();
member
public: void startReceiveContents();
member
public: void startReceiveContents2();
member
public: void startReceiveCRLF();
member
public: void commandReceived();
member
public: void headersReceived();
member
public: void blockSizeReceived();
member
public: void contentsReceived();
member
public: void contentsReceived2();
member
public: void CRLFReceived();
member
public: list chunked;
member
public: integer buffer_size;
member
public: list buffer;
member
public: string command_line;
member
public: string command;
member
public: string http_ver;
member
public: integer content_block_size;
member
public: list bin_raw_http_header;
member
public: list headers;
member
public: integer content_length;
member
public: string refer;
member
public: list contents;
member
public: void process();
member
public: string order;
member
public: string path;
member
public: string path2;
member
public: list params;
member
public: list send(string str);
member
public: list send(list binary);
member
public: list send(list binary, integer index, integer size);
member
public: void sendCompleted();
member
public: string send_status;
member
public: file in;
member
public: integer total_read_bytes;
member
public: string fromIP;
member
public: list cert_info;
member
public: HttpServlet servlet;
member
public: HttpRequest req;
member
public: HttpResponse res;
member
public: list binary;
member
public: string boundary;
member
public: string upload_filename;
member
public: file upload;
end_class
class HttpClientConnection
member
public: list create(string url);
member
public: list doGet();
member
public: list doPost();
member
public: list doGet_noWait();
member
public: list doPost_noWait();
member
public: list isCompleted();
member
public: string request_method;
member
public: list connect();
member
public: list startReceiveProxyHeaders();
member
public: void proxyHeadersReceived();
member
public: void close();
member
public: string url;
member
public: list ssl;
member
public: string cert;
member
public: string key;
member
public: string ca_cert;
member
public: integer server_auth;
member
public: string host;
member
public: integer port;
member
public: string proxy_server;
member
public: integer proxy_port;
member
public: string path;
member
public: integer socket_id;
member
public: integer hwnd;
member
public: integer msg;
member
public: integer _time;
member
public: void setTimeout(integer sec);
member
public: integer timeout;
member
public: list headers;
member
public: list out(string s);
member
public: list out(list binary);
member
public: list out(list binary, integer index, integer size);
member
public: list output;
member
public: integer max_size;
member
public: integer content_length;
member
public: WaitObj wait_obj;
member
public: list send(string str);
member
public: list send(list binary);
member
public: list send(list binary, integer index, integer size);
member
public: list send2();
member
public: void sendCompleted();
member
public: integer send_index;
member
public: integer send_block_size;
member
public: integer send_total_size;
member
public: list startReceiveCommand();
member
public: list startReceiveHeaders();
member
public: list startReceiveBlockSize();
member
public: list startReceiveContents();
member
public: list startReceiveCRLF();
member
public: void commandReceived();
member
public: void headersReceived();
member
public: void blockSizeReceived();
member
public: void contentsReceived();
member
public: void CRLFReceived();
member
public: list chunked;
member
public: list error;
member
public: integer buffer_size;
member
public: list buffer;
member
public: string command;
member
public: integer content_block_size;
member
public: list contents;
member
public: integer response_code;
member
public: list cert_info;
member
public: static list connections;
member
public: static list hostaddr_cache;
member
public: static integer connect_timeout;
end_class
class HttpServlet
member
public: void doGet(HttpRequest req, HttpResponse res);
member
public: void doPost(HttpRequest req, HttpResponse res);
member
public: static list servlet_params;
member
public: string toUTF8(string str);
member
public: string toUTF8_direct(string str);
member
public: string fromUTF8(string str);
member
public: string fromUTF8(list str);
class WebUIServlet
member
public: void doGet(HttpRequest req, HttpResponse res);
member
public: void doPost(HttpRequest req, HttpResponse res);
member
public: void doAction(list params);
member
public: list get_arg_dcl(list params, DbConnection conn);
member
public: list invokeLogin(list params, DbConnection conn);
member
public: list invokeLogout(list params, DbConnection conn);
member
public: list authorize(list params, DbConnection conn);
member
public: list authorize2(list params, DbConnection conn);
member
public: list checkUserRole(string role_name);
member
public: list checkUserRole(DbConnection conn);
member
public: string action;
member
public: string target;
member
public: string admin_target;
member
public: string user_name;
member
public: list user_roles;
member
public: void error(string msg);
member
public: void error(string msg, AlException e);
member
public: HttpRequest req;
member
public: HttpResponse res;
member
public: HttpSession session;
member
public: static string pool_name;
member
public: list invokeWebUiAdminHome(list params, DbConnection conn);
member
public: list invokeWebUiAdminMenuEdit(list params, DbConnection conn);
member
public: list invokeWebUiAdminViewHome(list params, DbConnection conn);
member
public: list invokeWebUiAdminViewEdit(list params, DbConnection conn);
member
public: list invokeWebUiAdminSelectableHome(list params, DbConnection conn);
member
public: list invokeWebUiAdminSelectableEdit(list params, DbConnection conn);
member
public: XmlDbObject findItem(list itr, integer line_number);
member
public: XmlDbObject findItem(list itr, string path, string value);
member
public: integer max_line_number;
member
public: void incLineNumber(list itr);
member
public: void decLineNumber(list itr);
member
public: list invokeAdminHome(list params, DbConnection conn);
member
public: list invokeAdminMenu(list params, DbConnection conn);
member
public: list menu(list params, DbConnection conn);
member
public: string adminMenuTarget(string target, string user_name);
member
public: list invokeView(list params, DbConnection conn);
member
public: string getValue(string name);
member
public: XmlDbObject getSingle(XmlDbAccessor acc, list cond);
member
public: XmlDbObject getSingle(XmlDbObject obj, string path, list cond);
member
public: list getMultiple(XmlDbAccessor acc, list cond);
member
public: list getMultiple(XmlDbObject obj, string path, list cond);
member
public: list getMultiple(XmlDbAccessor acc, list cond, string range_path, string range_type, string from, string to, string order_path, string order_type, list desc);
member
public: list getMultiple(XmlDbObject obj, string path, list cond, string range_path, string range_type, string from, string to, string order_path, string order_type, list desc);
member
public: list checkPath(string msgType, string msgVersion, string dtd_filename, string path, DbConnection conn);
member
public: list checkFromTo(string from, string to);
member
public: list invokeSystemLog(list params, DbConnection conn);
member
public: list invokeAccessLog(list params, DbConnection conn);
member
public: list invokeUser(list params, DbConnection conn);
member
public: XmlDbObject getUser(XmlDbAccessor acc, string user, DbConnection conn);
member
public: list invokeRestart(list params, DbConnection conn);
member
public: list invokeShutdown(list params, DbConnection conn);
member
public: list invokeCacheClear(list params, DbConnection conn);
member
public: list invokeGC(list params, DbConnection conn);
member
public: list invokeShell(list params, DbConnection conn);
member
public: void genPageBegin(string title);
member
public: void genRefreshPageBegin(string title, integer interval);
member
public: void genPageEnd();
member
public: void genFormBegin(string action, list upload);
member
public: void genFormEnd();
member
public: void genTitle(string text);
member
public: void genText(string text);
member
public: void genLink(string path, string text);
member
public: void genBR();
member
public: void genHR();
member
public: void genButton(string name, string value);
member
public: void genTextField(string name, integer size, string value);
member
public: void genPassword(string name, integer size, string value);
member
public: void genTextArea(string name, integer rows, integer cols, string value);
member
public: void genCheck(string name, string text, list checked);
member
public: void genRadio(string name, string value, string text, list checked);
member
public: void genHidden(string name, string value);
member
public: void genUpload(string name);
member
public: void genSelect(string name, list values);
member
public: void genTable1(XmlDbObject obj, list visibles, list editables, list passwords, list io_map);
member
public: void genTable2(list objs, list visibles, list checks, list radio, integer count_from, integer count_max, list io_map);
member
public: string toUTF8(string str);
member
public: string fromUTF8(string str);
member
public: string fromUTF8(list str);
member
public: void dumpProps(list params);
member
public: string date_str(list datetime);
member
public: string date_str_2(list datetime);
member
public: list date_xml(list datetime);
member
public: string from_date_html(list xml);
member
public: string to_date_html(list xml);
member
public: integer date_int(string date_str);
end_class
end_class
class HttpRequest
member
public: WebServer _server;
member
public: HttpResponse _response;
member
public: string _command;
member
public: string _path;
member
public: string _params;
member
public: list bin_raw_http_header;
member
public: list headers;
member
public: string fromIP;
member
public: list cert_info;
member
public: list input;
member
public: string input_file;
member
public: list getParameters();
member
public: string getParameter(string name);
member
public: list parameters;
member
public: HttpSession createSession();
member
public: HttpSession getSession();
member
public: list getCookies();
member
public: string getCookie(string name);
member
public: list cookies;
member
public: string getBasePath();
member
public: static list splitNameValue(string name_value);
end_class
class HttpResponse
member
public: void _create();
member
public: HttpRequest _request;
member
public: integer response_code;
member
public: list headers;
member
public: list output;
member
public: integer max_size;
member
public: integer content_length;
member
public: void out(string s);
member
public: void out(list binary);
member
public: void out(list binary, integer index, integer size);
member
public: void redirect(string url);
member
public: void redirectWithSession(string url);
member
public: WebServer _server;
member
public: string http_ver;
member
public: string system_command;
member
public: string response_filepath;
member
public: string response_content_disposition;
end_class
class HttpSession
member
public: void _create(WebServer server);
member
public: WebServer _server;
member
public: string _sessionId;
member
public: integer _time;
member
public: void invalidate();
member
public: list getAttributes();
member
public: list getAttribute(string name);
member
public: void setAttribute(string name, list attr);
member
public: void setAttribute(string name, integer attr);
member
public: void setAttribute(string name, string attr);
member
public: void setAttribute(string name, AlObject attr);
member
public: list attrs;
end_class
end_class
class MultipartSecureMessage
member
public: void setHeader(string name, string value);
member
public: void addHeaderSubType(string name, string subtype, string value);
member
public: void setBodyHeader(string name, string value);
member
public: void addBodyHeaderSubType(string name, string subtype, string value);
member
public: void addBodyText(string text);
member
public: void addBodyFile(string filename);
member
public: void addBodyBinary(list content_bin, integer from, integer content_len);
member
public: void addMultipartSecureMessage(MultipartSecureMessage msm);
member
public: string _genContentType();
member
public: void writeHeader(file out);
member
public: void writeMultipart(file out);
member
public: void writeMultipartMessage(file out);
member
public: list header;
member
public: list body_header;
member
public: list body_header_bin;
member
public: integer body_index;
member
public: list body_content;
member
public: void readMultipartMessage(string filename);
member
public: void readMultipartMessage(list bin, integer size);
member
public: void readMultipartMessage2(list bin, integer size);
member
public: string getHeader(string name);
member
public: string getHeaderSubType(string name, string subtype);
member
public: integer getCount();
member
public: string getBodyHeader(integer index, string name);
member
public: string getBodyHeaderSubType(integer index, string name, string subtype);
member
public: string getBodyText(integer index);
member
public: list getBodyBinary(integer index);
member
public: void getBody(integer index);
member
public: list multipart;
member
public: void encrypt(string cipher, string cert);
member
public: void sign(string cert, string key);
member
public: list isEncrypted(integer index);
member
public: void decrypt(integer index, string cert, string key);
member
public: list isSigned();
member
public: list verify(string cert, string ca_cert);
member
public: void multipartToOneBody();
member
public: void oneBodyToMultipart(integer index);
member
public: static void getBody(string in_file, string name, string out_file);
end_class
class ProxyServer
member
public: string name;
member
public: integer port;
member
public: integer connect_timeout;
member
public: ProxyServerConnectionMgr conn_mgr;
member
public: integer connectionTimeout;
member
public: AltairServer ap_server;
member
public: integer maxMsgSize;
member
public: void proxy_log(string fromIP, string path, string reason);
member
public: string proxy_log_filepath;
member
public: string proxy_log_db;
member
public: void error_log(string str);
class ProxyServerConnectionMgr
member
public: ProxyServer server;
member
public: list connections;
member
public: integer server_socket_id;
member
public: integer hwnd;
member
public: integer msg;
end_class
class ProxyServerConnection
member
public: void close();
member
public: ProxyServer server;
member
public: integer socket_id;
member
public: integer hwnd;
member
public: integer msg;
member
public: integer msg2;
member
public: integer _time;
member
public: void startReceiveHeaders();
member
public: void startReceive();
member
public: void headersReceived();
member
public: void received();
member
public: integer buffer_size;
member
public: list buffer;
member
public: string command_line;
member
public: string command;
member
public: string request_url;
member
public: string path;
member
public: string http_ver;
member
public: list headers;
member
public: list send(string str);
member
public: list send(list binary);
member
public: list send(list binary, integer index, integer size);
member
public: void sendCompleted();
member
public: string send_status;
member
public: list exiting;
member
public: file in;
member
public: string fromIP;
member
public: ProxyClientConnection conn;
member
public: list sending;
end_class
class ProxyClientConnection
member
public: list create(ProxyServer server, string url);
member
public: ProxyServer server;
member
public: list connect();
member
public: void close();
member
public: string url;
member
public: list ssl;
member
public: string host;
member
public: integer port;
member
public: string path;
member
public: integer socket_id;
member
public: integer hwnd;
member
public: integer msg;
member
public: integer msg2;
member
public: integer _time;
member
public: void setTimeout(integer sec);
member
public: integer timeout;
member
public: list send(string str);
member
public: list send(list binary);
member
public: list send(list binary, integer index, integer size);
member
public: void sendCompleted();
member
public: list startReceiveCommand();
member
public: list startReceiveHeaders();
member
public: list startReceive();
member
public: void commandReceived();
member
public: void headersReceived();
member
public: void received();
member
public: list error;
member
public: integer buffer_size;
member
public: list buffer;
member
public: string command_line;
member
public: list headers;
member
public: integer content_length;
member
public: integer total_read_bytes;
member
public: static list connections;
member
public: ProxyServerConnection conn;
member
public: static list hostaddr_cache;
end_class
end_class
class XmlUtility
member
public: static void Initialize();
member
public: static list init;
member
public: static string ctrl_a;
member
public: static list parseXML(string xml, list debug);
member
public: static list parseXML(file in, list debug);
member
public: static list parseXML(string filename);
member
public: static string xslTransform(string xsl_filename, list xml);
member
public: static string getDocType(list parse_tree);
member
public: static string getDTDfile(list parse_tree);
member
public: static list loadDTD(string filename);
member
public: static list loadXmlSchema(string filename);
member
public: static list loadXSL(string filename);
member
public: static void validateXML(list dtd, list parse_tree);
member
public: static string dtd_base;
member
public: static string xsl_base;
member
public: static string content_validation_base;
member
public: static list dtd_cache;
member
public: static list xsl_cache;
member
public: static XmlDbObject createMsgData(string msgId, string msgType, string msgVersion, string dtdFilename, DbConnection conn);
member
public: static XmlDbObject getMsgData(string msgId, string msgType, string msgVersion, string dtdFilename, DbConnection conn);
member
public: list isLike(string value);
member
public: void skip_optional();
member
public: void skip_choice();
member
public: void skip_case();
member
public: void skip_all_opt();
member
public: DtdItr dtd_itr;
member
public: list content_validate;
member
public: string validation_errors;
member
public: static list content_validation_report;
class XmlSchemaLoader
end_class
class DtdLoader
member
public: list read_entities(file in);
member
public: list apply_entities(file in, file out);
member
public: list entities;
member
public: list read_element(file in);
member
public: list elems;
member
public: list root_elem;
member
public: list elem_attr(file in);
member
public: list load_elem(file in);
member
public: list load_elem1(file in);
member
public: list load_elem2(file in);
member
public: list load_elem_tag(file in);
member
public: list load_elem_empty_any(file in);
member
public: list load_elem_data(file in);
member
public: list add_attr(list elem, file in);
member
public: list attr;
member
public: list load_attr_choice(file in);
member
public: void normalize();
member
public: list check_recursive(list elem, list tags);
member
public: list check_recursive(list ret, string tag);
member
public: list data_duplicate;
member
public: void error_log(string s);
member
public: void warning_log(string s);
member
public: void info_log(string s);
member
public: list log_level;
member
public: static void attach_content_validation_data(list dtd, string csv_filename);
member
public: static void get_node(list ret, list elem, string xpath);
class ExtendedDtdLoader
member
public: list read_element(file in);
member
public: list elem_attr(file in);
member
public: list add_attr(list elem, file in);
end_class
end_class
class DtdItr
member
public: void Reset(list node0);
member
public: list Next(list skip_flag);
member
public: list pop();
member
public: list stack;
member
public: list type;
member
public: list node;
member
public: list opt;
member
public: void ContinueRepetition();
member
public: void BreakRepetition();
member
public: list repetition_stack;
member
public: string abs_xpath;
member
public: string rel_xpath;
member
public: string attr;
member
public: string tag;
member
public: list xpath_stack;
member
public: void expand_recursive();
member
public: void mark(list elem);
member
public: void unmark(list elem);
member
public: list recursive_expanded;
member
public: string repetition_tag;
member
public: DtdHandler handler;
member
public: DtdItr Copy();
member
public: list stack_copy(list stack);
member
public: list repetition_stack_copy(list repetition_stack);
member
public: list getFieldList();
member
public: list getChildList();
member
public: DtdItr getChild(string xpath);
member
public: list getFieldList2();
member
public: list getChild2(string xpath);
member
public: list tag2;
member
public: list ns_stack;
member
public: list all_tag;
end_class
class DtdHandler
member
public: void startElement(string tag);
member
public: void endElement(string tag);
member
public: void setNamespace(string name);
class XmlComposerHandler
member
public: void startElement(string tag);
member
public: void endElement(string tag);
member
public: void setNamespace(string name);
member
public: XmlComposer composer;
member
public: void out_current_tag();
member
public: string current_tag;
member
public: list current_attrs;
member
public: string current_value;
member
public: string raw_current_value;
member
public: void out_str(string val);
member
public: string ns_name;
member
public: list ns_names;
end_class
end_class
class XmlItr
member
public: void Reset(list parse_tree);
member
public: list Next();
member
public: list Next2();
member
public: list Next3();
member
public: list Next3(string prev_rept_xpath);
member
public: list stack;
member
public: list xpath;
member
public: string value;
member
public: list getNext(string xpath, string attr);
member
public: list getNext(string prev_rept_xpath, string xpath, string attr);
member
public: list getAttribute(list tag, string attr);
member
public: list getNodeAsText(string xpath);
member
public: XmlItr Copy();
member
public: void Copy(XmlItr xml_itr);
end_class
class XmlValidator
member
public: list validate(list dtd, list xml);
member
public: list validate1(XmlItr xml_itr);
member
public: void save;
member
public: void Begin();
member
public: void End();
member
public: void BeginRepetition(string abs_xpath, string xpath);
member
public: void ContinueRepetition();
member
public: void BreakRepetition();
member
public: string getMsgId();
member
public: string msgType;
member
public: string msgVersion;
member
public: string putValue(string kind, string xpath, string value);
member
public: void Flush();
member
public: string XPath2TagId(string xpath);
member
public: string dataId;
member
public: string msgId;
member
public: string parentId;
member
public: string tagId;
member
public: integer child_seq;
member
public: integer field_seq;
member
public: string last_repetition_xpath;
member
public: list values;
member
public: list stack;
member
public: integer read_tag_count;
member
public: integer read_elem_count;
member
public: integer read_recursive_tag_count;
class SimpleXml2Db
member
public: void Begin();
member
public: void End();
member
public: void BeginRepetition(string abs_xpath, string xpath);
member
public: void ContinueRepetition();
member
public: void BreakRepetition();
member
public: string getMsgId();
member
public: string putValue(string kind, string xpath, string value);
member
public: void Flush();
member
public: string getTagId();
member
public: string XPath2TagId(string xpath);
member
public: void createXPathTagIdMap();
member
public: list map;
member
public: DbConnection conn;
member
public: string db_type;
member
public: XmlDbAccessor acc;
end_class
end_class
class XmlComposer
member
public: list compose(list dtd);
member
public: list compose1();
member
public: void clear();
member
public: string recursive_check_xpath(string xpath);
member
public: string doctype;
member
public: string dtd_filename;
member
public: string xml;
member
public: void out_str(string val);
member
public: list Begin();
member
public: list GetFields();
member
public: list GetChildren(string path);
member
public: list nextChild();
member
public: void BreakRepetition();
member
public: string getValue(string path);
member
public: string msgType;
member
public: string msgVersion;
member
public: string value;
member
public: XmlComposerHandler handler;
member
public: integer read_tag_count;
member
public: list recursive_expand_tag_count;
class SimpleDb2Xml
member
public: list Begin();
member
public: list GetFields();
member
public: list GetChildren(string path);
member
public: list nextChild();
member
public: void BreakRepetition();
member
public: string getValue(string path);
member
public: void createTagIdPathMap();
member
public: string dataId;
member
public: string msgId;
member
public: string parentId;
member
public: string tagId;
member
public: list values;
member
public: list children;
member
public: list stack;
member
public: list map;
member
public: list map2;
member
public: DbConnection conn;
member
public: string db_type;
member
public: XmlDbAccessor acc;
end_class
end_class
class XmlDataRetriver
member
public: void create(list tree);
member
public: list tag_tree;
member
public: list body_tree;
member
public: list itr;
member
public: string tag;
member
public: XmlDataRetriver getItr(string xpath);
member
public: XmlDataRetriver getNext();
member
public: string getValue(string xpath);
end_class
class XmlDbAccessor
member
public: void create(string msgType, string msgVersion, DbConnection conn);
member
public: void setDTD(list dtd);
member
public: void setDTDbase(string dtd_base);
member
public: void setDTDfilename(string dtd_filename);
member
public: void setContentValidationBase(string content_validation_base);
member
public: void setContentValidation(list flag);
member
public: void setDocType(string doc_type);
member
public: string putXML(string xml);
member
public: string putXML(string xml, string msgId);
member
public: string putXML(list parse_tree, string msgId);
member
public: string getXML(string msgId);
member
public: XmlDbObject create();
member
public: XmlDbObject create(string msgId);
member
public: XmlDbObject getMetaInfo();
member
public: XmlDbObject get(string msgId);
member
public: XmlDbObject getWithMsgTypeAndMsgVersion(string msgId);
member
public: list getAll();
member
public: list get(string path, string value);
member
public: list get(string path1, string value1, string path2, string value2);
member
public: list get(string path1, string value1, string path2, string value2, string path3, string value3);
member
public: list get(list cond);
member
public: list get(list cond, string range_path, string range_type, string from, string to, string orderby_path, string orderby_type, list desc);
member
public: string msgType;
member
public: string msgVersion;
member
public: DbConnection conn;
member
public: string db_type;
member
public: list _dtd;
member
public: string _dtd_base;
member
public: string _content_validation_base;
member
public: string _dtd_filename;
member
public: string _doc_type;
member
public: void createTagPathMap();
member
public: string getTagId();
member
public: string XPath2TagId(string xpath);
member
public: list map;
member
public: list map2;
member
public: string getMsgId();
member
public: static string digit5(integer val);
member
public: void createFieldList();
member
public: list xpath_list;
member
public: DtdItr dtd_itr;
member
public: integer count_max;
class XmlDbTableAccessor
member
public: string putXML(list parse_tree, string msgId);
member
public: string getXML(string msgId);
member
public: XmlDbObject create();
member
public: XmlDbObject create(string msgId);
member
public: XmlDbObject get(string msgId);
member
public: list get(list cond);
member
public: list get(list cond, string range_path, string range_type, string from, string to, string orderby_path, string orderby_type, list desc);
member
public: void createFieldList2();
member
public: string table_name;
member
public: string pkey_names;
member
public: list rev_xpath_list;
end_class
end_class
class XmlDbObject
member
public: static integer MAX_VALUE_SIZE;
member
public: string msgType;
member
public: string msgVersion;
member
public: DbConnection conn;
member
public: string db_type;
member
public: XmlDbAccessor acc;
member
public: string dataId;
member
public: string msgId;
member
public: string parentId;
member
public: string tagId;
member
public: integer field_seq;
member
public: integer child_seq;
member
public: void putField(string path, string value);
member
public: void removeField(string path);
member
public: XmlDbObject createChild(string path);
member
public: XmlDbObject getMetaInfo(string path);
member
public: string getField(string path);
member
public: list getChildren(string path);
member
public: list getChildren(string path, string path1, string value1);
member
public: list getChildren(string path, string path1, string value1, string path2, string value2);
member
public: list getChildren(string path, list cond);
member
public: list getChildren(string path, list cond, string range_path, string range_type, string from, string to, string orderby_path, string orderby_type, list desc);
member
public: void fetch();
member
public: list values;
member
public: void delete();
member
public: list fetched;
member
public: DtdItr dtd_itr;
member
public: list xpath_list;
member
public: integer count_max;
class XmlDbTableObject
member
public: void putField(string path, string value);
member
public: void removeField(string path);
member
public: XmlDbObject createChild(string path);
member
public: void delete();
member
public: string getField(string path);
member
public: list getChildren(string path, list cond);
member
public: list getChildren(string path, list cond, string range_path, string range_type, string from, string to, string orderby_path, string orderby_type, list desc);
member
public: void fetch();
member
public: list table_name;
member
public: list pkey_values;
member
public: list rev_xpath_list;
end_class
end_class
class Csv1Data
member
public: void loadCSV(string filename);
member
public: list root_csv_data;
class Csv1DataItr
member
public: void Reset(list csv_data);
member
public: void Reset();
member
public: list base_csv_data;
member
public: list csv_data_itr;
member
public: list nextRow();
member
public: string parent_id;
member
public: string child_id;
member
public: string dst_path;
member
public: string src_path;
member
public: string value;
member
public: Csv1Data nextChild();
member
public: Csv1Data nextChild(string name);
member
public: string base_parent_name;
member
public: string base_parent_id;
member
public: string base_child_id;
member
public: string base_dst_path;
member
public: string base_src_path;
member
public: string base_value;
end_class
end_class
end_class
class DbUtility
member
public: string convChar(string str);
class DbConnection
member
public: void prepare(string sql);
member
public: list executeQuery(integer num_cols, list values);
member
public: void executeUpdate(list values);
member
public: list executeQuery(integer num_cols, string sql);
member
public: void executeUpdate(string sql);
member
public: list nextResultSet();
member
public: void setMaxResultSet(integer count);
member
public: void clearMaxResultSet();
member
public: string getNextSeq(string sequenceName);
member
public: void commit();
member
public: void rollback();
member
public: void close();
member
public: list connection;
member
public: list statement;
member
public: list types;
member
public: integer max_result_set;
member
public: string db_type;
member
public: DbConnectionPool pool;
member
public: list in_transaction;
class DbPoolConnection
member
public: void close();
end_class
end_class
class DbConnectionPool
member
public: AltairServer ap_server;
member
public: void start();
member
public: void stop();
member
public: string pool_name;
member
public: DbConnection getConnection();
member
public: string db_type;
member
public: string host;
member
public: string port;
member
public: string db_name;
member
public: string user;
member
public: string pass;
member
public: list free_connections;
member
public: list used_connections;
member
public: integer initial_connections;
member
public: integer max_connections;
member
public: integer num_connections;
member
public: void sql_trace_log(string str);
member
public: string sql_trace_log_filepath;
end_class
class DbManager
member
public: static list createPool(DbConnectionPool pool, string pool_name);
member
public: static void closeAllPools();
member
public: static string getDbType(string pool_name);
member
public: static DbConnection getConnection(string pool_name);
member
public: static list pools;
member
public: static DbConnection getConnection(string db_type, string host, string port, string db_name, string user, string pass);
end_class
end_class
class FileUtility
member
public: static string tempFile();
member
public: static list readBinary(string filename);
member
public: static string readString(string filename);
member
public: static void writeBinary(string filename, list bin);
member
public: static void writeBinary(string filename, list bin, integer from, integer size);
member
public: static void writeBinary(string filename, string str);
member
public: static void appendBinary(string filename, list bin);
member
public: static void appendBinary(string filename, list bin, integer from, integer size);
member
public: static void appendBinary(string filename, string str);
member
public: static void writeString(string filename, string str);
member
public: static void appendString(string filename, string str);
member
public: static list readGraphData(string filename);
member
public: static void writeGraphData(string filename, list data);
member
public: static void remove(string dir);
member
public: static void makeReadOnly(string dir);
member
public: static void makeWritable(string dir);
member
public: static void makeWritable();
class FileItr
member
public: void Reset(string root);
member
public: list Next();
member
public: list stack;
member
public: string root;
member
public: string path;
member
public: string name;
member
public: string abs_path;
member
public: list is_dir;
end_class
class RevFileItr
member
public: void Reset(string root);
member
public: list Next();
member
public: list stack;
member
public: string root;
member
public: string path;
member
public: string name;
member
public: string abs_path;
member
public: list is_dir;
end_class
end_class
class Context
member
public: static string genTimeStamp();
member
public: static string genTimeStamp(integer diff);
member
public: static string genTimeStamp2();
member
public: static string genMsgId();
member
public: static integer msg_seq;
end_class
class InitDB
member
public: static void init_all();
member
public: void init();
member
public: void init_system();
member
public: void init_system_user();
member
public: void init_system_webuidata();
member
public: DbConnection conn;
member
public: static void upate();
member
public: void _update();
end_class
end_class
$END_MEMBER
TEXT
AlObject
class AltairServer
member
public: static void start();
body
{
	if (appServer) {
		al_print("[Error] Server already started.\n");
		return;
	} else {
	}
	appServer = new AltairServer;
	var string err;
	if (err = appServer.startServer()) {
		al_print("[Error] fail to start server.(" + err + ")\n");
		appServer.shutdownServer();
		appServer = null;
	} else {
	}
}
end_body
member
public: static void shutdown();
body
{
	if (appServer == null) {
		al_print("[Error] Server not started.\n");
		return;
	} else {
	}
	appServer.shutdownServer();
	appServer = null;
	al_gc(null);
	al_gp("vtbl", null, null, null, null);
}
end_body
member
public: static void restart();
body
{
	shutdown();
	start();
}
end_body
member
public: static void start_trace();
body
{
	var list prof, cls;
	cls = al_cons(null, null);
	al_create_arc(cls, "DbManager", null);
	al_create_arc(cls, "DbConnection", null);
	al_create_arc(cls, "DbPoolConnection", null);
	al_create_arc(cls, "DbConnectionPool", null);
	al_create_arc(cls, "ProcMgr", null);
	al_create_arc(cls, "ProcSched", null);
	al_create_arc(cls, "ServiceHandler", null);
	al_create_arc(cls, "RNIF20ServiceHandler", null);
	if (al_misc("platform", null, null) == "windows") {
		prof = al_list2(2, "C:/altair/sample/server/log/log.txt");
	} else {
	}
	if (al_misc("platform", null, null) == "linux" || al_misc("platform", null, null) == "mac") {
		prof = al_list2(2, "/proj/altair/data/server/log/log.txt");
	} else {
	}
	al_prof("set", "prof", cls);
	al_prof("start", "prof", prof);
}
end_body
member
public: static void stop_trace();
body
{
	al_prof("stop", "prof", null);
	al_prof("clear", "prof", null);
}
end_body
member
public: static void remote_shutdown();
body
{
	shutdown();
	al_misc("exit", 0, null);
}
end_body
member
public: static void remote_restart();
body
{
	restart();
}
end_body
member
public: static AltairServer appServer;
member
public: list startServer();
body
{
	var string err;
	var XmlDataRetriver root, itr, web_server_info, itr2, ssl_info, servlet_info;
	var XmlDataRetriver proxy_server_info, itr3, servlet_param_info, client_info;
	var XmlDataRetriver db_pool_info, pe_info, xml_info;
	// ---- load configuration
	if (err = load_config()) {
		return err;
	} else {
	}
	root = new XmlDataRetriver;
	root.create(config);
	// ---- initialize log file
	logObj = new LogObj;
	logObj.init();
	var integer size;
	size = (integer)root.getValue("AltairServer/MaxLogSize") * 1024;
	if (al_is_type(size, "integer") == null || size < 1) {
		size = 1000;
	} else {
	}
	LogObj::max_size = size;
	system_log_filepath = root.getValue("AltairServer/SystemLog");
	system_log_db = (root.getValue("AltairServer/SystemLogDb") == "true");
	// ---- GC
	gc_interval = (integer)root.getValue("AltairServer/GcInterval");
	_gc_time = 0;
	// ---- create DB connection pool
	var list startup_started_log;
	itr = root.getItr("AltairServer/DbConnectionPool");
	loop {
		if (db_pool_info = itr.getNext()) {
		} else {
			break;
		}
		var DbConnectionPool pool;
		pool = new DbConnectionPool;
		pool.ap_server = this;
		pool.pool_name = db_pool_info.getValue("@name");
		if (pool_name) {
		} else {
			pool_name = pool.pool_name;
			WebUIServlet::pool_name = pool.pool_name;
		}
		pool.sql_trace_log_filepath = db_pool_info.getValue("SqlTraceLog");
		pool.db_type = db_pool_info.getValue("DbType");
		pool.host = db_pool_info.getValue("Host");
		pool.port = (integer)db_pool_info.getValue("Port");
		pool.db_name = db_pool_info.getValue("DbName");
		pool.user = db_pool_info.getValue("DbUser");
		pool.pass = db_pool_info.getValue("DbPassword");
		pool.initial_connections = (integer)db_pool_info.getValue("InitialCapacity");
		pool.max_connections = (integer)db_pool_info.getValue("MaxCapacity");
		err = DbManager::createPool(pool, pool.pool_name);
		if (err) {
			system_log("error", "DB Connection Pool Creation falied: pool_name = " + (string)pool.pool_name + ": " + err);
			return err;
		} else {
		}
		if (startup_started_log) {
		} else {
			startup_started_log = 1;
			system_log("info", ">>>>>>>>> system startup started.");
		}
		system_log("info", "DB Connection pool created: pool_name = " + (string)pool.pool_name);
	}
	// ---- initialize XmlUtility
	XmlUtility::Initialize();
	itr = root.getItr("AltairServer/XmlUtility");
	loop {
		if (xml_info = itr.getNext()) {
		} else {
			break;
		}
		XmlUtility::dtd_base = xml_info.getValue("DtdBase");
		XmlUtility::xsl_base = xml_info.getValue("XslBase");
		XmlDbObject::MAX_VALUE_SIZE = (integer)xml_info.getValue("DbObjectMaxValueLength");
		XmlUtility::content_validation_base = xml_info.getValue("ContentValidationBase");
	}
	// ---- start web servers
	web_servers = al_cons(null, null);
	itr = root.getItr("AltairServer/WebServer");
	loop {
		if (web_server_info = itr.getNext()) {
		} else {
			break;
		}
		var WebServer web_server;
		web_server = new WebServer;
		web_server.ap_server = this;
		web_server.name = web_server_info.getValue("@name");
		web_server.port = (integer)web_server_info.getValue("Port");
		web_server.documentRoot = web_server_info.getValue("DocumentRoot");
		web_server.access_log_filepath = web_server_info.getValue("AccessLog");
		web_server.access_log_db = (web_server_info.getValue("AccessLogDb") == "true");
		itr2 = web_server_info.getItr("SSL");
		if (ssl_info = itr2.getNext()) {
			web_server.ssl = 1;
			web_server.ca_cert = ssl_info.getValue("caCert");
			web_server.cert = ssl_info.getValue("serverCert");
			web_server.key = ssl_info.getValue("serverKey");
			web_server.clientAuth = (ssl_info.getValue("clientAuth") == "true" ? 1 : 0);
			web_server.dhparam = ssl_info.getValue("dhParam");
			web_server.cipher = ssl_info.getValue("cipher");
		} else {
		}
		web_server.connectionTimeout = (integer)web_server_info.getValue("ConnectionTimeout");
		web_server.sessionTimeout = (integer)web_server_info.getValue("SessionTimeout");
		web_server.maxMsgSize = (integer)web_server_info.getValue("MaxMessageSize");
		web_server.servlet_list = al_cons(null, null);
		itr2 = web_server_info.getItr("Servlet");
		web_server.servlet_param_list = al_cons(null, null);
		loop {
			if (servlet_info = itr2.getNext()) {
			} else {
				break;
			}
			var string path, class_name;
			path = servlet_info.getValue("Path");
			class_name = servlet_info.getValue("Class");
			al_create_arc(web_server.servlet_list, class_name, path);
			var list nvls;
			al_create_arc(web_server.servlet_param_list, nvls = al_cons(null, null), class_name);
			itr3 = servlet_info.getItr("Param");
			loop {
				if (servlet_param_info = itr3.getNext()) {
				} else {
					break;
				}
				var string name, value;
				name = servlet_param_info.getValue("Name");
				value = servlet_param_info.getValue("Value");
				if (name && value) {
					al_set_dst_node(nvls, name, value);
				} else {
				}
			}
		}
		web_server.upload_servlet_list = al_cons(null, null);
		itr2 = web_server_info.getItr("UploadServlet");
		loop {
			if (servlet_info = itr2.getNext()) {
			} else {
				break;
			}
			var string path, class_name;
			path = servlet_info.getValue("Path");
			class_name = servlet_info.getValue("Class");
			al_create_arc(web_server.upload_servlet_list, class_name, path);
		}
		al_create_arc(web_servers, web_server, null);
		if (err = web_server.start()) {
			system_log("error", "Web Server Startup failed: " + err);
			return err;
		} else {
		}
		system_log("info", "WebServer started: port = " + (string)web_server.port + ", SSL = " + (string)(web_server.ssl ? "true" : "false"));
	}
	// ---- start timer
	var list cb;
	timer_id = al_get_id();
	cb = al_list3(al_root_class(), this, AltairServer::timeoutCheck);
	al_gui_misc("timer", al_list2(timer_id, 1000), cb);
	// ---- write startup log
	system_log("info", "<<<<<<<<< system startup completed.");
	return null;
}
end_body
member
public: void shutdownServer();
body
{
	system_log("info", ">>>>>>>>> shutdown system immediately.");
	if (timer_id) {
		al_gui_misc("timer", al_list2(timer_id, 1000), null);
		al_release_id(timer_id);
		timer_id = null;
	} else {
	}
	var list itr;
	var WebServer web_server;
	itr = al_dst_itr(web_servers);
	loop {
		if (web_server = al_next(itr)) {
		} else {
			break;
		}
		web_server.stop();
		web_server.ap_server = null;
	}
	web_servers = null;
	var HttpClientConnection conn;
	if (HttpClientConnection::connections) {
		itr = al_dst_itr(HttpClientConnection::connections);
		loop {
			if (conn = al_next(itr)) {
			} else {
				break;
			}
			al_prev(itr);
			conn.close();
		}
	} else {
	}
	DbManager::closeAllPools();
	XmlUtility::dtd_cache = null;
	if (logObj) {
		logObj.finalize();
		logObj = null;
	} else {
	}
}
end_body
member
public: list load_config();
body
{
	var file f;
	if (f = al_file_open("config.xml", "r")) {
	} else {
		return "config.xml nof found.";
	}
	var list tree_err;
	tree_err = al_xml("parse", f, null, null);
	if (tree_err.tail.head) {
		return "fail to parse config.xml.";
	} else {
	}
	config = tree_err.head;
	return null;
}
end_body
member
public: list config;
member
public: list web_servers;
member
public: string pool_name;
member
public: void log(string filepath, string str);
body
{
	if (logObj) {
		logObj.log(filepath, str);
	} else {
	}
}
end_body
member
public: void system_log(string level, string str);
body
{
	if (system_log_filepath) {
		log(system_log_filepath, level + ": " + str);
	} else {
	}
	if (system_log_db) {
		var DbConnection conn;
		var string db_type;
		try {
			conn = DbManager::getConnection(pool_name);
			db_type = DbManager::getDbType(pool_name);
			var string sql, time;
			time = al_misc("get_time", null, null);
			time = al_misc("get_localtime", time, null);
			time = al_misc("format_time", time, "yyyy'/'MM'/'dd'-'HH':'mm':'ss");
			sql = al_copy("insert into SystemLog (SystemLogId, Time, LogLevel, Message) values ('");
			al_append_str(sql, conn.getNextSeq("SystemLogId_seq"));
			al_append_str(sql, "','");
			al_append_str(sql, time);
			al_append_str(sql, "','");
			al_append_str(sql, (string)level);
			al_append_str(sql, "','");
			al_append_str(sql, DbUtility::convChar((string)str));
			al_append_str(sql, "')");
			conn.executeUpdate(sql);
			conn.commit();
			conn.close();
		} catch (AlException e) {
			if (conn) {
				try {
					conn.rollback();
				} catch (AlException e) {
				}
				try {
					conn.close();
				} catch (AlException e) {
				}
			} else {
			}
		}
	} else {
	}
}
end_body
member
public: string system_log_filepath;
member
public: string system_log_db;
member
public: LogObj logObj;
member
public: static integer getTime(string time);
body
{
	var integer val, ch;
	val = (integer)time;
	if (al_is_type(time, "string") && al_strlen(time) > 1) {
		ch = al_get_char(time, al_strlen(time) - 1);
	} else {
	}
	if (ch == 's' || ch == 'S') {
		val = val;
	} else {
	}
	if (ch == 'm' || ch == 'M') {
		val = val * 60;
	} else {
	}
	if (ch == 'h' || ch == 'H') {
		val = val * 60 * 60;
	} else {
	}
	if (ch == 'd' || ch == 'D') {
		val = val * 24 * 60 * 60;
	} else {
	}
	return val;
}
end_body
member
public: void timeoutCheck();
body
{
	var list itr;
	// ---- HttpServerConnection
	var WebServer web_server;
	itr = al_dst_itr(web_servers);
	loop {
		if (web_server = al_next(itr)) {
		} else {
			break;
		}
		web_server.timeoutCheck();
	}
	// ---- HttpClientConnection
	var HttpClientConnection conn;
	if (HttpClientConnection::connections) {
		itr = al_dst_itr(HttpClientConnection::connections);
		loop {
			if (conn = al_next(itr)) {
			} else {
				break;
			}
			conn._time = conn._time + 1;
			if (conn._time >= conn.timeout) {
				al_prev(itr);
				conn.error = "timeout";
				conn.wait_obj.notify();
				conn.close();
			} else {
			}
		}
	} else {
	}
	// ---- garbage collection
	_gc_time = _gc_time + 1;
	if (_gc_time >= gc_interval) {
		var list ls;
		var integer used, recycled, free;
		ls = al_gc(null);
		recycled = ls.head;
		free = ls.tail.head;
		used = ls.tail.tail.head;
		system_log("info", "garbage collection: recycled = " + (string)recycled + ", used = " + (string)used + ", total = " + (string)(recycled + free + used));
		_gc_time = 0;
	} else {
	}
}
end_body
member
public: integer timer_id;
member
public: integer gc_interval;
member
public: integer _gc_time;
member
public: void printStackTrace();
body
{
	try {
		var AlException ex;
		ex = new AlException;
		ex.msg = "stack dump";
		throw ex;
	} catch (AlException e) {
		var list frame, loc_base, loc_base2;
		var integer pos;
		frame = e.stack_frame;
		pos = e.pos;
		loop {
			pos = frame.head.tail.head;
			loc_base = frame.head.tail.tail.tail.head;
			frame = frame.tail;
			if (frame) {
			} else {
				break;
			}
			al_print("===========================\n");
			al_misc("stack_trace", frame, null);
			al_misc("error_source", al_list2(frame, pos), null);
			loop {
				if (loc_base) {
				} else {
					break;
				}
				loc_base2 = loc_base.head;
				loop {
					if (loc_base2) {
					} else {
						break;
					}
					al_print(loc_base2.head.head);
					al_print(" = ");
					al_print(loc_base2.head.tail.head);
					al_print("\n");
					loc_base2 = loc_base2.tail;
				}
				loc_base = loc_base.tail;
			}
		}
	}
}
end_body
member
public: void connection_debug();
body
{
	// ---- dump connection create/close and send/receive
	// debug = 1;
	// ---- dump request/response header to proxy
	// debug2 = 1;
	// ---- dump send proxy message to server/browser
	// debug3 = 1;
	// ---- connection debug log filepath
	// debug_log_file = "./debug.log";
}
end_body
member
public: void xml_debug();
body
{
	// debug = 1;
	// debug2 = 1;
}
end_body
member
public: list debug;
member
public: list debug2;
member
public: list debug3;
member
public: string debug_log_file;
member
public: static void dump_graph(string msg, integer i, list n);
body
{
	al_print(msg + ": node = " + (string)n + "\n");
	dump_graph(0, i, n);
}
end_body
member
public: static void dump_graph(integer indent, integer i, list n);
body
{
	if (i <= 0) {
		return;
	} else {
	}
	var list itr, n2, a2;
	itr = al_dst_itr(n);
	loop {
		if (n2 = al_next(itr)) {
		} else {
			break;
		}
		a2 = al_arc_a(itr);
		var integer k;
		k = 0;
		loop {
			if (k < indent) {
			} else {
				break;
			}
			al_print("    ");
			k = k + 1;
		}
		al_print("-/" + (string)a2 + "/->" + (string)n2 + "\n");
		dump_graph(indent + 1, i - 1, n2);
	}
}
end_body
class LogObj
member
public: void init();
body
{
	log_files = al_cons(null, null);
}
end_body
member
public: void finalize();
body
{
	log_files = null;
}
end_body
member
public: void log(string filepath, string str);
body
{
	if (filepath) {
	} else {
		return;
	}
	var file f;
	if (f = al_dst_node(log_files, filepath)) {
	} else {
		if (f = al_file_open(filepath, "a")) {
		} else {
			al_print("can't create logfile: filepath = " + filepath + "\n");
			al_print("message = \"" + str + "\"\n");
			return;
		}
		al_create_arc(log_files, f, filepath);
	}
	var list date;
	var list date_str;
	date = al_file_manip("current_datetime", null, null);
	date_str = al_misc("format_time", date, "yyyy'/'MM'/'dd' 'HH':'mm':'ss");
	al_file_write(f, "string", date_str + " " + str + "\n");
	al_file_manip("flush", f, null);
	if (al_file_manip("get_size", filepath, null) > max_size) {
		f = null;
		al_set_dst_node(log_files, filepath, null);
		var string filepath2;
		filepath2 = filepath + "." + Context::genTimeStamp();
		al_file_manip("rename", filepath, filepath2);
	} else {
	}
}
end_body
member
public: list log_files;
member
public: static integer max_size;
end_class
class WaitObj
member
public: void wait();
body
{
	if (notified) {
	} else {
		wait_obj = al_wait(null);
		al_wait(wait_obj);
	}
}
end_body
member
public: void notify();
body
{
	if (notified) {
	} else {
		notified = 1;
		if (wait_obj) {
			al_notify(wait_obj);
		} else {
		}
	}
}
end_body
member
public: list notified;
member
public: list wait_obj;
member
public: list value;
member
public: list value2;
end_class
class WebServer
member
public: AltairServer ap_server;
member
public: string name;
member
public: integer port;
member
public: string documentRoot;
member
public: list content_types;
member
public: list servlet_list;
member
public: list upload_servlet_list;
member
public: list servlet_param_list;
member
public: list start();
body
{
	content_types = al_cons(null, null);
	al_create_arc(content_types, "text/html", ".html");
	al_create_arc(content_types, "text/html", ".htm");
	al_create_arc(content_types, "text/plain", ".txt");
	al_create_arc(content_types, "image/jpeg", ".jpeg");
	al_create_arc(content_types, "image/jpeg", ".jpg");
	al_create_arc(content_types, "image/gif", ".gif");
	al_create_arc(content_types, "application/zip", ".zip");
	al_create_arc(content_types, "x-gzip", ".gz");
	var string err;
	conn_mgr = new HttpServerConnectionMgr;
	conn_mgr.create(this);
	if (err = conn_mgr.start()) {
		return err;
	} else {
	}
}
end_body
member
public: void stop();
body
{
	if (conn_mgr) {
		conn_mgr.close();
		conn_mgr = null;
	} else {
	}
	ap_server = null;
}
end_body
member
public: HttpServerConnectionMgr conn_mgr;
member
public: integer connectionTimeout;
member
public: string GetAbsPath(string path);
body
{
	var integer idx;
	idx = al_search_str(path, 0, "..");
	if (idx >= 0) {
		return null;
	} else {
	}
	var string abs_path;
	abs_path = documentRoot + path;
	if (al_file_manip("does_exist", abs_path, null)) {
		if (al_file_manip("is_dir", abs_path, null)) {
			abs_path = abs_path + "/index.html";
			if (al_file_manip("does_exist", abs_path, null)) {
				return abs_path;
			} else {
			}
		} else {
			return abs_path;
		}
	} else {
		return null;
	}
}
end_body
member
public: list sessions;
member
public: integer sessionTimeout;
member
public: integer maxMsgSize;
member
public: void access_log(string fromIP, string path, string code, string size);
body
{
	if (ap_server) {
		if (access_log_filepath) {
			var string s;
			s = fromIP + " \"" + path + "\" " + code + " " + size;
			ap_server.log(access_log_filepath, s);
		} else {
		}
		if (al_search_str(path, 0, "cmd.exe") >= 0 || al_search_str(path, 0, "root.exe") >= 0 || al_search_str(path, 0, "default.ida") >= 0) {
			// not write access log of IIS virus
			// skip if path includes 'cmd.exe', 'root.exe' or 'default.ida'
			return;
		} else {
		}
		if (null && al_search_str(path, 0, "/admin/ebiz?") >= 0 && al_search_str(path, 0, "/admin/ebiz?action=Login") < 0) {
			// not write access log of admin ui operation
			// skip if URI includes '/admin/ebiz?' and is not '/admin/ebiz?action=Login'
			return;
		} else {
		}
		if (access_log_db) {
			var DbConnection conn;
			var string db_type;
			try {
				conn = DbManager::getConnection(WebUIServlet::pool_name);
				db_type = DbManager::getDbType(WebUIServlet::pool_name);
				var string sql, time;
				time = al_misc("get_time", null, null);
				time = al_misc("get_localtime", time, null);
				time = al_misc("format_time", time, "yyyy'/'MM'/'dd'-'HH':'mm':'ss");
				sql = al_copy("insert into AccessLog (AccessLogId, Time, FromIP, Path, ResponseCode, ResponseSize) values ('");
				al_append_str(sql, conn.getNextSeq("AccessLogId_seq"));
				al_append_str(sql, "','");
				al_append_str(sql, time);
				al_append_str(sql, "','");
				al_append_str(sql, (string)fromIP);
				al_append_str(sql, "','");
				al_append_str(sql, DbUtility::convChar((string)path));
				al_append_str(sql, "','");
				al_append_str(sql, (string)code);
				al_append_str(sql, "','");
				al_append_str(sql, (string)size);
				al_append_str(sql, "')");
				conn.executeUpdate(sql);
				conn.commit();
				conn.close();
			} catch (AlException e) {
				if (conn) {
					try {
						conn.rollback();
					} catch (AlException e) {
					}
					try {
						conn.close();
					} catch (AlException e) {
					}
				} else {
				}
			}
		} else {
		}
	} else {
	}
}
end_body
member
public: string access_log_filepath;
member
public: string access_log_db;
member
public: void error_log(string str);
body
{
	ap_server.system_log("error", "WebServer: " + str);
}
end_body
member
public: void timeoutCheck();
body
{
	var list itr;
	if (sessions) {
		var HttpSession session;
		itr = al_dst_itr(sessions);
		loop {
			if (session = al_next(itr)) {
			} else {
				break;
			}
			session._time = session._time + 1;
			if (session._time >= sessionTimeout) {
				al_remove(itr);
			} else {
			}
		}
	} else {
	}
	if (conn_mgr && conn_mgr.connections) {
		var HttpServerConnection conn;
		itr = al_dst_itr(conn_mgr.connections);
		loop {
			if (conn = al_next(itr)) {
			} else {
				break;
			}
			conn._time = conn._time + 1;
			if (conn._time >= connectionTimeout) {
				al_prev(itr);
				conn.close();
			} else {
			}
		}
	} else {
	}
}
end_body
member
public: list ssl;
member
public: string ca_cert;
member
public: string cert;
member
public: string key;
member
public: integer clientAuth;
member
public: string dhparam;
member
public: string cipher;
class HttpServerConnectionMgr
member
public: void create(WebServer server);
body
{
	this.server = server;
	connections = al_cons(null, null);
}
end_body
member
public: void close();
body
{
	if (server_socket_id) {
		al_socket("close", server_socket_id, null, null);
		server_socket_id = null;
	} else {
	}
	if (hwnd && msg) {
		al_wnd_message(null, "msg_callback", msg, null);
		al_wnd_message(null, "unregister_msg", msg, null);
		hwnd = msg = null;
	} else {
	}
	var list itr;
	var HttpServerConnection conn;
	loop {
		itr = al_dst_itr(connections);
		if (conn = al_next(itr)) {
		} else {
			break;
		}
		conn.close();
	}
	server = null;
}
end_body
member
public: WebServer server;
member
public: list connections;
member
public: list start();
body
{
	var string err;
	if (server.ssl == null) {
		if (server_socket_id = al_socket("socket", null, null, null)) {
		} else {
			return "fail to create server socket.";
		}
	} else {
		var list files;
		files = al_list5(server.cert, server.key, server.ca_cert, server.clientAuth, server.dhparam);
		if (server_socket_id = al_socket("socket", "SSL", files, server.cipher)) {
		} else {
			return "fail to create SSL server socket.";
		}
	}
	if (al_socket("bind", server_socket_id, al_list2(0, server.port), null)) {
		err = (string)al_socket("get_last_error", server_socket_id, null, null);
		err = "fail to bind socket with port = " + (string)server.port + ". (" + err + ")";
		close();
		return err;
	} else {
	}
	if (al_socket("listen", server_socket_id, null, null)) {
		err = (string)al_socket("get_last_error", server_socket_id, null, null);
		close();
		return "fail to listen socket. (" + err + ")";
	} else {
	}
	var list cb;
	hwnd = al_wnd_message(null, "hwnd", null, null);
	msg = al_wnd_message(null, "register_msg", "ACCEPT" + (string)server_socket_id, null);
	cb = al_list3(al_root_class(), this, HttpServerConnectionMgr::accepted);
	al_wnd_message(null, "msg_callback", msg, cb);
	if (al_socket("accept_que", server_socket_id, al_list2(hwnd, msg), null)) {
		err = (string)al_socket("get_last_error", server_socket_id, null, null);
		close();
		return "fail to start accept_queue. (" + err + ")";
	} else {
	}
	return null;
}
end_body
member
public: integer server_socket_id;
member
public: integer hwnd;
member
public: integer msg;
member
public: void accepted();
body
{
	var integer socket_id;
	server_socket_id = al_wnd_message(null, "wParam", null, null);
	if (socket_id = al_socket("get_socket", server_socket_id, null, null)) {
	} else {
		server.error_log("fail to get_socket: port = " + (string)server.port);
		return;
	}
	if (socket_id < 0) {
		server.error_log("fail to accept socket: port = " + (string)server.port);
		return;
	} else {
	}
	var HttpServerConnection conn;
	conn = new HttpServerConnection;
	conn.create(server, socket_id);
	conn._time = 0;
	var list ip_addr;
	ip_addr = al_socket("getpeername", socket_id, null, null);
	if (ip_addr) {
		ip_addr = ip_addr.head;
		conn.fromIP = al_socket("address_string", ip_addr, null, null);
	} else {
		conn.fromIP = "";
	}
	conn.cert_info = al_socket("cert_info", socket_id, null, null);
	al_create_arc(connections, conn, socket_id);
	conn.startReceiveCommand();
}
end_body
end_class
class HttpServerConnection
member
public: void create(WebServer server, integer socket_id);
body
{
	connection_debug();
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpServerConnection::create: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! HttpServerConnection::create: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	this.server = server;
	this.socket_id = socket_id;
	hwnd = al_wnd_message(null, "hwnd", null, null);
	msg = al_wnd_message(null, "register_msg", "HttpSvrConn-" + (string)socket_id, null);
	buffer_size = 4096;
}
end_body
member
public: void close();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpServerConnection::close: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! HttpServerConnection::close: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	if (hwnd && msg) {
		al_wnd_message(null, "msg_callback", msg, null);
		al_wnd_message(null, "unregister_msg", msg, null);
		hwnd = msg = null;
	} else {
	}
	var integer id;
	id = socket_id;
	if (socket_id) {
		al_socket("close", socket_id, null, null);
		socket_id = null;
	} else {
	}
	var list connections;
	if (connections = al_src_node(this, id)) {
		al_set_dst_node(connections, id, null);
	} else {
	}
	if (upload_filename) {
		upload = null;
		if (al_file_manip("does_exist", upload_filename, null)) {
			al_file_manip("remove", upload_filename, null);
		} else {
		}
	} else {
	}
	if (res.system_command == "restart") {
		para remote_restart();
	} else {
	}
	if (res.system_command == "shutdown") {
		para remote_shutdown();
	} else {
	}
}
end_body
member
public: WebServer server;
member
public: integer socket_id;
member
public: integer hwnd;
member
public: integer msg;
member
public: integer _time;
member
public: void startReceiveCommand();
body
{
	if (msg) {
	} else {
		return;
	}
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpServerConnection::startReceiveCommand: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! HttpServerConnection::startReceiveCommand: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	var list cb, buf, err;
	cb = al_list3(al_root_class(), this, HttpServerConnection::commandReceived);
	al_wnd_message(null, "msg_callback", msg, cb);
	buffer = al_misc("binary", buffer_size, null);
	buf = al_list3(buffer, 0, buffer_size);
	if (al_socket("recv", socket_id, buf, al_list3(hwnd, msg, 1))) {
		err = (string)al_socket("get_last_error", socket_id, null, null);
		// *** server.error_log("recv error.(" + err + ")");
		close();
		return;
	} else {
	}
}
end_body
member
public: void startReceiveHeaders();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpServerConnection::startReceiveHeaders: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! HttpServerConnection::startReceiveHeaders: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	var list cb, buf, err;
	cb = al_list3(al_root_class(), this, HttpServerConnection::headersReceived);
	al_wnd_message(null, "msg_callback", msg, cb);
	buf = al_list3(buffer, 0, buffer_size);
	if (al_socket("recv", socket_id, buf, al_list3(hwnd, msg, 2))) {
		err = (string)al_socket("get_last_error", socket_id, null, null);
		// *** server.error_log("recv error.(" + err + ")");
		close();
		return;
	} else {
	}
}
end_body
member
public: void startReceiveBlockSize();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpServerConnection::startReceiveBlockSize: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! HttpServerConnection::startReceiveBlockSize: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	var list cb, buf, err;
	cb = al_list3(al_root_class(), this, HttpServerConnection::blockSizeReceived);
	al_wnd_message(null, "msg_callback", msg, cb);
	buf = al_list3(buffer, 0, buffer_size);
	if (al_socket("recv", socket_id, buf, al_list3(hwnd, msg, 1))) {
		err = (string)al_socket("get_last_error", socket_id, null, null);
		// *** server.error_log("recv error.(" + err + ")");
		close();
		return;
	} else {
	}
}
end_body
member
public: void startReceiveContents();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpServerConnection::startReceiveContents: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! HttpServerConnection::startReceiveContents: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	var list cb, buf, err;
	cb = al_list3(al_root_class(), this, HttpServerConnection::contentsReceived);
	al_wnd_message(null, "msg_callback", msg, cb);
	buf = al_list3(buffer, 0, buffer_size);
	if (content_length) {
		if (al_socket("recv", socket_id, buf, al_list4(hwnd, msg, 3, content_length))) {
			err = (string)al_socket("get_last_error", socket_id, null, null);
			// *** server.error_log("recv error.(" + err + ")");
			return;
		} else {
		}
	} else {
		if (content_block_size) {
			if (al_socket("recv", socket_id, buf, al_list4(hwnd, msg, 3, content_block_size))) {
				err = (string)al_socket("get_last_error", socket_id, null, null);
				// *** server.error_log("recv error.(" + err + ")");
				return;
			} else {
			}
		} else {
			if (al_socket("recv", socket_id, buf, al_list2(hwnd, msg))) {
				err = (string)al_socket("get_last_error", socket_id, null, null);
				// *** server.error_log("recv error.(" + err + ")");
				return;
			} else {
			}
		}
	}
}
end_body
member
public: void startReceiveContents2();
body
{
	var list cb, buf, err;
	cb = al_list3(al_root_class(), this, HttpServerConnection::contentsReceived2);
	al_wnd_message(null, "msg_callback", msg, cb);
	buf = al_list3(buffer, 0, buffer_size);
	if (al_socket("recv", socket_id, buf, al_list2(hwnd, msg))) {
		err = (string)al_socket("get_last_error", socket_id, null, null);
		// *** server.error_log("recv error.(" + err + ")");
		return;
	} else {
	}
}
end_body
member
public: void startReceiveCRLF();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpServerConnection::startReceiveCRLF: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! HttpServerConnection::startReceiveCRLF: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	var list cb, buf, err;
	cb = al_list3(al_root_class(), this, HttpServerConnection::CRLFReceived);
	al_wnd_message(null, "msg_callback", msg, cb);
	buf = al_list3(buffer, 0, buffer_size);
	if (al_socket("recv", socket_id, buf, al_list3(hwnd, msg, 1))) {
		err = (string)al_socket("get_last_error", socket_id, null, null);
		// *** server.error_log("recv error.(" + err + ")");
		close();
		return;
	} else {
	}
}
end_body
member
public: void commandReceived();
body
{
	var list err;
	var integer read_bytes;
	read_bytes = al_wnd_message(null, "lParam", null, null);
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpServerConnection::commandReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes);
		} else {
			al_print("!!! HttpServerConnection::commandReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes + "\n");
		}
	} else {
	}
	if (read_bytes < 0) {
		err = (string)al_socket("get_last_error", socket_id, null, null);
		// *** server.error_log("recv error. (" + err + ")");
		close();
		return;
	} else {
	}
	command_line = al_misc("binary_to_string", al_list3(buffer, 0, read_bytes - 1), null);
	var string cmd;
	in = al_file_open(command_line, "sr");
	if (cmd = al_file_read(in, "string")) {
	} else {
		// *** server.error_log("request Method not found.");
		close();
		return;
	}
	cmd = al_str_misc("to_upper", cmd, null);
	if (path = al_file_read(in, "string")) {
	} else {
		// *** server.error_log("request URI not found.");
		close();
		return;
	}
	path = al_str_misc("param_to_string", path, null);
	if (http_ver = al_file_read(in, "string")) {
	} else {
		// *** server.error_log("HTTP version not found.");
		close();
		return;
	}
	command = cmd;
	var integer idx;
	idx = al_search_str(path, 0, "?");
	if (idx > 0) {
		params = al_substr(path, idx + 1, al_strlen(path));
		path = al_substr(path, 0, idx);
	} else {
		params = "";
	}
	var integer len;
	len = al_strlen(path);
	if (al_get_char(path, len - 1) == '/') {
		path = al_substr(path, 0, len - 1);
	} else {
	}
	_time = 0;
	startReceiveHeaders();
}
end_body
member
public: void headersReceived();
body
{
	var string err;
	var integer read_bytes;
	read_bytes = al_wnd_message(null, "lParam", null, null);
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpServerConnection::headersReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes);
		} else {
			al_print("!!! HttpServerConnection::headersReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes + "\n");
		}
	} else {
	}
	if (read_bytes < 0) {
		err = (string)al_socket("get_last_error", socket_id, null, null);
		// *** server.error_log("recv error. (" + err + ")");
		close();
		return;
	} else {
	}
	bin_raw_http_header = al_misc("binary", read_bytes, null);
	al_misc("binary_copy", al_list2(bin_raw_http_header, 0), al_list3(buffer, 0, read_bytes));
	if (debug3) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "---- received Http Request Header\n" + (string)al_misc("binary_to_string", al_list3(buffer, 0, read_bytes), null));
		} else {
			al_print("---- received Http Request Header\n" + (string)al_misc("binary_to_string", al_list3(buffer, 0, read_bytes), null));
		}
	} else {
	}
	if (headers = al_crypt("mime_headers_read", al_list3(buffer, 0, read_bytes), null, null)) {
	} else {
		server.error_log("mime header parse error.");
		close();
		return;
	}
	headers = headers.head;
	refer = al_dst_node_i(headers, "Referer");
	if (content_length = al_dst_node_i(headers, "Content-Length")) {
		content_length = (integer)content_length;
		_time = 0;
		var string content_type, content_type_i;
		if (content_type = al_dst_node_i(headers, "Content-Type")) {
			content_type_i = al_str_misc("to_lower", content_type, null);
			if (content_type_i == "multipart/form-data") {
				boundary = al_dst_node_i(content_type, "boundary");
			} else {
			}
		} else {
		}
		if (boundary && al_dst_node(server.upload_servlet_list, path)) {
			startReceiveContents2();
		} else {
			if (content_length > server.maxMsgSize * 1000) {
				server.error_log("request message too large: Content-Length = " + (string)content_length + ", fromIP = " + (string)fromIP + ", Request = " + (string)command_line);
				send_status = "413_request_entity_too_large";
				if (err = send(http_ver + " 413\n")) {
					// *** server.error_log(err);
					close();
					return;
				} else {
				}
				return;
			} else {
			}
			startReceiveContents();
		}
	} else {
		if (command == "GET") {
			_time = 0;
			para this.process();
		} else {
			_time = 0;
			var string encoding;
			encoding = al_dst_node_i(headers, "Transfer-Encoding");
			if (encoding && al_misc("strcmpi", encoding, "chunked") == 0) {
				chunked = 1;
				startReceiveBlockSize();
			} else {
				startReceiveContents();
			}
		}
	}
}
end_body
member
public: void blockSizeReceived();
body
{
	var list err;
	var integer read_bytes;
	read_bytes = al_wnd_message(null, "lParam", null, null);
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpServerConnection::blockSizeReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes);
		} else {
			al_print("!!! HttpServerConnection::blockSizeReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes + "\n");
		}
	} else {
	}
	if (read_bytes < 0) {
		err = (string)al_socket("get_last_error", socket_id, null, null);
		// *** server.error_log("recv error. (" + err + ")");
		close();
		return;
	} else {
	}
	var string hex_str;
	var file f;
	var integer size;
	hex_str = al_misc("binary_to_string", al_list3(buffer, 0, read_bytes), null);
	f = al_file_open(hex_str, "sr");
	content_block_size = al_file_read(f, "hex");
	if (content_block_size > 0) {
		if (contents) {
			size = al_misc("binary_size", contents, null) + content_block_size;
		} else {
			size = content_block_size;
		}
		if (size > server.maxMsgSize * 1000) {
			server.error_log("request message too large: size >= " + (string)size + ", fromIP = " + (string)fromIP + ", Request = " + (string)command_line);
			send_status = "413_request_entity_too_large";
			if (err = send(http_ver + " 413\n")) {
				// *** server.error_log(err);
				close();
				return;
			} else {
			}
			return;
		} else {
		}
		_time = 0;
		startReceiveContents();
		return;
	} else {
		_time = 0;
		para this.process();
		return;
	}
}
end_body
member
public: void contentsReceived();
body
{
	var list err;
	var integer read_bytes;
	read_bytes = al_wnd_message(null, "lParam", null, null);
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpServerConnection::contentsReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes);
		} else {
			al_print("!!! HttpServerConnection::contentsReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes + "\n");
		}
	} else {
	}
	if (read_bytes < 0) {
		if (content_length) {
			err = (string)al_socket("get_last_error", socket_id, null, null);
			// *** server.error_log("recv error. (" + err + ")");
			close();
			return;
		} else {
			close();
			return;
		}
	} else {
	}
	if (content_length) {
		contents = al_misc("binary", read_bytes, null);
		al_misc("binary_copy", al_list2(contents, 0), al_list3(buffer, 0, read_bytes));
		_time = 0;
		para this.process();
		return;
	} else {
	}
	if (contents) {
		var integer idx;
		idx = al_misc("binary_size", contents, null);
		al_misc("extend_binary", contents, read_bytes);
		al_misc("binary_copy", al_list2(contents, idx), al_list3(buffer, 0, read_bytes));
	} else {
		contents = al_misc("binary", read_bytes, null);
		al_misc("binary_copy", al_list2(contents, 0), al_list3(buffer, 0, read_bytes));
	}
	var integer size;
	size = al_misc("binary_size", contents, null);
	if (size > server.maxMsgSize * 1000) {
		server.error_log("request message too large: size >= " + (string)size + ", fromIP = " + (string)fromIP + ", Request = " + (string)command_line);
		send_status = "413_request_entity_too_large";
		if (err = send(http_ver + " 413\n")) {
			// *** server.error_log(err);
			close();
			return;
		} else {
		}
		return;
	} else {
	}
	_time = 0;
	if (chunked) {
		startReceiveCRLF();
	} else {
		startReceiveContents();
	}
}
end_body
member
public: void contentsReceived2();
body
{
	var list err;
	var integer read_bytes;
	read_bytes = al_wnd_message(null, "lParam", null, null);
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpServerConnection::contentsReceived2: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes);
		} else {
			al_print("!!! HttpServerConnection::contentsReceived2: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes + "\n");
		}
	} else {
	}
	if (read_bytes < 0) {
		err = (string)al_socket("get_last_error", socket_id, null, null);
		// *** server.error_log("recv error. (" + err + ")");
		close();
		return;
	} else {
	}
	_time = 0;
	var list block;
	block = al_list3(buffer, 0, read_bytes);
	if (upload == null) {
		if (upload_filename = FileUtility::tempFile()) {
		} else {
			// *** server.error_log("can't get upload temp file name");
			close();
			return;
		}
		if (upload = al_file_open(upload_filename, "wb")) {
		} else {
			// *** server.error_log("can't open upload temp file");
			close();
			return;
		}
		if (al_file_write(upload, al_list3(bin_raw_http_header, 0, al_misc("binary_size", bin_raw_http_header, null)), null)) {
			upload = null;
			al_file_manip("remove", upload_filename, null);
			// *** server.error_log("write error to upload temp file");
			close();
			return;
		} else {
		}
		total_read_bytes = 0;
	} else {
	}
	if (al_file_write(upload, block, null)) {
		upload = null;
		al_file_manip("remove", upload_filename, null);
		// *** server.error_log("write error to upload temp file");
		close();
		return;
	} else {
	}
	total_read_bytes = total_read_bytes + read_bytes;
	if (total_read_bytes >= content_length) {
		upload = null;
		para this.process();
	} else {
		startReceiveContents2();
	}
}
end_body
member
public: void CRLFReceived();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpServerConnection::CRLFReceived: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! HttpServerConnection::CRLFReceived: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	_time = 0;
	startReceiveBlockSize();
}
end_body
member
public: list chunked;
member
public: integer buffer_size;
member
public: list buffer;
member
public: string command_line;
member
public: string command;
member
public: string http_ver;
member
public: integer content_block_size;
member
public: list bin_raw_http_header;
member
public: list headers;
member
public: integer content_length;
member
public: string refer;
member
public: list contents;
member
public: void process();
body
{
	var string err, class_name;
	var list upload;
	var string class_name;
	var string abs_path;
	var string content_disposition;
	if (class_name = al_dst_node(server.servlet_list, path)) {
	} else {
		if (class_name = al_dst_node(server.upload_servlet_list, path)) {
			upload = 1;
		} else {
		}
	}
	if (class_name) {
		if (servlet = al_gp("new", class_name, null, null, null)) {
		} else {
			server.access_log(fromIP, command_line, "404", "0");
			send_status = "404_not_found";
			if (err = send(http_ver + " 404\n")) {
				// *** server.error_log(err);
				close();
				return;
			} else {
			}
			return;
		}
		req = new HttpRequest;
		req._command = command;
		req._path = path;
		req._server = server;
		req.bin_raw_http_header = bin_raw_http_header;
		req.fromIP = fromIP;
		req.cert_info = cert_info;
		res = new HttpResponse;
		res._create();
		req._response = res;
		res._request = req;
		res._server = server;
		res.http_ver = http_ver;
		try {
			if (command == "GET") {
				req.headers = headers;
				req._params = params;
				servlet.doGet(req, res);
			} else {
			}
			if (command == "POST") {
				req.headers = headers;
				req._params = params;
				if (upload) {
					req.input_file = upload_filename;
					upload_filename = null;
				} else {
					req.input = contents;
				}
				servlet.doPost(req, res);
			} else {
			}
		} catch (AlException e) {
			var WebUIServlet svlt;
			svlt = new WebUIServlet;
			svlt.res = res;
			svlt.error("Internal Error", e);
		}
		req._response = null;
		req._server = null;
		res._request = null;
		res._server = null;
		server.access_log(fromIP, command_line, (string)res.response_code, (string)res.content_length);
		if (abs_path = res.response_filepath) {
			content_disposition = res.response_content_disposition;
		} else {
			send_status = "servlet_response_code";
			if (err = send(http_ver + " " + (string)res.response_code + "\n")) {
				// *** server.error_log(err);
				close();
				return;
			} else {
			}
			return;
		}
	} else {
	}
	if ((abs_path || abs_path = server.GetAbsPath(path)) && in = al_file_open(abs_path, "rb")) {
	} else {
		server.access_log(fromIP, command_line, "404", "0");
		send_status = "404_not_found";
		if (err = send(http_ver + " 404\n")) {
			// *** server.error_log(err);
			close();
			return;
		} else {
		}
		return;
	}
	content_length = al_file_manip("get_size", abs_path, null);
	headers = al_cons(null, null);
	var string file_ext, content_type;
	file_ext = al_str_misc("file_ext", abs_path, null);
	if (content_type = al_dst_node(server.content_types, file_ext)) {
	} else {
		content_type = "text/plain";
	}
	al_set_dst_node(headers, "Content-Type", content_type);
	al_set_dst_node(headers, "Content-Length", (string)content_length);
	if (content_disposition) {
		al_set_dst_node(headers, "Content-Disposition", content_disposition);
	} else {
	}
	al_set_dst_node(headers, "Server", "AltairServer" + al_misc("version", null, null));
	if (http_ver == "HTTP/1.1") {
		al_set_dst_node(headers, "Connection", "Close");
	} else {
	}
	buffer = al_crypt("mime_headers_write", headers, null, null);
	server.access_log(fromIP, command_line, "200", (string)content_length);
	send_status = "200_ok";
	if (err = send(http_ver + " 200\n")) {
		// *** server.error_log(err);
		close();
		return;
	} else {
	}
	return;
}
end_body
member
public: string order;
member
public: string path;
member
public: string path2;
member
public: list params;
member
public: list send(string str);
body
{
	var integer size;
	var list binary;
	size = al_strlen(str);
	binary = al_misc("binary", size, null);
	al_misc("binary_copy", al_list2(binary, 0), str);
	return send(binary, 0, size);
}
end_body
member
public: list send(list binary);
body
{
	var integer size;
	size = al_misc("binary_size", binary, null);
	return send(binary, 0, size);
}
end_body
member
public: list send(list binary, integer index, integer size);
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpServerConnection::send: socket_id = " + (string)socket_id + ", size = " + (string)size);
		} else {
			al_print("!!! HttpServerConnection::send: socket_id = " + (string)socket_id + ", size = " + (string)size + "\n");
		}
	} else {
	}
	if (msg) {
		var list cb, block;
		cb = al_list3(al_root_class(), this, HttpServerConnection::sendCompleted);
		al_wnd_message(null, "msg_callback", msg, cb);
		block = al_list3(binary, index, size);
		if (al_socket("send", socket_id, block, al_list2(hwnd, msg))) {
			return "send error. (" + (string)al_socket("get_last_error", socket_id, null, null) + ")";
		} else {
		}
	} else {
	}
	return null;
}
end_body
member
public: void sendCompleted();
body
{
	var string err;
	var integer send_bytes;
	send_bytes = al_wnd_message(null, "lParam", null, null);
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpServerConnection::sendCompleted: socket_id = " + (string)socket_id + ", send_bytes = " + (string)send_bytes);
		} else {
			al_print("!!! HttpServerConnection::sendCompleted: socket_id = " + (string)socket_id + ", send_bytes = " + (string)send_bytes + "\n");
		}
	} else {
	}
	if (send_bytes < 0) {
		err = (string)al_socket("get_last_error", socket_id, null, null);
		// *** server.error_log("send error. (" + err + ")");
		close();
		return;
	} else {
	}
	if (send_status == "servlet_response_code") {
		if (al_dst_node_i(res.headers, "Content-Type")) {
		} else {
			al_set_dst_node(res.headers, "Content-Type", "text/html");
		}
		al_set_dst_node(res.headers, "Content-Length", (string)res.content_length);
		al_set_dst_node(res.headers, "Server", "AltairServer" + al_misc("version", null, null));
		if (http_ver == "HTTP/1.1") {
			al_set_dst_node(headers, "Connection", "Close");
		} else {
		}
		var list buffer;
		buffer = al_crypt("mime_headers_write", res.headers, null, null);
		send_status = "servlet_response_headers";
		if (err = send(buffer)) {
			// *** server.error_log(err);
			close();
			return;
		} else {
		}
		_time = 0;
		return;
	} else {
	}
	if (send_status == "servlet_response_headers") {
		send_status = "servlet_response_contents";
		if (err = send(res.output, 0, res.content_length)) {
			// *** server.error_log(err);
			close();
			return;
		} else {
		}
		_time = 0;
		return;
	} else {
	}
	if (send_status == "servlet_response_contents") {
		close();
		return;
	} else {
	}
	if (send_status == "404_not_found") {
		close();
		return;
	} else {
	}
	if (send_status == "413_request_entity_too_large") {
		close();
		return;
	} else {
	}
	if (send_status == "200_ok") {
		send_status = "headers";
		if (err = send(buffer)) {
			// *** server.error_log(err);
			close();
			return;
		} else {
		}
		_time = 0;
		return;
	} else {
	}
	if (send_status == "headers") {
		buffer = al_misc("binary", buffer_size, null);
		var integer read_bytes;
		var list block;
		total_read_bytes = 0;
		block = al_list3(buffer, 0, buffer_size);
		if (read_bytes = al_file_read(in, block)) {
			if (read_bytes < 0) {
				// cannot read page
				close();
				return;
			} else {
			}
		} else {
			read_bytes = buffer_size;
		}
		send_status = "contents_block";
		total_read_bytes = total_read_bytes + read_bytes;
		if (err = send(buffer, 0, read_bytes)) {
			// *** server.error_log(err);
			close();
			return;
		} else {
		}
		_time = 0;
		return;
	} else {
	}
	if (send_status == "contents_block") {
		if (total_read_bytes >= content_length) {
			close();
			return;
		} else {
		}
		var integer read_bytes;
		var list block;
		block = al_list3(buffer, 0, buffer_size);
		if (read_bytes = al_file_read(in, block)) {
			if (read_bytes < 0) {
				// cannot read page
				close();
				return;
			} else {
			}
		} else {
			read_bytes = buffer_size;
		}
		send_status = "contents_block";
		total_read_bytes = total_read_bytes + read_bytes;
		if (err = send(buffer, 0, read_bytes)) {
			// *** server.error_log(err);
			close();
			return;
		} else {
		}
		_time = 0;
		return;
	} else {
	}
	close();
	return;
}
end_body
member
public: string send_status;
member
public: file in;
member
public: integer total_read_bytes;
member
public: string fromIP;
member
public: list cert_info;
member
public: HttpServlet servlet;
member
public: HttpRequest req;
member
public: HttpResponse res;
member
public: list binary;
member
public: string boundary;
member
public: string upload_filename;
member
public: file upload;
end_class
class HttpClientConnection
member
public: list create(string url);
body
{
	connection_debug();
	if (url == null) {
		return "url is null.";
	} else {
	}
	this.url = url;
	var integer i;
	var string head, tail;
	i = al_search_str(url, 0, "//");
	if (i < 0) {
		return "http:// or https:// required: url = " + (string)url;
	} else {
	}
	head = al_substr(url, 0, i);
	if (head == "http:") {
		ssl = null;
	} else {
		if (head == "https:") {
			ssl = 1;
		} else {
			return "http:// or https:// required: url = " + (string)url;
		}
	}
	tail = al_tail_str(url, i + 2);
	i = al_search_str(tail, 0, "/");
	if (i > 0) {
		path = al_tail_str(tail, i);
		tail = al_substr(tail, 0, i);
	} else {
		path = "/";
	}
	i = al_search_str(tail, 0, ":");
	if (i >= 0) {
		host = al_substr(tail, 0, i);
		port = (integer)al_tail_str(tail, i + 1);
	} else {
		host = tail;
		if (ssl) {
			port = 443;
		} else {
			port = 80;
		}
	}
	headers = al_cons(null, null);
	max_size = 4096;
	output = al_misc("binary", max_size, null);
	content_length = 0;
	buffer_size = 4096;
	buffer = al_misc("binary", buffer_size, null);
	contents = null;
	send_block_size = 4096;
	// default timeout is 60 sec (1 minutes)
	_time = 0;
	timeout = 60;
	wait_obj = new WaitObj;
	server_auth = 0;
	return null;
}
end_body
member
public: list doGet();
body
{
	if (doGet_noWait()) {
		return error;
	} else {
	}
	wait_obj.wait();
	close();
	return error;
}
end_body
member
public: list doPost();
body
{
	if (doPost_noWait()) {
		return error;
	} else {
	}
	wait_obj.wait();
	close();
	return error;
}
end_body
member
public: list doGet_noWait();
body
{
	request_method = "GET";
	if (proxy_server && proxy_server != "" && al_is_type(proxy_port, "integer")) {
		al_set_dst_node(headers, "User-Agent", "Altair" + al_misc("version", null, null));
		al_set_dst_node(headers, "Host", proxy_server + ":" + (string)proxy_port);
		al_set_dst_node(headers, "Accept", "*/*");
		if (error = connect()) {
			close();
			return error;
		} else {
		}
		if (ssl) {
			if (error = send("CONNECT " + host + ":" + (string)port + " HTTP/1.0\r\n")) {
				close();
				return error;
			} else {
			}
			var list buf;
			buf = al_crypt("mime_headers_write", headers, null, null);
			if (error = send(buf)) {
				close();
				return error;
			} else {
			}
			if (error = startReceiveProxyHeaders()) {
				close();
				return error;
			} else {
			}
			wait_obj.wait();
			close();
			return error;
		} else {
			if (error = send("GET " + url + " HTTP/1.0\r\n")) {
				close();
				return error;
			} else {
			}
		}
	} else {
		al_set_dst_node(headers, "User-Agent", "Altair" + al_misc("version", null, null));
		al_set_dst_node(headers, "Host", host + ":" + (string)port);
		al_set_dst_node(headers, "Accept", "*/*");
		if (error = connect()) {
			close();
			return error;
		} else {
		}
		if (ssl && al_socket("SSL_connect", socket_id, null, null)) {
			error = "fail to SSL_connect.(" + (string)al_socket("get_last_error", socket_id, null, null) + ")";
			close();
			return error;
		} else {
		}
		if (ssl) {
			cert_info = al_socket("cert_info", socket_id, null, null);
		} else {
		}
		if (error = send("GET " + path + " HTTP/1.0\r\n")) {
			close();
			return error;
		} else {
		}
	}
	var list buf;
	buf = al_crypt("mime_headers_write", headers, null, null);
	if (error = send(buf)) {
		close();
		return error;
	} else {
	}
	if (error = startReceiveCommand()) {
		close();
		return error;
	} else {
	}
	return null;
}
end_body
member
public: list doPost_noWait();
body
{
	request_method = "POST";
	if (proxy_server && proxy_server != "" && al_is_type(proxy_port, "integer")) {
		if (al_dst_node_i(headers, "Content-Type")) {
		} else {
			al_set_dst_node(headers, "Content-Type", "application/x-www-form-urlencoded");
		}
		al_set_dst_node(headers, "User-Agent", "Altair" + al_misc("version", null, null));
		al_set_dst_node(headers, "Host", proxy_server + ":" + (string)proxy_port);
		al_set_dst_node(headers, "Accept", "*/*");
		al_set_dst_node(headers, "Content-Length", (string)content_length);
		if (error = connect()) {
			close();
			return error;
		} else {
		}
		if (ssl) {
			if (error = send("CONNECT " + host + ":" + (string)port + " HTTP/1.0\r\n")) {
				close();
				return error;
			} else {
			}
			var list buf;
			buf = al_crypt("mime_headers_write", headers, null, null);
			if (error = send(buf)) {
				close();
				return error;
			} else {
			}
			if (error = startReceiveProxyHeaders()) {
				close();
				return error;
			} else {
			}
			wait_obj.wait();
			close();
			return error;
		} else {
			if (error = send("POST " + url + " HTTP/1.0\r\n")) {
				close();
				return error;
			} else {
			}
		}
	} else {
		if (al_dst_node_i(headers, "Content-Type")) {
		} else {
			al_set_dst_node(headers, "Content-Type", "application/x-www-form-urlencoded");
		}
		al_set_dst_node(headers, "User-Agent", "Altair" + al_misc("version", null, null));
		al_set_dst_node(headers, "Host", host + ":" + (string)port);
		al_set_dst_node(headers, "Accept", "*/*");
		al_set_dst_node(headers, "Content-Length", (string)content_length);
		if (error = connect()) {
			close();
			return error;
		} else {
		}
		if (ssl && al_socket("SSL_connect", socket_id, null, null)) {
			error = "fail to SSL_connect.(" + (string)al_socket("get_last_error", socket_id, null, null) + ")";
			close();
			return error;
		} else {
		}
		if (ssl) {
			cert_info = al_socket("cert_info", socket_id, null, null);
		} else {
		}
		if (error = send("POST " + path + " HTTP/1.0\r\n")) {
			close();
			return error;
		} else {
		}
	}
	var list buf;
	buf = al_crypt("mime_headers_write", headers, null, null);
	if (error = send(buf)) {
		close();
		return error;
	} else {
	}
	send_index = 0;
	send_total_size = content_length;
	if (send_block_size > send_total_size) {
		send_block_size = send_total_size;
	} else {
	}
	if (error = send2()) {
		close();
		return error;
	} else {
	}
	return null;
}
end_body
member
public: list isCompleted();
body
{
	return wait_obj && wait_obj.notified;
}
end_body
member
public: string request_method;
member
public: list connect();
body
{
	var integer hostaddr;
	if (ssl) {
		var list files;
		files = al_list4(cert, key, ca_cert, server_auth);
		if (socket_id = al_socket("socket", "SSL", files, "MEDIUM")) {
		} else {
			return "fail to create socket";
		}
	} else {
		if (socket_id = al_socket("socket", null, null, null)) {
		} else {
			return "fail to create socket";
		}
	}
	if (proxy_server && proxy_server != "" && al_is_type(proxy_port, "integer")) {
		if (hostaddr_cache) {
		} else {
			hostaddr_cache = al_cons(null, null);
		}
		if (hostaddr = al_dst_node(hostaddr_cache, host)) {
		} else {
			if (hostaddr = al_socket("gethostbyname", host, null, null)) {
			} else {
				return "fail to get hostaddr: host = " + (string)host;
			}
			al_create_arc(hostaddr_cache, hostaddr, host);
		}
		if (al_socket("connect", socket_id, al_list2(hostaddr, proxy_port), connect_timeout)) {
			return "fail to connect socket.(" + (string)al_socket("get_last_error", socket_id, null, null) + ")";
		} else {
		}
	} else {
		if (hostaddr_cache) {
		} else {
			hostaddr_cache = al_cons(null, null);
		}
		if (hostaddr = al_dst_node(hostaddr_cache, host)) {
		} else {
			if (hostaddr = al_socket("gethostbyname", host, null, null)) {
			} else {
				return "fail to get hostaddr: host = " + (string)host;
			}
			al_create_arc(hostaddr_cache, hostaddr, host);
		}
		if (al_socket("connect", socket_id, al_list2(hostaddr, port), connect_timeout)) {
			return "fail to connect socket.(" + (string)al_socket("get_last_error", socket_id, null, null) + ")";
		} else {
		}
	}
	hwnd = al_wnd_message(null, "hwnd", null, null);
	msg = al_wnd_message(null, "register_msg", "HttpClntConn-" + (string)socket_id, null);
	if (connections) {
	} else {
		connections = al_cons(null, null);
	}
	al_create_arc(connections, this, socket_id);
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpClientConnection::create: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! HttpClientConnection::create: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	return null;
}
end_body
member
public: list startReceiveProxyHeaders();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpClientConnection::startReceiveProxyResponse: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! HttpClientConnection::startReceiveProxyResponse: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	var list cb, buf;
	cb = al_list3(al_root_class(), this, HttpClientConnection::proxyHeadersReceived);
	al_wnd_message(null, "msg_callback", msg, cb);
	buf = al_list3(buffer, 0, buffer_size);
	if (al_socket("recv", socket_id, buf, al_list3(hwnd, msg, 2))) {
		return "proxy header recv error: " + (string)al_socket("get_last_error", socket_id, null, null);
	} else {
	}
	return null;
}
end_body
member
public: void proxyHeadersReceived();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpClientConnection::proxyHeadersReceived: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! HttpClientConnection::proxyHeadersReceived: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	if (request_method == "GET") {
		al_set_dst_node(headers, "User-Agent", "Altair" + al_misc("version", null, null));
		al_set_dst_node(headers, "Host", host + ":" + (string)port);
		al_set_dst_node(headers, "Accept", "*/*");
	} else {
		if (al_dst_node_i(headers, "Content-Type")) {
		} else {
			al_set_dst_node(headers, "Content-Type", "application/x-www-form-urlencoded");
		}
		al_set_dst_node(headers, "User-Agent", "Altair" + al_misc("version", null, null));
		al_set_dst_node(headers, "Host", host + ":" + (string)port);
		al_set_dst_node(headers, "Accept", "*/*");
		al_set_dst_node(headers, "Content-Length", (string)content_length);
	}
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpClientConnection::proxyHeadesReceived: ENTER SSL_connect: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! HttpClientConnection::proxyHeadesReceived: ENTER SSL_connect: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	if (al_socket("SSL_connect", socket_id, null, null)) {
		if (debug) {
			if (debug_log_file && appServer) {
				appServer.log(debug_log_file, "!!! HttpClientConnection::proxyHeadesReceived: LEAVE(error) SSL_connect: socket_id = " + (string)socket_id);
			} else {
				al_print("!!! HttpClientConnection::proxyHeadesReceived: LEAVE(error) SSL_connect: socket_id = " + (string)socket_id + "\n");
			}
		} else {
		}
		error = "fail to SSL_connect.(" + (string)al_socket("get_last_error", socket_id, null, null) + ")";
		wait_obj.notify();
		return;
	} else {
		if (debug) {
			if (debug_log_file && appServer) {
				appServer.log(debug_log_file, "!!! HttpClientConnection::proxyHeadesReceived: LEAVE SSL_connect: socket_id = " + (string)socket_id);
			} else {
				al_print("!!! HttpClientConnection::proxyHeadesReceived: LEAVE SSL_connect: socket_id = " + (string)socket_id + "\n");
			}
		} else {
		}
		cert_info = al_socket("cert_info", socket_id, null, null);
	}
	if (error = send(request_method + " " + path + " HTTP/1.0\r\n")) {
		wait_obj.notify();
		return;
	} else {
	}
	var list buf;
	buf = al_crypt("mime_headers_write", headers, null, null);
	if (error = send(buf)) {
		wait_obj.notify();
		return;
	} else {
	}
	if (ssl) {
		if (request_method == "GET") {
			if (error = startReceiveCommand()) {
				wait_obj.wait();
				return;
			} else {
			}
		} else {
			send_index = 0;
			send_total_size = content_length;
			if (send_block_size > send_total_size) {
				send_block_size = send_total_size;
			} else {
			}
			if (error = send2()) {
				wait_obj.wait();
				return;
			} else {
			}
		}
	} else {
		if (error = startReceiveHeaders()) {
			wait_obj.notify();
			return;
		} else {
		}
	}
}
end_body
member
public: void close();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpClientConnection::close: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! HttpClientConnection::close: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	var integer id;
	id = socket_id;
	if (socket_id) {
		al_socket("close", socket_id, null, null);
		socket_id = null;
	} else {
	}
	if (hwnd && msg) {
		al_wnd_message(null, "msg_callback", msg, null);
		al_wnd_message(null, "unregister_msg", msg, null);
		hwnd = msg = null;
	} else {
	}
	var list conns;
	if (conns = al_src_node(this, id)) {
		al_set_dst_node(conns, id, null);
	} else {
	}
}
end_body
member
public: string url;
member
public: list ssl;
member
public: string cert;
member
public: string key;
member
public: string ca_cert;
member
public: integer server_auth;
member
public: string host;
member
public: integer port;
member
public: string proxy_server;
member
public: integer proxy_port;
member
public: string path;
member
public: integer socket_id;
member
public: integer hwnd;
member
public: integer msg;
member
public: integer _time;
member
public: void setTimeout(integer sec);
body
{
	timeout = sec;
}
end_body
member
public: integer timeout;
member
public: list headers;
member
public: list out(string s);
body
{
	var integer len;
	len = al_strlen(s);
	if (content_length + len > max_size) {
		al_misc("extend_binary", output, len);
		max_size = max_size + len;
	} else {
	}
	al_misc("binary_copy", al_list2(output, content_length), s);
	content_length = content_length + len;
}
end_body
member
public: list out(list binary);
body
{
	var integer size;
	size = al_misc("binary_size", binary, null);
	out(binary, 0, size);
}
end_body
member
public: list out(list binary, integer index, integer size);
body
{
	if (content_length + size > max_size) {
		al_misc("extend_binary", output, size);
		max_size = max_size + size;
	} else {
	}
	al_misc("binary_copy", al_list2(output, content_length), al_list3(binary, index, size));
	content_length = content_length + size;
}
end_body
member
public: list output;
member
public: integer max_size;
member
public: integer content_length;
member
public: WaitObj wait_obj;
member
public: list send(string str);
body
{
	var integer size;
	var list binary;
	size = al_strlen(str);
	binary = al_misc("binary", size, null);
	al_misc("binary_copy", al_list2(binary, 0), str);
	return send(binary, 0, size);
}
end_body
member
public: list send(list binary);
body
{
	var integer size;
	size = al_misc("binary_size", binary, null);
	return send(binary, 0, size);
}
end_body
member
public: list send(list binary, integer index, integer size);
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpClientConnection::send: socket_id = " + (string)socket_id + ", size = " + (string)size);
		} else {
			al_print("!!! HttpClientConnection::send: socket_id = " + (string)socket_id + ", size = " + (string)size + "\n");
		}
	} else {
	}
	var list block;
	block = al_list3(binary, index, size);
	if (al_socket("send", socket_id, block, null)) {
		return "send error. (" + (string)al_socket("get_last_error", socket_id, null, null) + ")";
	} else {
	}
	return null;
}
end_body
member
public: list send2();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpClientConnection::send2: socket_id = " + (string)socket_id + ", send_index = " + (string)send_index + ", send_block_size =" + (string)send_block_size);
		} else {
			al_print("!!! HttpClientConnection::send2: socket_id = " + (string)socket_id + ", send_index = " + (string)send_index + ", send_block_size =" + (string)send_block_size + "\n");
		}
	} else {
	}
	var list cb, block;
	cb = al_list3(al_root_class(), this, HttpClientConnection::sendCompleted);
	al_wnd_message(null, "msg_callback", msg, cb);
	block = al_list3(output, send_index, send_block_size);
	if (al_socket("send", socket_id, block, al_list2(hwnd, msg))) {
		return "send error. (" + (string)al_socket("get_last_error", socket_id, null, null) + ")";
	} else {
	}
	return null;
}
end_body
member
public: void sendCompleted();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpClientConnection::sendCompleted: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! HttpClientConnection::sendCompleted: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	if (send_index >= send_total_size) {
		if (error = startReceiveCommand()) {
			wait_obj.notify();
			return;
		} else {
		}
		return;
	} else {
	}
	send_index = send_index + send_block_size;
	if (send_index + send_block_size > send_total_size) {
		send_block_size = send_total_size - send_index;
	} else {
	}
	if (error = send2()) {
		wait_obj.notify();
		return;
	} else {
	}
}
end_body
member
public: integer send_index;
member
public: integer send_block_size;
member
public: integer send_total_size;
member
public: list startReceiveCommand();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpClientConnection::startReceiveCommand: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! HttpClientConnection::startReceiveCommand: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	var list cb, buf;
	cb = al_list3(al_root_class(), this, HttpClientConnection::commandReceived);
	al_wnd_message(null, "msg_callback", msg, cb);
	buf = al_list3(buffer, 0, buffer_size);
	if (al_socket("recv", socket_id, buf, al_list3(hwnd, msg, 1))) {
		return "recv error: " + (string)al_socket("get_last_error", socket_id, null, null);
	} else {
	}
	return null;
}
end_body
member
public: list startReceiveHeaders();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpClientConnection::startReceiveHeaders: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! HttpClientConnection::startReceiveHeaders: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	var list cb, buf;
	cb = al_list3(al_root_class(), this, HttpClientConnection::headersReceived);
	al_wnd_message(null, "msg_callback", msg, cb);
	buf = al_list3(buffer, 0, buffer_size);
	if (al_socket("recv", socket_id, buf, al_list3(hwnd, msg, 2))) {
		return "recv error: " + (string)al_socket("get_last_error", socket_id, null, null);
	} else {
	}
	return null;
}
end_body
member
public: list startReceiveBlockSize();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpClientConnection::startReceiveBlockSize: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! HttpClientConnection::startReceiveBlockSize: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	var list cb, buf;
	cb = al_list3(al_root_class(), this, HttpClientConnection::blockSizeReceived);
	al_wnd_message(null, "msg_callback", msg, cb);
	buf = al_list3(buffer, 0, buffer_size);
	if (al_socket("recv", socket_id, buf, al_list3(hwnd, msg, 1))) {
		return "recv error: " + (string)al_socket("get_last_error", socket_id, null, null);
	} else {
	}
	return null;
}
end_body
member
public: list startReceiveContents();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpClientConnection::startReceiveContents: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! HttpClientConnection::startReceiveContents: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	var list cb, buf;
	cb = al_list3(al_root_class(), this, HttpClientConnection::contentsReceived);
	al_wnd_message(null, "msg_callback", msg, cb);
	buf = al_list3(buffer, 0, buffer_size);
	if (content_length) {
		if (al_socket("recv", socket_id, buf, al_list4(hwnd, msg, 3, content_length))) {
			return "recv error: " + (string)al_socket("get_last_error", socket_id, null, null);
		} else {
		}
	} else {
		if (content_block_size) {
			if (al_socket("recv", socket_id, buf, al_list4(hwnd, msg, 3, content_block_size))) {
				return "recv error: " + (string)al_socket("get_last_error", socket_id, null, null);
			} else {
			}
		} else {
			if (al_socket("recv", socket_id, buf, al_list2(hwnd, msg))) {
				return "recv error: " + (string)al_socket("get_last_error", socket_id, null, null);
			} else {
			}
		}
	}
	return null;
}
end_body
member
public: list startReceiveCRLF();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpClientConnection::startReceiveCRLF: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! HttpClientConnection::startReceiveCRLF: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	var list cb, buf;
	cb = al_list3(al_root_class(), this, HttpClientConnection::CRLFReceived);
	al_wnd_message(null, "msg_callback", msg, cb);
	buf = al_list3(buffer, 0, buffer_size);
	if (al_socket("recv", socket_id, buf, al_list3(hwnd, msg, 1))) {
		return "recv error: " + (string)al_socket("get_last_error", socket_id, null, null);
	} else {
	}
	return null;
}
end_body
member
public: void commandReceived();
body
{
	if (socket_id) {
	} else {
		return;
	}
	var integer read_bytes;
	read_bytes = al_wnd_message(null, "lParam", null, null);
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpClientConnection::commandReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes);
		} else {
			al_print("!!! HttpClientConnection::commandReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes + "\n");
		}
	} else {
	}
	if (read_bytes < 0) {
		error = "recv error: " + (string)al_socket("get_last_error", socket_id, null, null);
		wait_obj.notify();
		return;
	} else {
	}
	command = al_misc("binary_to_string", al_list3(buffer, 0, read_bytes), null);
	var file f;
	f = al_file_open(command, "sr");
	al_file_read(f, "string");
	response_code = al_file_read(f, "integer");
	_time = 0;
	if (error = startReceiveHeaders()) {
		wait_obj.notify();
		return;
	} else {
	}
}
end_body
member
public: void headersReceived();
body
{
	if (socket_id) {
	} else {
		return;
	}
	var integer read_bytes;
	read_bytes = al_wnd_message(null, "lParam", null, null);
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpClientConnection::headersReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes);
		} else {
			al_print("!!! HttpClientConnection::headersReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes + "\n");
		}
	} else {
	}
	if (read_bytes < 0) {
		error = "recv error: " + (string)al_socket("get_last_error", socket_id, null, null);
		wait_obj.notify();
		return;
	} else {
	}
	if (headers = al_crypt("mime_headers_read", al_list3(buffer, 0, read_bytes), null, null)) {
		headers = headers.head;
	} else {
		headers = al_cons(null, null);
	}
	if (debug3) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "---- received Http Response Header\n" + (string)al_misc("binary_to_string", al_list3(buffer, 0, read_bytes), null));
		} else {
			al_print("---- received Http Response Header\n" + (string)al_misc("binary_to_string", al_list3(buffer, 0, read_bytes), null));
		}
	} else {
	}
	if (content_length = al_dst_node_i(headers, "Content-Length")) {
		content_length = (integer)content_length;
		if (content_length <= 0) {
			contents = al_misc("binary", 0, null);
			wait_obj.notify();
			return;
		} else {
		}
		_time = 0;
		if (error = startReceiveContents()) {
			wait_obj.notify();
			return;
		} else {
		}
	} else {
		var string encoding;
		encoding = al_dst_node_i(headers, "Transfer-Encoding");
		if (encoding && al_str_misc("strcmpi", encoding, "chunked") == 0) {
			chunked = 1;
			_time = 0;
			if (error = startReceiveBlockSize()) {
				wait_obj.notify();
				return;
			} else {
			}
		} else {
			_time = 0;
			if (error = startReceiveContents()) {
				wait_obj.notify();
				return;
			} else {
			}
		}
	}
}
end_body
member
public: void blockSizeReceived();
body
{
	if (socket_id) {
	} else {
		return;
	}
	var integer read_bytes;
	read_bytes = al_wnd_message(null, "lParam", null, null);
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpClientConnection::blockSizeReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes);
		} else {
			al_print("!!! HttpClientConnection::blockSizeReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes + "\n");
		}
	} else {
	}
	if (read_bytes < 0) {
		error = "recv error: " + (string)al_socket("get_last_error", socket_id, null, null);
		wait_obj.notify();
		return;
	} else {
	}
	var string hex_str;
	var file f;
	hex_str = al_misc("binary_to_string", al_list3(buffer, 0, read_bytes), null);
	f = al_file_open(hex_str, "sr");
	content_block_size = al_file_read(f, "hex");
	if (content_block_size > 0) {
		_time = 0;
		if (error = startReceiveContents()) {
			wait_obj.notify();
			return;
		} else {
		}
	} else {
		wait_obj.notify();
		return;
	}
}
end_body
member
public: void contentsReceived();
body
{
	if (socket_id) {
	} else {
		return;
	}
	var integer read_bytes;
	read_bytes = al_wnd_message(null, "lParam", null, null);
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpClientConnection::contentsReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes);
		} else {
			al_print("!!! HttpClientConnection::contentsReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes + "\n");
		}
	} else {
	}
	if (read_bytes < 0) {
		if (content_length) {
			error = "recv error: " + (string)al_socket("get_last_error", socket_id, null, null);
			wait_obj.notify();
			return;
		} else {
			wait_obj.notify();
			return;
		}
	} else {
	}
	if (content_length) {
		contents = al_misc("binary", read_bytes, null);
		al_misc("binary_copy", al_list2(contents, 0), al_list3(buffer, 0, read_bytes));
		wait_obj.notify();
		return;
	} else {
	}
	if (contents) {
		var integer idx;
		idx = al_misc("binary_size", contents, null);
		al_misc("extend_binary", contents, read_bytes);
		al_misc("binary_copy", al_list2(contents, idx), al_list3(buffer, 0, read_bytes));
	} else {
		contents = al_misc("binary", read_bytes, null);
		al_misc("binary_copy", al_list2(contents, 0), al_list3(buffer, 0, read_bytes));
	}
	if (chunked) {
		_time = 0;
		if (error = startReceiveCRLF()) {
			wait_obj.notify();
			return;
		} else {
		}
	} else {
		_time = 0;
		if (error = startReceiveContents()) {
			wait_obj.notify();
			return;
		} else {
		}
	}
}
end_body
member
public: void CRLFReceived();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! HttpClientConnection::CRLFReceived: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! HttpClientConnection::CRLFReceived: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	_time = 0;
	if (error = startReceiveBlockSize()) {
		wait_obj.notify();
		return;
	} else {
	}
}
end_body
member
public: list chunked;
member
public: list error;
member
public: integer buffer_size;
member
public: list buffer;
member
public: string command;
member
public: integer content_block_size;
member
public: list contents;
member
public: integer response_code;
member
public: list cert_info;
member
public: static list connections;
member
public: static list hostaddr_cache;
member
public: static integer connect_timeout;
end_class
class HttpServlet
member
public: void doGet(HttpRequest req, HttpResponse res);
body
{
	res.response_code = 404;
}
end_body
member
public: void doPost(HttpRequest req, HttpResponse res);
body
{
	res.response_code = 404;
}
end_body
member
public: static list servlet_params;
member
public: string toUTF8(string str);
body
{
	if (str) {
		str = al_str_misc("xml_encode", str, 0x0000000000000003);
	} else {
	}
	str = toUTF8_direct(str);
	return str;
}
end_body
member
public: string toUTF8_direct(string str);
body
{
	if (str) {
	} else {
		return "";
	}
	var string platform, s;
	platform = al_misc("platform", null, null);
	if (platform == "windows") {
		if (s = al_str_misc("sjis_to_utf8", str, null)) {
			str = s;
		} else {
		}
	} else {
	}
	return str;
}
end_body
member
public: string fromUTF8(string str);
body
{
	if (str) {
	} else {
		return null;
	}
	var string platform, s;
	platform = al_misc("platform", null, null);
	if (platform == "windows") {
		if (s = al_str_misc("utf8_to_sjis", str, null)) {
			str = s;
		} else {
		}
	} else {
	}
	return str;
}
end_body
member
public: string fromUTF8(list str);
body
{
	var string s;
	s = str;
	return fromUTF8(s);
}
end_body
class WebUIServlet
member
public: void doGet(HttpRequest req, HttpResponse res);
body
{
	this.req = req;
	this.res = res;
	var list params;
	params = req.getParameters();
	action = (string)al_dst_node(params, "action");
	if (session = req.getSession()) {
		target = session.getAttribute("target");
		user_name = session.getAttribute("user_name");
		user_roles = session.getAttribute("user_roles");
		admin_target = adminMenuTarget(target, user_name);
	} else {
		error("no session");
		return;
	}
	if (target == "system") {
		doAction(params);
		return;
	} else {
	}
	var string class_name;
	var WebUIServlet servlet;
	class_name = "WebUI" + (string)target + "Servlet";
	if (servlet = al_gp("new", class_name, null, null, null)) {
	} else {
		error("servlet for target '" + (string)target + "' not found");
		return;
	}
	servlet.action = action;
	servlet.target = target;
	servlet.admin_target = adminMenuTarget(target, user_name);
	servlet.user_name = user_name;
	servlet.user_roles = user_roles;
	servlet.req = req;
	servlet.res = res;
	servlet.session = session;
	servlet.doAction(params);
}
end_body
member
public: void doPost(HttpRequest req, HttpResponse res);
body
{
	this.req = req;
	this.res = res;
	var list params;
	params = req.getParameters();
	action = (string)al_dst_node(params, "action");
	if (session = req.getSession()) {
		target = session.getAttribute("target");
		user_name = session.getAttribute("user_name");
		user_roles = session.getAttribute("user_roles");
		admin_target = adminMenuTarget(target, user_name);
	} else {
		if (al_search_str(action, 0, "Login") < 0 && session == null) {
			error("no session");
			return;
		} else {
			target = fromUTF8((list)al_dst_node(params, "target"));
			if (target == null || target == "") {
				target = "system";
			} else {
			}
			user_name = target + ":" + (string)fromUTF8((list)al_dst_node(params, "user"));
		}
	}
	if (target == "system") {
		doAction(params);
		return;
	} else {
	}
	var string class_name;
	var WebUIServlet servlet;
	class_name = "WebUI" + (string)target + "Servlet";
	if (servlet = al_gp("new", class_name, null, null, null)) {
	} else {
		error("servlet for target '" + (string)target + "' not found");
		return;
	}
	servlet.action = action;
	servlet.target = target;
	servlet.admin_target = adminMenuTarget(target, user_name);
	servlet.user_name = user_name;
	servlet.user_roles = user_roles;
	servlet.req = req;
	servlet.res = res;
	servlet.session = session;
	servlet.doAction(params);
}
end_body
member
public: void doAction(list params);
body
{
	var DbConnection conn;
	var list arg_dcl, arg1, arg2, method_name, args;
	try {
		conn = DbManager::getConnection(pool_name);
		method_name = "invoke" + action;
		arg_dcl = get_arg_dcl(null, (DbConnection)null);
		arg1 = al_list3(arg_dcl.head, params, null);
		arg2 = al_list3(arg_dcl.tail.tail.head, conn, null);
		args = al_list2(arg1, arg2);
		if (al_gp("run2", this, arg_dcl, method_name, args) == 0x0000000080000000) {
			error("specified action '" + action + "' not found.");
			conn.rollback();
			conn.close();
			return;
		} else {
		}
		conn.commit();
		conn.close();
	} catch (AlException e) {
		if (conn) {
			try {
				conn.rollback();
			} catch (AlException e) {
			}
			try {
				conn.close();
			} catch (AlException e) {
			}
		} else {
		}
		error("", e);
	}
}
end_body
member
public: list get_arg_dcl(list params, DbConnection conn);
body
{
	return al_gp("arg_dcl", null, null, null, null);
}
end_body
member
public: list invokeLogin(list params, DbConnection conn);
body
{
	if (authorize(params, conn)) {
	} else {
		return null;
	}
	if (al_dst_node(user_roles, "webuiadmin")) {
		res.redirect("ebiz?action=WebUiAdminHome");
		return null;
	} else {
	}
	if (al_dst_node(user_roles, "admin")) {
		res.redirect("ebiz?action=AdminHome");
		return null;
	} else {
	}
	error("User '" + user_name + "' does not have required user role");
	return null;
}
end_body
member
public: list invokeLogout(list params, DbConnection conn);
body
{
	session.invalidate();
	res.redirect("index.html");
	return null;
}
end_body
member
public: list authorize(list params, DbConnection conn);
body
{
	var XmlDbAccessor acc;
	var XmlDbObject obj;
	var string pass, pass2, role_name;
	var list ls, itr;
	if (session) {
		session.invalidate();
	} else {
	}
	pass = al_dst_node(params, "pass");
	acc = new XmlDbAccessor;
	acc.create("User", "", conn);
	acc.setDTDfilename("User.dtd");
	ls = acc.get("User/Id", user_name);
	itr = al_dst_itr(ls);
	if (al_count(itr) == 0) {
		error("User '" + user_name + "' not found.");
		return null;
	} else {
	}
	if (al_count(itr) > 1) {
		error("number of user '" + user_name + "' records is more than 1.");
		return null;
	} else {
	}
	obj = al_next(itr);
	pass2 = obj.getField("User/Password");
	if (pass2 != pass) {
		error("Password not match.");
		return null;
	} else {
	}
	req._server.ap_server.system_log("info", "user '" + user_name + "' login.");
	session = req.createSession();
	ls = obj.getChildren("User/RoleName");
	itr = al_dst_itr(ls);
	user_roles = al_cons(null, null);
	loop {
		if (obj = al_next(itr)) {
		} else {
			break;
		}
		role_name = obj.getField("");
		al_create_arc(user_roles, al_cons(null, null), role_name);
	}
	session.setAttribute("target", target);
	session.setAttribute("user_name", user_name);
	session.setAttribute("user_roles", user_roles);
	return 1;
}
end_body
member
public: list authorize2(list params, DbConnection conn);
body
{
	var XmlDbAccessor acc;
	var XmlDbObject obj;
	var string pass, pass2, role_name;
	var list ls, itr;
	pass = al_dst_node(params, "pass");
	acc = new XmlDbAccessor;
	acc.create("User", "", conn);
	acc.setDTDfilename("User.dtd");
	ls = acc.get("User/Id", user_name);
	itr = al_dst_itr(ls);
	if (al_count(itr) == 0) {
		error("User '" + user_name + "' not found.");
		return null;
	} else {
	}
	if (al_count(itr) > 1) {
		error("number of user '" + user_name + "' records is more than 1.");
		return null;
	} else {
	}
	obj = al_next(itr);
	pass2 = obj.getField("User/Password");
	if (pass2 != pass) {
		error("Password not match.");
		return null;
	} else {
	}
	if (session) {
	} else {
		req._server.ap_server.system_log("info", "user '" + user_name + "' login.");
		session = req.createSession();
	}
	ls = obj.getChildren("User/RoleName");
	itr = al_dst_itr(ls);
	user_roles = al_cons(null, null);
	loop {
		if (obj = al_next(itr)) {
		} else {
			break;
		}
		role_name = obj.getField("");
		al_create_arc(user_roles, al_cons(null, null), role_name);
	}
	session.setAttribute("target", target);
	session.setAttribute("user_name", user_name);
	session.setAttribute("user_roles", user_roles);
	return 1;
}
end_body
member
public: list checkUserRole(string role_name);
body
{
	if (user_roles && al_dst_node(user_roles, role_name)) {
		return 1;
	} else {
	}
	error("user_role '" + (string)role_name + "' required");
	return null;
}
end_body
member
public: list checkUserRole(DbConnection conn);
body
{
	var XmlDbAccessor acc;
	var XmlDbObject obj;
	var list ls, itr;
	var string view_name, role_name;
	acc = new XmlDbAccessor;
	acc.create("WebUiData", "", conn);
	acc.setDTDfilename("WebUiData.dtd");
	ls = acc.get("WebUiData/Target", adminMenuTarget(target, user_name));
	itr = al_dst_itr(ls);
	if (obj = al_next(itr)) {
	} else {
		error("WebUiData information of target '" + (string)user_name + "' not found.");
		return null;
	}
	ls = obj.getChildren("WebUiData/MenuItem", "Name", action);
	itr = al_dst_itr(ls);
	if (obj = al_next(itr)) {
	} else {
		error("required roles of view '" + action + "' not found.");
		return null;
	}
	ls = obj.getChildren("View/RoleName");
	itr = al_dst_itr(ls);
	loop {
		if (obj = al_next(itr)) {
		} else {
			break;
		}
		role_name = obj.getField("");
		if (al_dst_node(user_roles, role_name)) {
		} else {
			error("user_role '" + (string)role_name + "' required");
			return null;
		}
	}
	return 1;
}
end_body
member
public: string action;
member
public: string target;
member
public: string admin_target;
member
public: string user_name;
member
public: list user_roles;
member
public: void error(string msg);
body
{
	res._create();
	res.out("<HTML><HEAD><TITLE>Error</TITLE></HEAD><BODY>\n");
	res.out(msg);
	res.out("</BODY></HEML>\n");
}
end_body
member
public: void error(string msg, AlException e);
body
{
	var string s, s2, line;
	var file f, f2;
	s = al_copy("");
	f = al_file_open(s, "sw");
	al_file_write(f, "string", "StackTrace\n");
	al_misc("stack_trace", e.stack_frame, f);
	al_file_write(f, "string", "Source\n");
	al_misc("error_source", al_list2(e.stack_frame, e.pos), f);
	f = al_file_open(s, "sr");
	s2 = al_copy("");
	f2 = al_file_open(s2, "sw");
	loop {
		if (line = al_file_read(f, "line")) {
		} else {
			break;
		}
		line = al_str_misc("xml_encode", line, 3);
		if (line == "StackTrace" || line == "Source") {
			al_file_write(f2, "string", "<H4>");
		} else {
		}
		al_file_write(f2, "string", line);
		if (line == "StackTrace" || line == "Source") {
			al_file_write(f2, "string", "</H4>");
		} else {
			al_file_write(f2, "string", "<BR/>");
		}
	}
	error(msg + "<BR/><BR/>" + "Exception: e.msg = " + e.msg + "<BR/><BR/>" + s2);
}
end_body
member
public: HttpRequest req;
member
public: HttpResponse res;
member
public: HttpSession session;
member
public: static string pool_name;
member
public: list invokeWebUiAdminHome(list params, DbConnection conn);
body
{
	if (checkUserRole("webuiadmin")) {
	} else {
		return null;
	}
	var XmlDbAccessor acc;
	var XmlDbObject obj;
	var list ls, itr, sel_values;
	var string line_number, name, kind, text;
	acc = new XmlDbAccessor;
	acc.create("WebUiData", "", conn);
	acc.setDTDfilename("WebUiData.dtd");
	ls = acc.get("WebUiData/Target", target);
	itr = al_dst_itr(ls);
	if (al_count(itr) == 0) {
		error("WebUiData not found.");
		return null;
	} else {
	}
	if (al_count(itr) > 1) {
		error("number of WebUiData records is more than 1.");
		return null;
	} else {
	}
	obj = al_next(itr);
	genPageBegin("MenuEdit");
	genFormBegin("WebUiAdminMenuEdit", null);
	genTitle("Menu Edit");
	res.out("<TABLE BORDER=\"1\">\n");
	res.out("<TR><TD>Kind</TD><TD>Name</TD><TD>Text</TD></TR>\n");
	ls = obj.getChildren("WebUiData/MenuItem", (list)al_cons(null, null), "LineNumber", "", "0", "9999", "LineNumber", "integer", null);
	itr = al_dst_itr(ls);
	loop {
		if (obj = al_next(itr)) {
		} else {
			break;
		}
		line_number = obj.getField("LineNumber");
		name = obj.getField("Name");
		kind = obj.getField("Kind");
		text = obj.getField("Text");
		res.out("<TR><TD>");
		genRadio("radio", name, kind, null);
		res.out("</TD><TD>");
		genText(name);
		res.out("</TD><TD>");
		genTextField(name + "-Text", 20, text);
		res.out("</TD></TR>\n");
		genHidden(name + "-Hidden", line_number);
	}
	res.out("</TABLE>\n");
	sel_values = al_cons(null, null);
	al_create_arc(sel_values, "Title", null);
	al_create_arc(sel_values, "View", (list)1);
	al_create_arc(sel_values, "RefreshView", null);
	genText("Kind");
	genSelect("Create-Select", sel_values);
	genBR();
	genText("Name");
	genTextField("Create-Name", 20, "");
	genBR();
	genText("Text");
	genTextField("Create-Text", 20, "");
	genBR();
	genButton("submit", "create");
	genBR();
	genButton("submit", "update");
	genButton("submit", "delete");
	genButton("submit", "up");
	genButton("submit", "down");
	genBR();
	genButton("submit", "edit view");
	genHR();
	genButton("submit", "logout");
	genBR();
	genFormEnd();
	genPageEnd();
	return null;
}
end_body
member
public: list invokeWebUiAdminMenuEdit(list params, DbConnection conn);
body
{
	if (checkUserRole("webuiadmin")) {
	} else {
		return null;
	}
	var string submit;
	var string item, item_text;
	var string create_select, create_name, create_text;
	var integer item_number, i, i2;
	var XmlDbAccessor acc;
	var XmlDbObject obj, obj2;
	var list ls, itr;
	var string name, kind, text;
	submit = al_dst_node(params, "submit");
	item = al_dst_node(params, "radio");
	if (item && item != "") {
		item_number = (integer)al_dst_node(params, item + "-Hidden");
		item_text = fromUTF8((string)al_dst_node(params, item + "-Text"));
	} else {
		item_number = 0;
	}
	create_select = al_dst_node(params, "Create-Select");
	create_name = al_dst_node(params, "Create-Name");
	create_text = fromUTF8((string)al_dst_node(params, "Create-Text"));
	acc = new XmlDbAccessor;
	acc.create("WebUiData", "", conn);
	acc.setDTDfilename("WebUiData.dtd");
	ls = acc.get("WebUiData/Target", target);
	itr = al_dst_itr(ls);
	obj = al_next(itr);
	ls = obj.getChildren("WebUiData/MenuItem", (list)al_cons(null, null), "LineNumber", "", "0", "9999", "LineNumber", "integer", null);
	itr = al_dst_itr(ls);
	if (submit == "create") {
		if (create_name && create_name != "" && create_text && create_text != "") {
			if (obj2 = findItem(itr, item_number)) {
				i = (integer)obj2.getField("LineNumber");
				al_prev(itr);
				incLineNumber(itr);
			} else {
				i = max_line_number + 1;
			}
			obj = obj.createChild("WebUiData/MenuItem");
			obj.putField("LineNumber", (string)i);
			obj.putField("Name", create_name);
			obj.putField("Kind", create_select);
			obj.putField("Text", create_text);
		} else {
			error("Name or Text is null.");
			return null;
		}
		return invokeWebUiAdminHome(params, conn);
	} else {
	}
	if (submit == "delete") {
		if (obj = findItem(itr, item_number)) {
			obj.delete();
			decLineNumber(itr);
		} else {
			error("radio button not checked.");
			return null;
		}
		return invokeWebUiAdminHome(params, conn);
	} else {
	}
	if (submit == "up") {
		if (obj = findItem(itr, item_number) && obj2 = al_prev(itr)) {
			i = (integer)obj.getField("LineNumber");
			i2 = (integer)obj2.getField("LineNumber");
			obj.putField("LineNumber", (string)i2);
			obj2.putField("LineNumber", (string)i);
		} else {
			error("radio button not checked or top item checked.");
			return null;
		}
		return invokeWebUiAdminHome(params, conn);
	} else {
	}
	if (submit == "down") {
		if (obj = findItem(itr, item_number) && obj2 = al_next(itr)) {
			i = (integer)obj.getField("LineNumber");
			i2 = (integer)obj2.getField("LineNumber");
			obj.putField("LineNumber", (string)i2);
			obj2.putField("LineNumber", (string)i);
		} else {
			error("radio button not checked or bottom item checked.");
			return null;
		}
		return invokeWebUiAdminHome(params, conn);
	} else {
	}
	if (submit == "update") {
		if (item_text && item_text != "") {
			if (obj = findItem(itr, item_number)) {
				obj.putField("Text", item_text);
			} else {
				error("Text is null.");
				return null;
			}
		} else {
			error("radio button not checked.");
			return null;
		}
		return invokeWebUiAdminHome(params, conn);
	} else {
	}
	if (submit == "edit view") {
		if (item && item != "") {
			session.setAttribute("view_name", item);
		} else {
			error("radio button not checked.");
			return null;
		}
		return invokeWebUiAdminViewHome(params, conn);
	} else {
	}
	if (submit == "logout") {
		return invokeLogout(params, conn);
	} else {
	}
	return invokeWebUiAdminViewHome(params, conn);
}
end_body
member
public: list invokeWebUiAdminViewHome(list params, DbConnection conn);
body
{
	if (checkUserRole("webuiadmin")) {
	} else {
		return null;
	}
	var string view_name;
	var XmlDbAccessor acc;
	var XmlDbObject obj, obj2;
	var list ls, itr, sel_values;
	var string line_number, name, kind, text;
	if (view_name = session.getAttribute("view_name")) {
	} else {
		error("view name is not setted.");
		return null;
	}
	acc = new XmlDbAccessor;
	acc.create("WebUiData", "", conn);
	acc.setDTDfilename("WebUiData.dtd");
	ls = acc.get("WebUiData/Target", target);
	itr = al_dst_itr(ls);
	obj = al_next(itr);
	ls = obj.getChildren("WebUiData/MenuItem", "Name", view_name);
	itr = al_dst_itr(ls);
	if (al_count(itr) == 0) {
		error("view '" + (string)view_name + "' not found.");
		return null;
	} else {
	}
	if (al_count(itr) > 1) {
		error("number of view '" + (string)view_name + "' is more than 1.");
		return null;
	} else {
	}
	obj = al_next(itr);
	genPageBegin("ViewEdit");
	genFormBegin("WebUiAdminViewEdit", null);
	genTitle("View Edit (view name = " + (string)view_name + ")");
	ls = obj.getChildren("View/RoleName");
	itr = al_dst_itr(ls);
	genText("* Requried Roles");
	genBR();
	res.out("<TABLE BORDER=\"1\">\n");
	res.out("<TR><TD>Required Role</TD></TR>\n");
	sel_values = al_cons(null, null);
	loop {
		if (obj2 = al_next(itr)) {
		} else {
			break;
		}
		var string role_name;
		role_name = obj2.getField("");
		al_create_arc(sel_values, role_name, null);
		res.out("<TR><TD>");
		res.out(toUTF8(role_name));
		res.out("</TD><TR>\n");
	}
	res.out("</TABLE>\n");
	genTextField("addRole-Text", 20, "");
	genButton("submit", "addRole");
	genSelect("removeRole-Text", sel_values);
	genButton("submit", "removeRole");
	res.out("</TABLE>\n");
	genHR();
	genText("* UI parts");
	genBR();
	res.out("<TABLE BORDER=\"1\">\n");
	res.out("<TR><TD>Kind</TD><TD>Name</TD><TD>Text</TD></TR>\n");
	ls = obj.getChildren("View/UiElem", (list)al_cons(null, null), "LineNumber", "", "0", "9999", "LineNumber", "integer", null);
	itr = al_dst_itr(ls);
	loop {
		if (obj = al_next(itr)) {
		} else {
			break;
		}
		line_number = obj.getField("LineNumber");
		name = obj.getField("Name");
		kind = obj.getField("Kind");
		text = obj.getField("Text");
		res.out("<TR><TD>");
		genRadio("radio", name, kind, null);
		res.out("</TD><TD>");
		if (kind != "BR" && kind != "Text") {
			genText(name);
		} else {
		}
		res.out("</TD><TD>");
		if (kind == "Text" || kind == "Link" || kind == "Button" || kind == "TextField" || kind == "TextArea" || kind == "Radio" || kind == "Table1" || kind == "Table2") {
			genTextField(name + "-Text", 20, text);
		} else {
		}
		res.out("</TD></TR>\n");
		genHidden(name + "-Hidden", line_number);
	}
	res.out("</TABLE>\n");
	sel_values = al_cons(null, null);
	al_create_arc(sel_values, "Title", null);
	al_create_arc(sel_values, "Text", null);
	al_create_arc(sel_values, "Link", null);
	al_create_arc(sel_values, "BR", null);
	al_create_arc(sel_values, "Button", (list)1);
	al_create_arc(sel_values, "Check", null);
	al_create_arc(sel_values, "Radio", null);
	al_create_arc(sel_values, "TextField", null);
	al_create_arc(sel_values, "Password", null);
	al_create_arc(sel_values, "TextArea", null);
	al_create_arc(sel_values, "Upload", null);
	al_create_arc(sel_values, "Select", null);
	al_create_arc(sel_values, "Table1", null);
	al_create_arc(sel_values, "Table2", null);
	genText("Kind");
	genSelect("Create-Select", sel_values);
	genText("Name");
	genTextField("Create-Name", 20, "");
	genText("Text");
	genTextField("Create-Text", 20, "");
	genBR();
	genButton("submit", "create");
	genBR();
	genButton("submit", "update");
	genButton("submit", "delete");
	genButton("submit", "up");
	genButton("submit", "down");
	genBR();
	genButton("submit", "edit select/table");
	genHR();
	genButton("submit", "return");
	genBR();
	genFormEnd();
	genPageEnd();
	return null;
}
end_body
member
public: list invokeWebUiAdminViewEdit(list params, DbConnection conn);
body
{
	if (checkUserRole("webuiadmin")) {
	} else {
		return null;
	}
	var string submit;
	var string item, item_text, submit_text;
	var string create_select, create_name, create_text;
	var integer item_number, i, i2;
	var string view_name;
	var XmlDbAccessor acc;
	var XmlDbObject obj, obj2;
	var list ls, itr;
	var string name, kind, text;
	submit = al_dst_node(params, "submit");
	submit_text = fromUTF8((string)al_dst_node(params, submit + "-Text"));
	item = al_dst_node(params, "radio");
	if (item && item != "") {
		item_number = (integer)al_dst_node(params, item + "-Hidden");
		item_text = fromUTF8((string)al_dst_node(params, item + "-Text"));
	} else {
		item_number = 0;
	}
	create_select = al_dst_node(params, "Create-Select");
	create_name = al_dst_node(params, "Create-Name");
	create_text = fromUTF8((string)al_dst_node(params, "Create-Text"));
	if (view_name = session.getAttribute("view_name")) {
	} else {
		error("view name is not setted.");
		return null;
	}
	acc = new XmlDbAccessor;
	acc.create("WebUiData", "", conn);
	acc.setDTDfilename("WebUiData.dtd");
	ls = acc.get("WebUiData/Target", target);
	itr = al_dst_itr(ls);
	obj = al_next(itr);
	ls = obj.getChildren("WebUiData/MenuItem", "Name", view_name);
	itr = al_dst_itr(ls);
	if (al_count(itr) == 0) {
		error("view '" + (string)view_name + "' not found.");
		return null;
	} else {
	}
	if (al_count(itr) > 1) {
		error("number of view '" + (string)view_name + "' is more than 1.");
		return null;
	} else {
	}
	obj = al_next(itr);
	ls = obj.getChildren("View/UiElem", (list)al_cons(null, null), "LineNumber", "", "0", "9999", "LineNumber", "integer", null);
	itr = al_dst_itr(ls);
	if (submit == "addRole") {
		if (submit_text && submit_text != "") {
			obj = obj.createChild("View/RoleName");
			obj.putField("", submit_text);
			invokeWebUiAdminViewHome(params, conn);
		} else {
			error("role to be added is null.");
			return null;
		}
		return invokeWebUiAdminViewHome(params, conn);
	} else {
	}
	if (submit == "removeRole") {
		ls = obj.getChildren("View/RoleName", "", submit_text);
		itr = al_dst_itr(ls);
		if (obj = al_next(itr)) {
			obj.delete();
		} else {
			error("role to be deleted not found.");
			return null;
		}
		return invokeWebUiAdminViewHome(params, conn);
	} else {
	}
	if (submit == "create") {
		if (create_name && create_name != "" && create_text) {
			if (obj2 = findItem(itr, item_number)) {
				i = (integer)obj2.getField("LineNumber");
				al_prev(itr);
				incLineNumber(itr);
			} else {
				i = max_line_number + 1;
			}
			obj = obj.createChild("View/UiElem");
			obj.putField("LineNumber", (string)i);
			obj.putField("Name", create_name);
			obj.putField("Kind", create_select);
			obj.putField("Text", create_text);
		} else {
			error("Name or Text is null.");
			return null;
		}
		return invokeWebUiAdminViewHome(params, conn);
	} else {
	}
	if (submit == "delete") {
		if (obj = findItem(itr, item_number)) {
			obj.delete();
			decLineNumber(itr);
		} else {
			error("radio button not checked.");
			return null;
		}
		return invokeWebUiAdminViewHome(params, conn);
	} else {
	}
	if (submit == "up") {
		if (obj = findItem(itr, item_number) && obj2 = al_prev(itr)) {
			i = (integer)obj.getField("LineNumber");
			i2 = (integer)obj2.getField("LineNumber");
			obj.putField("LineNumber", (string)i2);
			obj2.putField("LineNumber", (string)i);
		} else {
			error("radio button not checked or top item checked.");
			return null;
		}
		return invokeWebUiAdminViewHome(params, conn);
	} else {
	}
	if (submit == "down") {
		if (obj = findItem(itr, item_number) && obj2 = al_next(itr)) {
			i = (integer)obj.getField("LineNumber");
			i2 = (integer)obj2.getField("LineNumber");
			obj.putField("LineNumber", (string)i2);
			obj2.putField("LineNumber", (string)i);
		} else {
			error("radio button not checked or bottom item checked.");
			return null;
		}
		return invokeWebUiAdminViewHome(params, conn);
	} else {
	}
	if (submit == "update") {
		if (item_text) {
			if (obj = findItem(itr, item_number)) {
				obj.putField("Text", item_text);
			} else {
				error("Text is null.");
				return null;
			}
		} else {
			error("radio button not checked.");
			return null;
		}
		return invokeWebUiAdminViewHome(params, conn);
	} else {
	}
	if (submit == "edit select/table") {
		if (item && item != "") {
			session.setAttribute("db_parts_name", item);
			return invokeWebUiAdminSelectableHome(params, conn);
		} else {
			error("radio button not checked.");
			return null;
		}
		return invokeWebUiAdminSelectableHome(params, conn);
	} else {
	}
	if (submit == "return") {
		session.setAttribute("view_name", null);
		return invokeWebUiAdminHome(params, conn);
	} else {
	}
}
end_body
member
public: list invokeWebUiAdminSelectableHome(list params, DbConnection conn);
body
{
	if (checkUserRole("webuiadmin")) {
	} else {
		return null;
	}
	var string view_name, db_parts_name;
	var XmlDbAccessor acc, meta_acc;
	var XmlDbObject obj, obj2, obj3, meta_obj;
	var list ls, itr, itr2;
	var string name, kind;
	var string msgType, msgVersion, dtd_filename, child_path, type, default;
	var string line_number, path, value, line_number2;
	var string range_path, range_type, from, to;
	var string orderby_path, orderby_type, desc, count_from, count_max;
	var string column_name, column_value;
	var string column_name2, column_value2;
	var string editable, password;
	if (view_name = session.getAttribute("view_name")) {
	} else {
		error("view name is not setted.");
		return null;
	}
	acc = new XmlDbAccessor;
	acc.create("WebUiData", "", conn);
	acc.setDTDfilename("WebUiData.dtd");
	ls = acc.get("WebUiData/Target", target);
	itr = al_dst_itr(ls);
	obj = al_next(itr);
	ls = obj.getChildren("WebUiData/MenuItem", "Name", view_name);
	itr = al_dst_itr(ls);
	if (al_count(itr) == 0) {
		error("view '" + (string)view_name + "' not found.");
		return null;
	} else {
	}
	if (al_count(itr) > 1) {
		error("number of view '" + (string)view_name + "' is more than 1.");
		return null;
	} else {
	}
	obj = al_next(itr);
	if (db_parts_name = session.getAttribute("db_parts_name")) {
	} else {
		error("db parts name is not setted.");
		return null;
	}
	ls = obj.getChildren("View/UiElem", "Name", db_parts_name);
	itr = al_dst_itr(ls);
	if (al_count(itr) == 0) {
		error("db parts '" + (string)db_parts_name + "' not found.");
		return null;
	} else {
	}
	if (al_count(itr) > 1) {
		error("number of db_parts '" + (string)db_parts_name + "' is more than 1.");
		return null;
	} else {
	}
	obj = al_next(itr);
	name = obj.getField("Name");
	kind = obj.getField("Kind");
	genPageBegin("SelectableEdit");
	genFormBegin("WebUiAdminSelectableEdit", null);
	genTitle("Selectable Edit (name = " + (string)name + ", kind =" + (string)kind + ")");
	ls = obj.getChildren("Selectable/Children", (list)al_cons(null, null), "LineNumber", "", "0", "9999", "LineNumber", "integer", null);
	itr = al_dst_itr(ls);
	res.out("<TABLE BORDER=\"1\">\n");
	res.out("<TR><TD></TD><TD>MsgType,ChildPath</TD><TD>Condition</TD><TD>Type</TD><TD>Default</TD></TR>\n");
	loop {
		if (obj2 = al_next(itr)) {
		} else {
			break;
		}
		res.out("<TR>");
		line_number = obj2.getField("LineNumber");
		res.out("<TD>");
		genRadio("radio", "Children-" + line_number, "", null);
		res.out("</TD><TD>");
		genHidden("Children-Hidden", line_number);
		if (msgType = obj2.getField("MsgType")) {
			msgVersion = obj2.getField("MsgVersion");
			dtd_filename = obj2.getField("DTDfilename");
			genText("msgType");
			genTextField("msgType", 20, msgType);
			genBR();
			genText("msgVersion");
			genTextField("msgVersion", 20, msgVersion);
			genBR();
			genText("DTDfilename");
			genTextField("DTDfilename", 20, dtd_filename);
			meta_acc = new XmlDbAccessor;
			meta_acc.create(msgType, getValue(msgVersion), conn);
			meta_acc.setDTDfilename(dtd_filename);
			meta_obj = meta_acc.getMetaInfo();
		} else {
			child_path = obj2.getField("ChildPath");
			genText("ChildPath");
			genTextField("ChildPath-" + line_number, 20, child_path);
			meta_obj = meta_obj.getMetaInfo(child_path);
		}
		res.out("</TD><TD></TD><TD>");
		type = obj2.getField("Type");
		genTextField("Type-" + line_number, 7, type);
		res.out("</TD><TD>");
		default = obj2.getField("Default");
		genTextField("Default-" + line_number, 15, default);
		res.out("</TD></TR>");
		ls = obj2.getChildren("Condition", (list)al_cons(null, null), "LineNumber", "", "0", "9999", "LineNumber", "integer", null);
		itr2 = al_dst_itr(ls);
		loop {
			if (obj3 = al_next(itr2)) {
			} else {
				break;
			}
			line_number2 = obj3.getField("LineNumber");
			path = obj3.getField("Path");
			value = obj3.getField("Value");
			res.out("<TR><TD>");
			genRadio("radio", "Cond-" + line_number + ":" + line_number2, "", null);
			res.out("</TD><TD></TD><TD>");
			genText("Path");
			genTextField("Cond-Path-" + line_number + ":" + line_number2, 20, path);
			genBR();
			genText("Value");
			genTextField("Cond-Value-" + line_number + ":" + line_number2, 20, value);
			res.out("</TD><TD></TD></TR>");
		}
	}
	res.out("</TABLE>\n");
	genText("Path");
	genTextField("Create-Path", 20, "");
	genText("Type/Value");
	genTextField("Create-Value", 20, "");
	genBR();
	genButton("submit", "create");
	genButton("submit", "condition create");
	genBR();
	genButton("submit", "update");
	genButton("submit", "delete");
	genButton("submit", "up");
	genButton("submit", "down");
	genHR();
	if (kind == "Table2") {
		range_path = obj.getField("Selectable/Condition2/RangePath");
		range_type = obj.getField("Selectable/Condition2/RangeType");
		from = obj.getField("Selectable/Condition2/From");
		to = obj.getField("Selectable/Condition2/To");
		orderby_path = obj.getField("Selectable/Condition2/OrderByPath");
		orderby_type = obj.getField("Selectable/Condition2/OrderByType");
		desc = obj.getField("Selectable/Condition2/Desc");
		count_from = obj.getField("Selectable/Condition2/CountFrom");
		count_max = obj.getField("Selectable/Condition2/CountMax");
		column_name = obj.getField("Selectable/Condition2/ColumnName");
		column_value = obj.getField("Selectable/Condition2/ColumnValue");
		column_name2 = obj.getField("Selectable/Condition2/ColumnName2");
		column_value2 = obj.getField("Selectable/Condition2/ColumnValue2");
		genText("RagnePath");
		genTextField("RangePath", 30, range_path);
		genText("RagneType");
		genTextField("RangeType", 30, range_type);
		genBR();
		genText("From");
		genTextField("From", 30, from);
		genText("To");
		genTextField("To", 30, to);
		genBR();
		genText("OrderByPath");
		genTextField("OrderByPath", 30, orderby_path);
		genText("OrderByType");
		genTextField("OrderByType", 30, orderby_type);
		genBR();
		genText("Desc");
		genTextField("Desc", 10, desc);
		genBR();
		genText("CountFrom");
		genTextField("CountFrom", 30, count_from);
		genText("CountMax");
		genTextField("CountMax", 30, count_max);
		genBR();
		genText("ColumnName");
		genTextField("ColumnName", 30, column_name);
		genText("ColumnValue");
		genTextField("ColumnValue", 30, column_value);
		genBR();
		genText("ColumnName2");
		genTextField("ColumnName2", 30, column_name2);
		genText("ColumnValue2");
		genTextField("ColumnValue2", 30, column_value2);
		genBR();
		genButton("submit", "condition update");
		genButton("submit", "condition delete");
		genHR();
	} else {
	}
	itr = al_dst_itr(meta_obj.xpath_list);
	res.out("<TABLE BORDER=\"1\">\n");
	res.out("<TR><TD></TD><TD>Path</TD><TD>LineNumber</TD><TD>Visible</TD><TD>Editable</TD><TD>Password</TD></TR>\n");
	loop {
		if (path = al_next(itr)) {
		} else {
			break;
		}
		res.out("<TR><TD>");
		genRadio("radio", "Item-" + path, "", null);
		res.out("</TD><TD>");
		genText(path);
		genHidden("Item-" + path + "-Path", path);
		res.out("</TD><TD>");
		ls = obj.getChildren("Selectable/TableItem", "Path", path);
		itr2 = al_dst_itr(ls);
		if (obj2 = al_next(itr2)) {
			genHidden("Item-" + path, path);
			line_number = obj2.getField("LineNumber");
			editable = obj2.getField("Editable");
			password = obj2.getField("Password");
			genTextField("Item-" + path + "-LineNumber", 5, line_number);
			res.out("</TD><TD>");
			genTextField("Item-" + path + "-Visible", 10, "true");
			res.out("</TD><TD>");
			genTextField("Item-" + path + "-Editable", 10, editable);
			res.out("</TD><TD>");
			genTextField("Item-" + path + "-Password", 10, password == "true" ? "true" : "");
			res.out("</TD></TR>");
		} else {
			genTextField("Item-" + path + "-LineNumber", 5, "0");
			res.out("</TD><TD>");
			genTextField("Item-" + path + "-Visible", 10, "false");
			res.out("</TD><TD>");
			genTextField("Item-" + path + "-Editable", 10, "");
			res.out("</TD><TD>");
			genTextField("Item-" + path + "-Password", 10, "");
			res.out("</TD></TR>");
		}
	}
	res.out("</TABLE>\n");
	genButton("submit", "table item update");
	genHR();
	genButton("submit", "return");
	genBR();
	genFormEnd();
	genPageEnd();
	return null;
}
end_body
member
public: list invokeWebUiAdminSelectableEdit(list params, DbConnection conn);
body
{
	if (checkUserRole("webuiadmin")) {
	} else {
		return null;
	}
	var string submit, item;
	var string create_path, create_value;
	var integer idx, idx2, item_number, i, item_number2, i2;
	var string view_name, db_parts_name;
	var XmlDbAccessor acc, meta_acc;
	var XmlDbObject obj, obj2, obj3;
	var list ls, itr, itr2;
	var string msgType, msgVersion, dtd_filename, child_path, type, default;
	var string path, value, line_number;
	var string range_path, range_type, from, to;
	var string orderby_path, orderby_type, desc, count_from, count_max;
	var string column_name, column_value;
	var string column_name2, column_value2;
	var string visible, editable, password;
	if (view_name = session.getAttribute("view_name")) {
	} else {
		error("view name is not setted.");
		return null;
	}
	acc = new XmlDbAccessor;
	acc.create("WebUiData", "", conn);
	acc.setDTDfilename("WebUiData.dtd");
	ls = acc.get("WebUiData/Target", target);
	itr = al_dst_itr(ls);
	obj = al_next(itr);
	ls = obj.getChildren("WebUiData/MenuItem", "Name", view_name);
	itr = al_dst_itr(ls);
	if (al_count(itr) == 0) {
		error("view '" + (string)view_name + "' not found.");
		return null;
	} else {
	}
	if (al_count(itr) > 1) {
		error("number of view '" + (string)view_name + "' is more than 1.");
		return null;
	} else {
	}
	obj = al_next(itr);
	if (db_parts_name = session.getAttribute("db_parts_name")) {
	} else {
		error("db parts name is not setted.");
		return null;
	}
	ls = obj.getChildren("View/UiElem", "Name", db_parts_name);
	itr = al_dst_itr(ls);
	if (al_count(itr) == 0) {
		error("db parts '" + (string)db_parts_name + "' not found.");
		return null;
	} else {
	}
	if (al_count(itr) > 1) {
		error("number of db_parts '" + (string)db_parts_name + "' is more than 1.");
		return null;
	} else {
	}
	obj = al_next(itr);
	ls = obj.getChildren("Selectable/Children", (list)al_cons(null, null), "LineNumber", "", "0", "9999", "LineNumber", "integer", null);
	itr = al_dst_itr(ls);
	submit = al_dst_node(params, "submit");
	item = al_dst_node(params, "radio");
	if (item = al_dst_node(params, "radio")) {
		idx = al_search_str(item, 0, "-");
		idx2 = al_search_str(item, 0, ":");
	} else {
		idx = idx2 =  - 1;
	}
	if (idx >= 0) {
		item_number = (integer)al_tail_str(item, idx + 1);
	} else {
		item_number = 0;
	}
	if (idx2 >= 0) {
		item_number2 = (integer)al_tail_str(item, idx2 + 1);
	} else {
		item_number2 = 0;
	}
	create_path = al_dst_node(params, "Create-Path");
	create_value = al_dst_node(params, "Create-Value");
	if (submit == "create") {
		if (create_path && create_path != "" && create_value && create_value != "") {
			if (obj2 = findItem(itr, item_number)) {
				i = (integer)obj2.getField("LineNumber") + 1;
				if (al_next(itr)) {
					incLineNumber(itr);
				} else {
				}
			} else {
				error("appropriate radio not checked.");
				return null;
			}
			obj = obj.createChild("Selectable/Children");
			obj.putField("LineNumber", (string)i);
			obj.putField("ChildPath", create_path);
			obj.putField("Type", create_value);
		} else {
			error("Path or Type is null.");
			return null;
		}
		return invokeWebUiAdminSelectableHome(params, conn);
	} else {
	}
	if (submit == "condition create") {
		if (create_path && create_path != "" && create_value && create_value != "") {
			if (obj2 = findItem(itr, item_number)) {
				ls = obj2.getChildren("Condition");
				itr2 = al_dst_itr(ls);
				if (obj3 = findItem(itr2, item_number2)) {
					i = (integer)obj3.getField("LineNumber") + 1;
					if (al_next(itr2)) {
						incLineNumber(itr2);
					} else {
					}
				} else {
					ls = obj2.getChildren("Condition");
					itr2 = al_dst_itr(ls);
					i = 1;
					incLineNumber(itr2);
				}
			} else {
				error("appropriate radio not checked.");
				return null;
			}
			obj = obj2.createChild("Condition");
			obj.putField("LineNumber", (string)i);
			obj.putField("Path", create_path);
			obj.putField("Value", create_value);
		} else {
			error("Path or Type is null.");
			return null;
		}
		return invokeWebUiAdminSelectableHome(params, conn);
	} else {
	}
	if (submit == "update") {
		if (item == "Children-1") {
			msgType = al_dst_node(params, "msgType");
			msgVersion = al_dst_node(params, "msgVersion");
			dtd_filename = al_dst_node(params, "DTDfilename");
			type = al_dst_node(params, "Type-1");
			default = al_dst_node(params, "Default-1");
			if (obj2 = findItem(itr, item_number)) {
			} else {
				error("appropriate radio not checked.");
				return null;
			}
			obj2.putField("MsgType", msgType);
			obj2.putField("MsgVersion", msgVersion);
			obj2.putField("DTDfilename", dtd_filename);
			obj2.putField("Type", type);
			obj2.putField("Default", default);
		} else {
			if (obj2 = findItem(itr, item_number)) {
				ls = obj2.getChildren("Condition");
				itr2 = al_dst_itr(ls);
				if (obj3 = findItem(itr2, item_number2)) {
					path = al_dst_node(params, "Cond-Path-" + (string)item_number + ":" + (string)item_number2);
					value = al_dst_node(params, "Cond-Value-" + (string)item_number + ":" + (string)item_number2);
					obj2.putField("LineNumber", (string)(item_number2 + 1));
					obj3.putField("Path", path);
					obj3.putField("Value", value);
				} else {
					child_path = al_dst_node(params, "ChildPath-" + (string)item_number);
					type = al_dst_node(params, "Type-" + (string)item_number);
					default = al_dst_node(params, "Default-" + (string)item_number);
					obj2.putField("LineNumber", (string)(item_number + 1));
					obj2.putField("ChildPath", child_path);
					obj2.putField("Type", type);
					obj2.putField("Default", default);
				}
			} else {
				error("appropriate radio not checked.");
				return null;
			}
		}
		return invokeWebUiAdminSelectableHome(params, conn);
	} else {
	}
	if (submit == "delete") {
		if (item == "Children-1") {
			error("msgType must not be deleted.");
			return null;
		} else {
			if (obj2 = findItem(itr, item_number)) {
				ls = obj2.getChildren("Condition");
				itr2 = al_dst_itr(ls);
				if (obj3 = findItem(itr2, item_number2)) {
					itr = itr2;
					obj2 = obj3;
				} else {
				}
			} else {
				error("appropriate radio not checked.");
				return null;
			}
			obj2.delete();
			decLineNumber(itr);
		}
		return invokeWebUiAdminSelectableHome(params, conn);
	} else {
	}
	if (submit == "up") {
		if (item == "Children-1") {
			error("this item is top.");
			return null;
		} else {
			if (obj2 = findItem(itr, item_number)) {
				ls = obj2.getChildren("Condition", (list)al_cons(null, null), "LineNumber", "", "0", "9999", "LineNumber", "integer", null);
				itr2 = al_dst_itr(ls);
				if (obj3 = findItem(itr2, item_number2)) {
					itr = itr2;
					obj2 = obj3;
				} else {
					if (item_number == 2) {
						error("msgType must be top.");
						return null;
					} else {
					}
				}
				if (obj3 = al_prev(itr)) {
				} else {
					error("appropriate radio not checked.");
					return null;
				}
			} else {
				error("appropriate radio not checked.");
				return null;
			}
			i = (integer)obj2.getField("LineNumber");
			i2 = (integer)obj3.getField("LineNumber");
			obj2.putField("LineNumber", (string)i2);
			obj3.putField("LineNumber", (string)i);
		}
		return invokeWebUiAdminSelectableHome(params, conn);
	} else {
	}
	if (submit == "down") {
		if (item == "Children-1") {
			error("msgType must be top.");
			return null;
		} else {
			if (obj2 = findItem(itr, item_number)) {
				ls = obj2.getChildren("Condition", (list)al_cons(null, null), "LineNumber", "", "0", "9999", "LineNumber", "integer", null);
				itr2 = al_dst_itr(ls);
				if (obj3 = findItem(itr2, item_number2)) {
					itr = itr2;
					obj2 = obj3;
				} else {
				}
				if (obj3 = al_next(itr)) {
				} else {
					error("appropriate radio not checked.");
					return null;
				}
			} else {
				error("appropriate radio not checked.");
				return null;
			}
			i = (integer)obj2.getField("LineNumber");
			i2 = (integer)obj3.getField("LineNumber");
			obj2.putField("LineNumber", (string)i2);
			obj3.putField("LineNumber", (string)i);
		}
		return invokeWebUiAdminSelectableHome(params, conn);
	} else {
	}
	if (submit == "condition update") {
		range_path = al_dst_node(params, "RangePath");
		range_type = al_dst_node(params, "RangeType");
		from = al_dst_node(params, "From");
		to = al_dst_node(params, "To");
		orderby_path = al_dst_node(params, "OrderByPath");
		orderby_type = al_dst_node(params, "OrderByType");
		desc = al_dst_node(params, "Desc");
		count_from = al_dst_node(params, "CountFrom");
		count_max = al_dst_node(params, "CountMax");
		column_name = al_dst_node(params, "ColumnName");
		column_value = al_dst_node(params, "ColumnValue");
		column_name2 = al_dst_node(params, "ColumnName2");
		column_value2 = al_dst_node(params, "ColumnValue2");
		obj.putField("Selectable/Condition2/RangePath", range_path);
		obj.putField("Selectable/Condition2/RangeType", range_type);
		obj.putField("Selectable/Condition2/From", from);
		obj.putField("Selectable/Condition2/To", to);
		obj.putField("Selectable/Condition2/OrderByPath", orderby_path);
		obj.putField("Selectable/Condition2/OrderByType", orderby_type);
		obj.putField("Selectable/Condition2/Desc", desc);
		obj.putField("Selectable/Condition2/CountFrom", count_from);
		obj.putField("Selectable/Condition2/CountMax", count_max);
		obj.putField("Selectable/Condition2/ColumnName", column_name);
		obj.putField("Selectable/Condition2/ColumnValue", column_value);
		obj.putField("Selectable/Condition2/ColumnName", column_name);
		obj.putField("Selectable/Condition2/ColumnValue2", column_value2);
		return invokeWebUiAdminSelectableHome(params, conn);
	} else {
	}
	if (submit == "condition delete") {
		obj.removeField("Selectable/Condition2/RangePath");
		obj.removeField("Selectable/Condition2/RangeType");
		obj.removeField("Selectable/Condition2/From");
		obj.removeField("Selectable/Condition2/To");
		obj.removeField("Selectable/Condition2/OrderByPath");
		obj.removeField("Selectable/Condition2/OrderByType");
		obj.removeField("Selectable/Condition2/Desc");
		obj.removeField("Selectable/Condition2/CountFrom");
		obj.removeField("Selectable/Condition2/CountMax");
		obj.removeField("Selectable/Condition2/ColumnName");
		obj.removeField("Selectable/Condition2/ColumnValue");
		obj.removeField("Selectable/Condition2/ColumnName2");
		obj.removeField("Selectable/Condition2/ColumnValue2");
		return invokeWebUiAdminSelectableHome(params, conn);
	} else {
	}
	if (submit == "table item update") {
		if (item && item != "") {
			path = al_dst_node(params, item + "-Path");
			ls = obj.getChildren("Selectable/TableItem");
			itr = al_dst_itr(ls);
			if (obj2 = findItem(itr, "Path", path)) {
			} else {
				obj2 = obj.createChild("Selectable/TableItem");
			}
			line_number = al_dst_node(params, item + "-LineNumber");
			visible = al_dst_node(params, item + "-Visible");
			visible = (visible == "true" ? "true" : "false");
			editable = al_dst_node(params, item + "-Editable");
			editable = (editable == "true" ? "true" : "false");
			password = al_dst_node(params, item + "-Password");
			password = (password == "true" ? "true" : "false");
			if (visible == "true") {
				obj2.putField("Path", path);
				obj2.putField("LineNumber", line_number);
				obj2.putField("Editable", editable);
				obj2.putField("Password", password);
			} else {
				obj2.delete();
			}
		} else {
			error("radio button not checked.");
			return null;
		}
		return invokeWebUiAdminSelectableHome(params, conn);
	} else {
	}
	if (submit == "return") {
		session.setAttribute("db_parts_name", null);
		return invokeWebUiAdminViewHome(params, conn);
	} else {
	}
}
end_body
member
public: XmlDbObject findItem(list itr, integer line_number);
body
{
	max_line_number = 0;
	if (line_number == null) {
		return null;
	} else {
	}
	var XmlDbObject obj;
	var integer i;
	loop {
		if (obj = al_next(itr)) {
		} else {
			return null;
		}
		max_line_number = i = (integer)obj.getField("LineNumber");
		if (i == line_number) {
			return obj;
		} else {
		}
	}
}
end_body
member
public: XmlDbObject findItem(list itr, string path, string value);
body
{
	var XmlDbObject obj;
	var string val;
	loop {
		if (obj = al_next(itr)) {
		} else {
			return null;
		}
		val = obj.getField(path);
		if (val == value) {
			return obj;
		} else {
		}
	}
}
end_body
member
public: integer max_line_number;
member
public: void incLineNumber(list itr);
body
{
	var XmlDbObject obj;
	var integer i;
	loop {
		if (obj = al_next(itr)) {
		} else {
			break;
		}
		i = (integer)obj.getField("LineNumber");
		i = i + 1;
		obj.putField("LineNumber", (string)i);
	}
}
end_body
member
public: void decLineNumber(list itr);
body
{
	var XmlDbObject obj;
	var integer i;
	loop {
		if (obj = al_next(itr)) {
		} else {
			break;
		}
		i = (integer)obj.getField("LineNumber");
		i = i - 1;
		obj.putField("LineNumber", (string)i);
	}
}
end_body
member
public: list invokeAdminHome(list params, DbConnection conn);
body
{
	if (checkUserRole("admin")) {
	} else {
		return null;
	}
	res.out("<HTML><HEAD>\n<META http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n");
	res.out("<TITLE>Altair Server Administration</TITLE></HEAD>\n");
	res.out("<FRAMESET COLS=\"20%,*\" FRAMEBORDER=\"YES\">\n");
	res.out("<FRAME SRC=\"ebiz?action=AdminMenu\" SCROLLING=\"auto\" NAME=\"menu\"/>\n");
	res.out("<FRAME SRC=\"home.html\" SCROLLING=\"auto\" NAME=\"action\"/>\n");
	res.out("</FRAMESET>\n");
	res.out("</HTML>\n");
	return null;
}
end_body
member
public: list invokeAdminMenu(list params, DbConnection conn);
body
{
	if (checkUserRole("admin")) {
	} else {
		return null;
	}
	return menu(params, conn);
}
end_body
member
public: list menu(list params, DbConnection conn);
body
{
	res.out("<HTML><HEAD>\n<META http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n");
	res.out("<BASE TARGET=\"action\"></HEAD><BODY>\n");
	{
		var XmlDbAccessor acc;
		var XmlDbObject obj;
		var list ls, itr, in_ul;
		acc = new XmlDbAccessor;
		acc.create("WebUiData", "", conn);
		acc.setDTDfilename("WebUiData.dtd");
		ls = acc.get("WebUiData/Target", admin_target);
		itr = al_dst_itr(ls);
		if (al_count(itr) == 0) {
			error("webuidata for target '" + admin_target + "' not found.");
			return null;
		} else {
		}
		if (al_count(itr) > 1) {
			error("number of webuidata for target '" + admin_target + "' is more than 1.");
			return null;
		} else {
		}
		obj = al_next(itr);
		ls = obj.getChildren("WebUiData/MenuItem", (list)al_cons(null, null), "LineNumber", "", "0", "9999", "LineNumber", "integer", null);
		itr = al_dst_itr(ls);
		loop {
			if (obj = al_next(itr)) {
			} else {
				break;
			}
			var string name, kind, text;
			name = obj.getField("Name");
			kind = obj.getField("Kind");
			text = obj.getField("Text");
			if (kind == "Title") {
				if (in_ul) {
					res.out("</UL>\n");
					in_ul = null;
				} else {
				}
				genTitle(text);
			} else {
			}
			if (kind == "View" || kind == "RefreshView") {
				if (in_ul == null) {
					res.out("<UL>\n");
					in_ul = 1;
				} else {
				}
				res.out("<LI>");
				genLink("ebiz?action=" + (string)name, text);
			} else {
			}
		}
		if (in_ul) {
			res.out("</UL>\n");
			in_ul = null;
		} else {
		}
	}
	res.out("<A HREF=\"ebiz?action=Logout\" TARGET=\"_top\">Logout</A>\n");
	res.out("</BODY></HTML>\n");
	return null;
}
end_body
member
public: string adminMenuTarget(string target, string user_name);
body
{
	if (user_name) {
	} else {
		return null;
	}
	var integer idx;
	idx = al_search_str(user_name, 0, ":");
	if (idx >= 0) {
		user_name = al_tail_str(user_name, idx + 1);
	} else {
	}
	if (user_name != "admin") {
		return target;
	} else {
	}
	var string amt;
	var integer n, i, ch;
	amt = al_copy("");
	n = al_strlen(target);
	i = 0;
	loop {
		if (i < n) {
		} else {
			break;
		}
		ch = al_get_char(target, i);
		if (i == 0) {
			al_append_str(amt, ch);
		} else {
			if ('A' <= ch && ch <= 'Z') {
				return amt;
			} else {
				al_append_str(amt, ch);
			}
		}
		i = i + 1;
	}
	return amt;
}
end_body
member
public: list invokeView(list params, DbConnection conn);
body
{
	if (checkUserRole(conn)) {
	} else {
		return null;
	}
	var XmlDbAccessor acc, data_acc;
	var XmlDbObject obj, obj2, obj3, data_obj;
	var list ls, itr, upload, itr2, itr3, cond, checked, values, data_ls, not_condition2, not_last;
	var string name, kind, text;
	var string path, value, child_path;
	var string msgType, msgVersion, dtd_filename, single_multi, default;
	var string range_path, range_type, from, to;
	var string order_path, order_type;
	var list desc;
	var integer count_from, count_max;
	var string column_name, column_value;
	var string column_name2, column_value2;
	var integer children_number;
	var list visibles, editables, passwords, visible, editable, password;
	var list edit_mode, checks, radio;
	acc = new XmlDbAccessor;
	acc.create("WebUiData", "", conn);
	acc.setDTDfilename("WebUiData.dtd");
	ls = acc.get("WebUiData/Target", (string)admin_target);
	itr = al_dst_itr(ls);
	if (al_count(itr) == 0) {
		error("webuidata for target '" + (string)admin_target + "' not found.");
		return null;
	} else {
	}
	if (al_count(itr) > 1) {
		error("number of webuidata for target '" + (string)admin_target + "' is more than 1.");
		return null;
	} else {
	}
	obj = al_next(itr);
	ls = obj.getChildren("WebUiData/MenuItem", (list)al_cons(null, null), "LineNumber", "", "0", "9999", "LineNumber", "integer", null);
	itr = al_dst_itr(ls);
	loop {
		if (obj = al_next(itr)) {
		} else {
			break;
		}
		kind = obj.getField("Kind");
		name = obj.getField("Name");
		if ((kind == "View" || kind == "RefreshView") && name == action) {
			break;
		} else {
		}
	}
	if (kind == "View") {
		genPageBegin(action);
	} else {
		genRefreshPageBegin(action, 60);
	}
	genFormBegin(action, upload);
	genTitle(action);
	if (obj) {
		ls = obj.getChildren("View/UiElem", (list)al_cons(null, null), "LineNumber", "", "0", "9999", "LineNumber", "integer", null);
	} else {
		ls = al_cons(null, null);
	}
	itr = al_dst_itr(ls);
	loop {
		if (obj = al_next(itr)) {
		} else {
			break;
		}
		kind = obj.getField("Kind");
		if (kind == "Upload") {
			upload = 1;
		} else {
		}
	}
	itr = al_dst_itr(ls);
	loop {
		if (obj = al_next(itr)) {
		} else {
			break;
		}
		name = obj.getField("Name");
		kind = obj.getField("Kind");
		text = obj.getField("Text");
		if (kind == "Title") {
			genTitle(text);
		} else {
		}
		if (kind == "Text") {
			genText(text);
		} else {
		}
		if (kind == "Link") {
			genLink(name, text);
		} else {
		}
		if (kind == "BR") {
			genBR();
		} else {
		}
		if (kind == "Button") {
			genButton(name, text);
		} else {
		}
		if (kind == "Check") {
			genCheck(name, text, null);
		} else {
		}
		if (kind == "Radio") {
			genRadio(name, text, text, null);
		} else {
		}
		if (kind == "TextField") {
			genTextField(name, 20, getValue(text));
		} else {
		}
		if (kind == "Password") {
			genPassword(name, 20, getValue(text));
		} else {
		}
		if (kind == "TextArea") {
			genTextArea(name, 20, 72, getValue(text));
		} else {
		}
		if (kind == "Upload") {
			genUpload(name);
		} else {
		}
		if (kind == "Select" || kind == "Table1" || kind == "Table2") {
			not_condition2 = 1;
			loop {
				if (range_path = obj.getField("Selectable/Condition2/RangePath")) {
					range_path = getValue(range_path);
				} else {
					break;
				}
				if (range_type = obj.getField("Selectable/Condition2/RangeType")) {
					range_type = getValue(range_type);
				} else {
					break;
				}
				if (from = obj.getField("Selectable/Condition2/From")) {
					from = getValue(from);
				} else {
					break;
				}
				if (to = obj.getField("Selectable/Condition2/To")) {
					to = getValue(to);
				} else {
					break;
				}
				if (order_path = obj.getField("Selectable/Condition2/OrderByPath")) {
					order_path = getValue(order_path);
				} else {
					break;
				}
				if (order_type = obj.getField("Selectable/Condition2/OrderByType")) {
					order_type = getValue(order_type);
				} else {
					break;
				}
				if (desc = obj.getField("Selectable/Condition2/Desc")) {
					desc = (getValue((string)desc) == "true");
				} else {
					break;
				}
				if (column_name = obj.getField("Selectable/Condition2/ColumnName")) {
					column_name = getValue(column_name);
				} else {
					break;
				}
				if (column_value = obj.getField("Selectable/Condition2/ColumnValue")) {
					column_value = getValue(column_value);
				} else {
					break;
				}
				if (column_name2 = obj.getField("Selectable/Condition2/ColumnName2")) {
					column_name2 = getValue(column_name2);
				} else {
					break;
				}
				if (column_value2 = obj.getField("Selectable/Condition2/ColumnValue2")) {
					column_value2 = getValue(column_value2);
				} else {
					break;
				}
				not_condition2 = null;
				break;
			}
			if (count_from = obj.getField("Selectable/Condition2/CountFrom")) {
				if (count_from = getValue((string)count_from) && count_from != "") {
					count_from = (integer)count_from;
				} else {
					count_from = 1;
				}
			} else {
				count_from = 1;
			}
			if (count_max = obj.getField("Selectable/Condition2/CountMax")) {
				if (count_max = getValue((string)count_max) && count_max != "") {
					count_max = (integer)count_max;
				} else {
					count_max = 1000;
				}
			} else {
				count_max = 1000;
			}
			children_number = 1;
			ls = obj.getChildren("Selectable/Children", (list)al_cons(null, null), "LineNumber", "", "0", "9999", "LineNumber", "integer", null);
			itr2 = al_dst_itr(ls);
			if (obj2 = al_next(itr2)) {
			} else {
				error("First record containig MsgType not found.");
				return null;
			}
			msgType = obj2.getField("MsgType");
			msgVersion = obj2.getField("MsgVersion");
			dtd_filename = obj2.getField("DTDfilename");
			single_multi = obj2.getField("Type");
			default = getValue(obj2.getField("Default"));
			if (msgType && msgVersion && dtd_filename && single_multi) {
			} else {
				error("MsgType, MsgVersion, DTDfilename or Type is empty.");
				return null;
			}
			if (msgVersion = getValue(msgVersion)) {
			} else {
				error("can't get MsgType value.");
				return null;
			}
			if (msgVersion == "dbTable") {
				data_acc = new XmlDbTableAccessor;
			} else {
				data_acc = new XmlDbAccessor;
			}
			data_acc.create(msgType, msgVersion, conn);
			data_acc.setDTDfilename(dtd_filename);
			ls = obj2.getChildren("Condition");
			itr3 = al_dst_itr(ls);
			child_path = null;
			data_obj = null;
			data_ls = al_cons(null, null);
			cond = al_cons(null, null);
			loop {
				if (obj3 = al_next(itr3)) {
				} else {
					break;
				}
				path = obj3.getField("Path");
				value = obj3.getField("Value");
				value = getValue(value);
				if (path == msgType + "/Target" && value == "system") {
					continue;
				} else {
				}
				if (path && value) {
					al_create_arc(cond, value, path);
				} else {
				}
			}
			not_last = (al_next(itr2) != null);
			al_prev(itr2);
			if (single_multi == "single") {
				data_obj = getSingle(data_acc, cond);
			} else {
				if (single_multi == "multiple") {
					data_acc.count_max = count_max;
					if (not_last || not_condition2) {
						data_ls = getMultiple(data_acc, cond);
					} else {
						if (column_name && column_value && column_value != "") {
							al_create_arc(cond, column_value, column_name);
						} else {
						}
						if (column_name2 && column_value2 && column_value2 != "") {
							al_create_arc(cond, column_value2, column_name2);
						} else {
						}
						if (range_path && range_type && from && to && order_path && order_type) {
							data_ls = getMultiple(data_acc, cond, range_path, range_type, from, to, order_path, order_type, desc);
						} else {
							data_ls = getMultiple(data_acc, cond);
						}
					}
				} else {
					error("Type must be single or multiple. (name = " + (string)name + ")");
					return null;
				}
			}
			loop {
				if (obj2 = al_next(itr2)) {
				} else {
					break;
				}
				if (single_multi != "single") {
					error("nest parent must be single. (name = " + (string)name + ")");
					return null;
				} else {
				}
				child_path = obj2.getField("ChildPath");
				single_multi = obj2.getField("Type");
				default = getValue(obj2.getField("Default"));
				if (child_path == null) {
					error("ChildPath is null. (name = " + (string)name + ")");
					return null;
				} else {
				}
				ls = obj2.getChildren("Condition");
				itr3 = al_dst_itr(ls);
				cond = al_cons(null, null);
				loop {
					if (obj3 = al_next(itr3)) {
					} else {
						break;
					}
					path = obj3.getField("Path");
					value = obj3.getField("Value");
					if (path && value = getValue(value)) {
						al_create_arc(cond, value, path);
					} else {
					}
				}
				not_last = (al_next(itr2) != null);
				al_prev(itr2);
				if (single_multi == "single") {
					data_obj = getSingle(data_obj, child_path, cond);
				} else {
					if (single_multi == "multiple") {
						if (not_last || not_condition2) {
							data_ls = getMultiple(data_obj, child_path, cond);
						} else {
							if (column_name && column_value && column_value != "") {
								al_create_arc(cond, column_value, column_name);
							} else {
							}
							if (column_name2 && column_value2 && column_value2 != "") {
								al_create_arc(cond, column_value2, column_name2);
							} else {
							}
							if (range_path && range_type && from && to && order_path && order_type) {
								data_ls = getMultiple(data_obj, child_path, cond, range_path, range_type, from, to, order_path, order_type, desc);
							} else {
								data_ls = getMultiple(data_obj, child_path, cond);
							}
						}
					} else {
						error("Type must be single or multiple. (name = " + (string)name + ")");
						return null;
					}
				}
				children_number = children_number + 1;
			}
			if (kind == "Select") {
				if (single_multi != "multiple") {
					error("Type of Select must be multiple (name = " + (string)name + ")");
					return null;
				} else {
				}
				values = al_cons(null, null);
				itr2 = al_dst_itr(data_ls);
				loop {
					if (data_obj = al_next(itr2)) {
					} else {
						break;
					}
					ls = obj.getChildren("Selectable/TableItem", (list)al_cons(null, null), "LineNumber", "", "0", "9999", "LineNumber", "integer", null);
					itr3 = al_dst_itr(ls);
					value = "";
					var string val;
					loop {
						if (obj2 = al_next(itr3)) {
						} else {
							break;
						}
						if (path = obj2.getField("Path")) {
						} else {
							continue;
						}
						if (val = data_obj.getField(path)) {
						} else {
							val = "";
						}
						if (value == "") {
							value = val;
						} else {
							value = value + ": " + val;
						}
					}
					al_create_arc(values, value, value == default);
				}
				values = al_misc("sort", values, al_list2(0, 0));
				genSelect(name, values);
			} else {
			}
			if (kind == "Table1") {
				if (single_multi != "single") {
					error("Type of Table1 must be single (name = " + (string)name + ")");
					return null;
				} else {
				}
				edit_mode = getValue(text);
				visibles = al_cons(null, null);
				editables = al_cons(null, null);
				passwords = al_cons(null, null);
				ls = obj.getChildren("Selectable/TableItem", (list)al_cons(null, null), "LineNumber", "", "0", "9999", "LineNumber", "integer", null);
				itr3 = al_dst_itr(ls);
				loop {
					if (obj2 = al_next(itr3)) {
					} else {
						break;
					}
					if (path = obj2.getField("Path")) {
					} else {
						path = "";
					}
					if (edit_mode && editable = (integer)obj2.getField("Editable") && editable >= edit_mode) {
						editable = 1;
					} else {
						editable = null;
					}
					if (password = obj2.getField("Password") && password == "true") {
						password = 1;
					} else {
						password = null;
					}
					al_create_arc(visibles, al_copy(1), path);
					al_create_arc(editables, editable, path);
					al_create_arc(passwords, password, path);
				}
				if (edit_mode) {
					genTable1(data_obj, visibles, editables, passwords, null);
				} else {
					genTable1(data_obj, visibles, null, passwords, null);
				}
			} else {
			}
			if (kind == "Table2") {
				if (single_multi != "multiple") {
					error("Type of Table2 must be multiple (name = " + (string)name + ")");
					return null;
				} else {
				}
				radio = getValue(text);
				visibles = al_cons(null, null);
				checks = al_cons(null, null);
				ls = obj.getChildren("Selectable/TableItem", (list)al_cons(null, null), "LineNumber", "", "0", "9999", "LineNumber", "integer", null);
				itr3 = al_dst_itr(ls);
				loop {
					if (obj2 = al_next(itr3)) {
					} else {
						break;
					}
					if (path = obj2.getField("Path")) {
					} else {
						path = "";
					}
					al_create_arc(visibles, al_copy(1), path);
				}
				if (radio && radio != "") {
					genTable2(data_ls, visibles, checks, (list)(radio == "check" ? null : radio), count_from, count_max, null);
				} else {
					genTable2(data_ls, visibles, null, null, count_from, count_max, null);
				}
			} else {
			}
		} else {
		}
	}
	genFormEnd();
	genPageEnd();
	return null;
}
end_body
member
public: string getValue(string name);
body
{
	if (name == null || name == "*") {
		return null;
	} else {
	}
	var integer ch;
	if (al_strlen(name) == 0) {
		return name;
	} else {
	}
	ch = al_get_char(name, 0);
	if (ch == '@') {
		name = al_tail_str(name, 1);
		return al_dst_node(this, name);
	} else {
	}
	if (ch == '#') {
		name = al_tail_str(name, 1);
		return session.getAttribute(name);
	} else {
	}
	return name;
}
end_body
member
public: XmlDbObject getSingle(XmlDbAccessor acc, list cond);
body
{
	var list ls, itr;
	ls = acc.get(cond);
	itr = al_dst_itr(ls);
	if (al_count(itr) > 1) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "webui: record of " + acc.msgType + "-" + acc.msgVersion + " is more than 1.";
		throw ex;
	} else {
	}
	return al_next(itr);
}
end_body
member
public: XmlDbObject getSingle(XmlDbObject obj, string path, list cond);
body
{
	if (obj) {
	} else {
		return null;
	}
	var list ls, itr;
	ls = obj.getChildren(path, cond);
	itr = al_dst_itr(ls);
	if (al_count(itr) > 1) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "webui: record of " + obj.msgType + "-" + obj.msgVersion + " is more than 1.";
		throw ex;
	} else {
	}
	return al_next(itr);
}
end_body
member
public: list getMultiple(XmlDbAccessor acc, list cond);
body
{
	return acc.get(cond);
}
end_body
member
public: list getMultiple(XmlDbObject obj, string path, list cond);
body
{
	if (obj) {
	} else {
		return al_cons(null, null);
	}
	return obj.getChildren(path, cond);
}
end_body
member
public: list getMultiple(XmlDbAccessor acc, list cond, string range_path, string range_type, string from, string to, string order_path, string order_type, list desc);
body
{
	var list ls, itr;
	var XmlDbObject obj2;
	ls = acc.get(cond, range_path, range_type, from, to, order_path, order_type, desc);
	itr = al_dst_itr(ls);
	if (obj2 = al_prev(itr)) {
		session.setAttribute("range_end", obj2.getField(range_path));
	} else {
	}
	return ls;
}
end_body
member
public: list getMultiple(XmlDbObject obj, string path, list cond, string range_path, string range_type, string from, string to, string order_path, string order_type, list desc);
body
{
	if (obj) {
	} else {
		return al_cons(null, null);
	}
	var list ls, itr;
	var XmlDbObject obj2;
	var string value1, value2;
	ls = obj.getChildren(path, cond, range_path, range_type, from, to, order_path, order_type, desc);
	if (obj2 = al_prev(itr)) {
		session.setAttribute("range_end", obj2.getField(range_path));
	} else {
	}
	return ls;
}
end_body
member
public: list checkPath(string msgType, string msgVersion, string dtd_filename, string path, DbConnection conn);
body
{
	var XmlDbAccessor acc;
	var XmlDbObject obj;
	acc = new XmlDbAccessor;
	acc.create(msgType, msgVersion, conn);
	acc.setDTDfilename(dtd_filename);
	obj = acc.getMetaInfo();
	if (obj = acc.getMetaInfo() && al_dst_node(obj.xpath_list, path)) {
		return 1;
	} else {
		error("path '" + (string)path + "' not fonund in '" + (string)msgType + "'");
		return null;
	}
}
end_body
member
public: list checkFromTo(string from, string to);
body
{
	var list t;
	t = al_list4("String", 19, 19, "9999X99X99X99X99X99");
	if (al_xml("type_check", from, t, null)) {
		error("From time format must be 'yyy:MM:dd-HH:mm:ss'");
		return null;
	} else {
	}
	if (al_xml("type_check", to, t, null)) {
		error("To time format must be 'yyy:MM:dd-HH:mm:ss'");
		return null;
	} else {
	}
	return 1;
}
end_body
member
public: list invokeSystemLog(list params, DbConnection conn);
body
{
	if (checkUserRole(conn)) {
	} else {
		return null;
	}
	var string submit;
	var string range_path, from, to;
	var string order_path, count_max, desc;
	var string column_name, column_value;
	var string column_name2, column_value2;
	submit = al_dst_node(params, "submit");
	range_path = al_dst_node(params, "RangePathTextField");
	from = al_dst_node(params, "FromTextField");
	to = al_dst_node(params, "ToTextField");
	order_path = al_dst_node(params, "OrderByPathTextField");
	count_max = al_dst_node(params, "CountMaxTextField");
	desc = al_dst_node(params, "DescTextField");
	column_name = al_dst_node(params, "ColumnNameTextField");
	column_value = al_dst_node(params, "ColumnValueTextField");
	column_name2 = al_dst_node(params, "ColumnNameTextField2");
	column_value2 = al_dst_node(params, "ColumnValueTextField2");
	if (session.getAttribute("system_log_range_path")) {
	} else {
		session.setAttribute("system_log_range_path", "SystemLog/Time");
	}
	if (session.getAttribute("system_log_from")) {
	} else {
		session.setAttribute("system_log_from", "0000/00/00-00:00:00");
	}
	if (session.getAttribute("system_log_to")) {
	} else {
		session.setAttribute("system_log_to", "9999/99/99-99:99:99");
	}
	if (session.getAttribute("system_log_order_path")) {
	} else {
		session.setAttribute("system_log_order_path", "SystemLog/Time");
	}
	if (session.getAttribute("system_log_count_max")) {
	} else {
		session.setAttribute("system_log_count_max", "100");
	}
	if (session.getAttribute("system_log_desc")) {
	} else {
		session.setAttribute("system_log_desc", "true");
	}
	if (session.getAttribute("system_log_column_name")) {
	} else {
		session.setAttribute("system_log_column_name", "SystemLog/LogLevel");
	}
	if (session.getAttribute("system_log_column_value")) {
	} else {
		session.setAttribute("system_log_column_value", "");
	}
	if (session.getAttribute("system_log_column_name2")) {
	} else {
		session.setAttribute("system_log_column_name2", "SystemLog/Message");
	}
	if (session.getAttribute("system_log_column_value2")) {
	} else {
		session.setAttribute("system_log_column_value2", "");
	}
	if (submit == "Next") {
		var string str;
		if (str = session.getAttribute("range_end")) {
			if (desc == "true") {
				from = "0000/00/00-00:00:00";
				to = str;
			} else {
				from = str;
				to = "9999/99/99-99:99:99";
			}
		} else {
		}
	} else {
	}
	if (submit == "ShowLog" || submit == "Next") {
		if (checkFromTo(from, to)) {
		} else {
			return null;
		}
		if (checkPath("SystemLog", "dbTable", "SystemLog.dtd", range_path, conn)) {
		} else {
			return null;
		}
		if (checkPath("SystemLog", "dbTable", "SystemLog.dtd", order_path, conn)) {
		} else {
			return null;
		}
		if (checkPath("SystemLog", "dbTable", "SystemLog.dtd", column_name, conn)) {
		} else {
			return null;
		}
		if (checkPath("SystemLog", "dbTable", "SystemLog.dtd", column_name2, conn)) {
		} else {
			return null;
		}
		session.setAttribute("system_log_range_path", range_path);
		session.setAttribute("system_log_from", from);
		session.setAttribute("system_log_to", to);
		session.setAttribute("system_log_order_path", order_path);
		session.setAttribute("system_log_count_max", count_max);
		session.setAttribute("system_log_desc", desc);
		session.setAttribute("system_log_column_name", column_name);
		session.setAttribute("system_log_column_value", column_value);
		session.setAttribute("system_log_column_name2", column_name2);
		session.setAttribute("system_log_column_value2", column_value2);
	} else {
	}
	return invokeView(params, conn);
}
end_body
member
public: list invokeAccessLog(list params, DbConnection conn);
body
{
	if (checkUserRole(conn)) {
	} else {
		return null;
	}
	var string submit;
	var string range_path, from, to;
	var string order_path, count_max, desc;
	var string column_name, column_value;
	var string column_name2, column_value2;
	submit = al_dst_node(params, "submit");
	range_path = al_dst_node(params, "RangePathTextField");
	from = al_dst_node(params, "FromTextField");
	to = al_dst_node(params, "ToTextField");
	order_path = al_dst_node(params, "OrderByPathTextField");
	count_max = al_dst_node(params, "CountMaxTextField");
	desc = al_dst_node(params, "DescTextField");
	column_name = al_dst_node(params, "ColumnNameTextField");
	column_value = al_dst_node(params, "ColumnValueTextField");
	column_name2 = al_dst_node(params, "ColumnNameTextField2");
	column_value2 = al_dst_node(params, "ColumnValueTextField2");
	if (session.getAttribute("access_log_range_path")) {
	} else {
		session.setAttribute("access_log_range_path", "AccessLog/Time");
	}
	if (session.getAttribute("access_log_from")) {
	} else {
		session.setAttribute("access_log_from", "0000/00/00-00:00:00");
	}
	if (session.getAttribute("access_log_to")) {
	} else {
		session.setAttribute("access_log_to", "9999/99/99-99:99:99");
	}
	if (session.getAttribute("access_log_order_path")) {
	} else {
		session.setAttribute("access_log_order_path", "AccessLog/Time");
	}
	if (session.getAttribute("access_log_count_max")) {
	} else {
		session.setAttribute("access_log_count_max", "100");
	}
	if (session.getAttribute("access_log_desc")) {
	} else {
		session.setAttribute("access_log_desc", "true");
	}
	if (session.getAttribute("access_log_column_name")) {
	} else {
		session.setAttribute("access_log_column_name", "AccessLog/Path");
	}
	if (session.getAttribute("access_log_column_value")) {
	} else {
		session.setAttribute("access_log_column_value", "");
	}
	if (session.getAttribute("access_log_column_name2")) {
	} else {
		session.setAttribute("access_log_column_name2", "AccessLog/ResponseCode");
	}
	if (session.getAttribute("access_log_column_value2")) {
	} else {
		session.setAttribute("access_log_column_value2", "");
	}
	if (submit == "Next") {
		var string str;
		if (str = session.getAttribute("range_end")) {
			if (desc == "true") {
				from = "0000/00/00-00:00:00";
				to = str;
			} else {
				from = str;
				to = "9999/99/99-99:99:99";
			}
		} else {
		}
	} else {
	}
	if (submit == "ShowLog" || submit == "Next") {
		if (checkFromTo(from, to)) {
		} else {
			return null;
		}
		if (checkPath("AccessLog", "dbTable", "AccessLog.dtd", range_path, conn)) {
		} else {
			return null;
		}
		if (checkPath("AccessLog", "dbTable", "AccessLog.dtd", order_path, conn)) {
		} else {
			return null;
		}
		if (checkPath("AccessLog", "dbTable", "AccessLog.dtd", column_name, conn)) {
		} else {
			return null;
		}
		if (checkPath("AccessLog", "dbTable", "AccessLog.dtd", column_name2, conn)) {
		} else {
			return null;
		}
		session.setAttribute("access_log_range_path", range_path);
		session.setAttribute("access_log_from", from);
		session.setAttribute("access_log_to", to);
		session.setAttribute("access_log_order_path", order_path);
		session.setAttribute("access_log_count_max", count_max);
		session.setAttribute("access_log_desc", desc);
		session.setAttribute("access_log_column_name", column_name);
		session.setAttribute("access_log_column_value", column_value);
		session.setAttribute("access_log_column_name2", column_name2);
		session.setAttribute("access_log_column_value2", column_value2);
	} else {
	}
	return invokeView(params, conn);
}
end_body
member
public: list invokeUser(list params, DbConnection conn);
body
{
	if (checkUserRole(conn)) {
	} else {
		return null;
	}
	var string submit, user, new_user, new_pass, add_role, remove_role;
	submit = al_dst_node(params, "submit");
	user = fromUTF8((list)al_dst_node(params, "UserSelect"));
	new_user = fromUTF8((list)al_dst_node(params, "User/UserId"));
	new_pass = al_dst_node(params, "User/Password");
	add_role = fromUTF8((list)al_dst_node(params, "AddRoleName"));
	remove_role = fromUTF8((list)al_dst_node(params, "RemoveRoleName"));
	var XmlDbAccessor acc;
	var XmlDbObject obj, obj2;
	var list ls, itr;
	acc = new XmlDbAccessor;
	acc.create("User", "", conn);
	acc.setDTDfilename("User.dtd");
	if (submit == "Show") {
		session.setAttribute("target_user_id", user);
		session.setAttribute("edit_mode", null);
	} else {
	}
	if (submit == "Create") {
		session.setAttribute("target_user_id", "#");
		session.setAttribute("edit_mode", 1);
	} else {
	}
	if (submit == "Edit") {
		if (user == null || user == "") {
			error("user id is empty.");
			return null;
		} else {
		}
		session.setAttribute("target_user_id", user);
		session.setAttribute("edit_mode", 2);
	} else {
	}
	if (submit == "Delete") {
		// delete user
		if (obj = getUser(acc, user, conn)) {
			obj.delete();
		} else {
			error("user '" + (string)user + "' not found.");
			return null;
		}
		session.setAttribute("target_user_id", "#");
		session.setAttribute("edit_mode", null);
	} else {
	}
	if (submit == "submit for Create/Edit") {
		var string target_user_id;
		if (target_user_id = session.getAttribute("target_user_id")) {
		} else {
			error("target user id is not setted.");
			return null;
		}
		if (target_user_id == "#") {
			// create user
			if (new_user == null || new_user == "") {
				error("new user id is empty.");
				return null;
			} else {
			}
			if (new_user == "#") {
				error("'#' can't be used as user id.");
				return null;
			} else {
			}
			if (new_pass == null || new_pass == "") {
				error("password is empty.");
				return null;
			} else {
			}
			if (obj = getUser(acc, new_user, conn)) {
				error("user '" + new_user + "' already exists.");
				return null;
			} else {
				obj = acc.create();
				obj.putField("User/Target", target);
				obj.putField("User/Id", target + ":" + new_user);
				obj.putField("User/UserId", new_user);
				obj.putField("User/Password", new_pass);
				session.setAttribute("target_user_id", target + ":" + new_user);
				session.setAttribute("edit_mode", null);
			}
		} else {
			// change password
			if (new_pass == null || new_pass == "") {
				error("password is empty.");
				return null;
			} else {
			}
			if (obj = getUser(acc, target_user_id, conn)) {
				obj.putField("User/Password", new_pass);
				session.setAttribute("target_user_id", target_user_id);
				session.setAttribute("edit_mode", null);
			} else {
				error("user '" + target_user_id + "' not found.");
				return null;
			}
		}
	} else {
	}
	if (submit == "AddRole") {
		if (user == null || user == "") {
			error("user id is empty.");
			return null;
		} else {
		}
		if (obj = getUser(acc, user, conn)) {
			if (add_role == null || add_role == "") {
				error("add role name is empty.");
				return null;
			} else {
			}
			ls = obj.getChildren("User/RoleName", "", (string)add_role);
			itr = al_dst_itr(ls);
			if (obj2 = al_next(itr)) {
				error("already has role '" + add_role + "'.");
				return null;
			} else {
			}
			obj2 = obj.createChild("User/RoleName");
			obj2.putField("", add_role);
			session.setAttribute("target_user_id", user);
			session.setAttribute("edit_mode", null);
		} else {
			error("user '" + (string)user + "' not found.");
			return null;
		}
	} else {
	}
	if (submit == "RemoveRole") {
		if (user == null || user == "") {
			error("user id is empty.");
			return null;
		} else {
		}
		if (obj = getUser(acc, user, conn)) {
			if (remove_role == null || remove_role == "") {
				error("remove role name is empty.");
				return null;
			} else {
			}
			ls = obj.getChildren("User/RoleName", "", (string)remove_role);
			itr = al_dst_itr(ls);
			if (obj2 = al_next(itr)) {
				obj2.delete();
				session.setAttribute("target_user_id", user);
				session.setAttribute("edit_mode", null);
			} else {
				error("does not have role '" + remove_role + "'.");
				return null;
			}
		} else {
			error("user '" + (string)user + "' not found.");
			return null;
		}
	} else {
	}
	if (session.getAttribute("target_user_id")) {
	} else {
		session.setAttribute("target_user_id", "#");
	}
	return invokeView(params, conn);
}
end_body
member
public: XmlDbObject getUser(XmlDbAccessor acc, string user, DbConnection conn);
body
{
	var list ls, itr;
	ls = acc.get("User/Id", user);
	itr = al_dst_itr(ls);
	return al_next(itr);
}
end_body
member
public: list invokeRestart(list params, DbConnection conn);
body
{
	if (checkUserRole(conn)) {
	} else {
		return null;
	}
	var string submit;
	submit = al_dst_node(params, "submit");
	if (submit == "Restart") {
		res.system_command = "restart";
	} else {
	}
	return invokeView(params, conn);
}
end_body
member
public: list invokeShutdown(list params, DbConnection conn);
body
{
	if (checkUserRole(conn)) {
	} else {
		return null;
	}
	var string submit;
	submit = al_dst_node(params, "submit");
	if (submit == "Shutdown") {
		res.system_command = "shutdown";
	} else {
	}
	return invokeView(params, conn);
}
end_body
member
public: list invokeCacheClear(list params, DbConnection conn);
body
{
	if (checkUserRole(conn)) {
	} else {
		return null;
	}
	var string submit, op;
	submit = al_dst_node(params, "submit");
	op = al_dst_node(params, "op");
	if (submit == "Clear") {
		if (op == null) {
			error("please check kind");
			return null;
		} else {
		}
		if (op == "DTD") {
			XmlUtility::dtd_cache = null;
		} else {
		}
		if (op == "XSL") {
			XmlUtility::xsl_cache = null;
		} else {
		}
		if (op == "hostaddr") {
			ProxyClientConnection::hostaddr_cache = null;
		} else {
		}
	} else {
	}
	return invokeView(params, conn);
}
end_body
member
public: list invokeGC(list params, DbConnection conn);
body
{
	if (checkUserRole(conn)) {
	} else {
		return null;
	}
	var string submit;
	submit = al_dst_node(params, "submit");
	if (submit == "doGC") {
		var list r;
		var integer recycled, free, used;
		r = al_gc(null);
		recycled = r.head;
		free = r.tail.head;
		used = r.tail.tail.head;
		genPageBegin("GC Result");
		genText("recycled = " + (string)recycled);
		genBR();
		genText("free = " + (string)free);
		genBR();
		genText("used = " + (string)used);
		genBR();
		genPageEnd();
		return null;
	} else {
	}
	return invokeView(params, conn);
}
end_body
member
public: list invokeShell(list params, DbConnection conn);
body
{
	if (checkUserRole(conn)) {
	} else {
		return null;
	}
	var string submit, pwd, cmd, output, filename, content;
	submit = al_dst_node(params, "submit");
	if (pwd = session.getAttribute("shell_pwd")) {
	} else {
		pwd = al_file_manip("get_dir", null, null);
		session.setAttribute("shell_pwd", pwd);
	}
	if (submit == "cd") {
		pwd = al_dst_node(params, "pwd");
		if (pwd != "") {
			session.setAttribute("shell_pwd", pwd);
		} else {
		}
		session.setAttribute("shell_output", "");
	} else {
	}
	if (submit == "exec") {
		cmd = al_dst_node(params, "cmd");
		output = al_copy("");
		if (cmd != "") {
			session.setAttribute("shell_cmd", cmd);
			var list pipe;
			var integer pid;
			pipe = al_file_open("", "pipe");
			if (pid = al_exec(cmd, pwd, null, pipe)) {
				var string line;
				loop {
					if (line = al_file_read(pipe, "line")) {
						if (line == 0x0000000080000000) {
							al_next_process();
							continue;
						} else {
						}
					} else {
						break;
					}
					al_append_str(output, line);
					al_append_str(output, "\n");
				}
			} else {
				output = "fail to execute '" + cmd + "'";
			}
		} else {
		}
		session.setAttribute("shell_output", output);
	} else {
	}
	if (submit == "put") {
		filename = al_dst_node(params, "filename");
		content = al_dst_node(params, "output");
		session.setAttribute("shell_filename", filename);
		if (filename != "") {
			try {
				FileUtility::writeBinary(pwd + "/" + filename, content);
				session.setAttribute("shell_output", "[INFO] file '" + pwd + "/" + filename + "' created.");
			} catch (AlException e) {
				session.setAttribute("shell_output", "[ERROR] " + (string)e.msg);
			}
		} else {
		}
	} else {
	}
	return invokeView(params, conn);
}
end_body
member
public: void genPageBegin(string title);
body
{
	res.out("<HTML><HEAD>\n<META http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n<TITLE>");
	res.out(toUTF8(title));
	res.out("</TITLE></HEAD><BODY>\n");
}
end_body
member
public: void genRefreshPageBegin(string title, integer interval);
body
{
	res.out("<HTML><HEAD>\n<META http-equiv=\"Refresh\" content=\"");
	res.out((string)interval);
	res.out("; charset=UTF-8\">\n<TITLE>");
	res.out(toUTF8(title));
	res.out("</TITLE><BODY>\n");
}
end_body
member
public: void genPageEnd();
body
{
	res.out("</BODY></HTML>\n");
}
end_body
member
public: void genFormBegin(string action, list upload);
body
{
	res.out("<FORM METHOD=\"POST\" ACTION=\"ebiz?action=");
	res.out(action);
	res.out("\"");
	if (upload) {
		res.out(" ENCTYPE=\"multipart/form-data\"");
	} else {
	}
	res.out(">\n");
}
end_body
member
public: void genFormEnd();
body
{
	res.out("</FORM>\n");
}
end_body
member
public: void genTitle(string text);
body
{
	res.out("<H3>");
	res.out(toUTF8(text));
	res.out("</H3>\n");
}
end_body
member
public: void genText(string text);
body
{
	res.out(toUTF8(text));
}
end_body
member
public: void genLink(string path, string text);
body
{
	res.out("<A HREF=\"");
	res.out(path);
	res.out("\">");
	res.out(toUTF8(text));
	res.out("</A>\n");
}
end_body
member
public: void genBR();
body
{
	res.out("<BR/>\n");
}
end_body
member
public: void genHR();
body
{
	res.out("<HR/>\n");
}
end_body
member
public: void genButton(string name, string value);
body
{
	res.out("<INPUT TYPE=\"submit\" NAME=\"");
	res.out(name);
	res.out("\" VALUE=\"");
	res.out(toUTF8(value));
	res.out("\"/>\n");
}
end_body
member
public: void genTextField(string name, integer size, string value);
body
{
	res.out("<INPUT TYPE=\"text\" NAME=\"");
	res.out(name);
	res.out("\" VALUE=\"");
	res.out(toUTF8(value));
	res.out("\" SIZE=\"");
	res.out((string)size);
	res.out("\"/>\n");
}
end_body
member
public: void genPassword(string name, integer size, string value);
body
{
	res.out("<INPUT TYPE=\"password\" NAME=\"");
	res.out(name);
	res.out("\" VALUE=\"");
	res.out(toUTF8(value));
	res.out("\" SIZE=\"");
	res.out((string)size);
	res.out("\"/>\n");
}
end_body
member
public: void genTextArea(string name, integer rows, integer cols, string value);
body
{
	res.out("<TEXTAREA NAME=\"");
	res.out(name);
	res.out("\" ROWS=\"");
	res.out((string)rows);
	res.out("\" COLS=\"");
	res.out((string)cols);
	res.out("\">\n");
	res.out(toUTF8(value));
	res.out("</TEXTAREA>\n");
}
end_body
member
public: void genCheck(string name, string text, list checked);
body
{
	res.out("<INPUT TYPE=\"checkBox\" NAME=\"");
	res.out(name);
	res.out("\"");
	if (checked) {
		res.out(" CHECKED=\"true\"");
	} else {
	}
	res.out("/>");
	res.out(toUTF8(text));
	res.out("\n");
}
end_body
member
public: void genRadio(string name, string value, string text, list checked);
body
{
	res.out("<INPUT TYPE=\"radio\" NAME=\"");
	res.out(name);
	res.out("\" VALUE=\"");
	res.out(toUTF8(value));
	res.out("\"");
	if (checked) {
		res.out(" CHECKED=\"true\"");
	} else {
	}
	res.out("/>");
	res.out(toUTF8(text));
	res.out("\n");
}
end_body
member
public: void genHidden(string name, string value);
body
{
	res.out("<INPUT TYPE=\"hidden\" NAME=\"");
	res.out(name);
	res.out("\" VALUE=\"");
	res.out(toUTF8(value));
	res.out("\"/>\n");
}
end_body
member
public: void genUpload(string name);
body
{
	res.out("<INPUT TYPE=\"file\" NAME=\"");
	res.out(name);
	res.out("\"/>\n");
}
end_body
member
public: void genSelect(string name, list values);
body
{
	res.out("<SELECT NAME=\"");
	res.out(name);
	res.out("\" SIZE=\"1\">\n");
	var string value;
	var list itr;
	itr = al_dst_itr(values);
	loop {
		if (value = al_next(itr)) {
		} else {
			break;
		}
		res.out("  <OPTION");
		if (al_arc_a(itr)) {
			res.out(" SELECTED=\"true\"");
		} else {
		}
		res.out(">");
		res.out(toUTF8(value));
		res.out("</OPTION>\n");
	}
	res.out("</SELECT>\n");
}
end_body
member
public: void genTable1(XmlDbObject obj, list visibles, list editables, list passwords, list io_map);
body
{
	res.out("<TABLE BORDER=\"1\">\n");
	var list itr;
	var string path, disp_name, value;
	itr = al_dst_itr(visibles);
	loop {
		if (al_next(itr)) {
		} else {
			break;
		}
		path = al_arc_a(itr);
		if (obj) {
			value = obj.getField(path);
		} else {
			value = "";
		}
		if (value == null || value == XmlUtility::ctrl_a) {
			value = "";
		} else {
		}
		if (io_map && disp_name = al_dst_node(io_map, path)) {
		} else {
			disp_name = al_str_misc("chg_delimiter", path, al_list2('/', ' '));
		}
		res.out("<TR><TD>");
		res.out(toUTF8(disp_name));
		res.out("</TD><TD>");
		if (editables && al_dst_node(editables, path)) {
			if (al_dst_node(passwords, path)) {
				genPassword(path, 20, value);
			} else {
				genTextField(path, 20, value);
			}
		} else {
			if (al_dst_node(passwords, path)) {
				genText("********");
			} else {
				genText(value);
			}
		}
		res.out("</TD></TR>\n");
	}
	res.out("</TABLE>\n");
}
end_body
member
public: void genTable2(list objs, list visibles, list checks, list radio, integer count_from, integer count_max, list io_map);
body
{
	res.out("<TABLE BORDER=\"1\">\n");
	var XmlDbObject obj;
	var list itr, itr2;
	var string path, disp_name, value;
	var integer count;
	itr2 = al_dst_itr(visibles);
	res.out("<TR>");
	if (checks) {
		res.out("<TD></TD>");
	} else {
	}
	loop {
		if (al_next(itr2)) {
		} else {
			break;
		}
		path = al_arc_a(itr2);
		if (io_map && disp_name = al_dst_node(io_map, path)) {
		} else {
			disp_name = al_str_misc("chg_delimiter", path, al_list2('/', ' '));
		}
		res.out("<TD>");
		res.out(toUTF8(disp_name));
		res.out("</TD>");
	}
	res.out("</TR>\n");
	itr = al_dst_itr(objs);
	count = 1;
	loop {
		if (count_from > 1 && count < count_from) {
		} else {
			break;
		}
		if (obj = al_next(itr)) {
		} else {
			break;
		}
		count = count + 1;
	}
	obj = 1;
	loop {
		if (count_max > 0 && count > count_max) {
			break;
		} else {
		}
		if (obj && obj = al_next(itr)) {
		} else {
			break;
		}
		count = count + 1;
		res.out("<TR>");
		if (checks) {
			res.out("<TD>");
			var list checked;
			checked = al_dst_node(checks, obj.dataId);
			if (radio) {
				genRadio((string)radio, obj.dataId, "", checked);
			} else {
				genCheck(obj.dataId, "", checked);
			}
			res.out("</TD>");
		} else {
		}
		itr2 = al_dst_itr(visibles);
		loop {
			if (al_next(itr2)) {
			} else {
				break;
			}
			path = al_arc_a(itr2);
			value = obj.getField(path);
			if (io_map && disp_name = al_dst_node(io_map, path)) {
			} else {
				disp_name = path;
			}
			if (value == null || value == XmlUtility::ctrl_a) {
				value = "";
			} else {
			}
			res.out("<TD>");
			genText(value);
			res.out("</TD>");
		}
		res.out("</TR>\n");
	}
	res.out("</TABLE>\n");
}
end_body
member
public: string toUTF8(string str);
body
{
	return HttpServlet::toUTF8(str);
}
end_body
member
public: string fromUTF8(string str);
body
{
	return HttpServlet::fromUTF8(str);
}
end_body
member
public: string fromUTF8(list str);
body
{
	return HttpServlet::fromUTF8(str);
}
end_body
member
public: void dumpProps(list params);
body
{
	al_print("==== begin Dump params <<<<\n");
	var list itr;
	var string name, value;
	itr = al_dst_itr(params);
	loop {
		if (value = al_next(itr)) {
		} else {
			break;
		}
		name = fromUTF8((string)al_arc_a(itr));
		value = fromUTF8(value);
		al_print("name = " + (string)name + ", value = " + (string)value + "\n");
	}
	al_print("==== end Dump params >>>>\n");
}
end_body
member
public: string date_str(list datetime);
body
{
	var string yyyy, mm, dd, str;
	yyyy = datetime.head;
	mm = datetime.tail.head;
	dd = datetime.tail.tail.head;
	str = (string)yyyy + "/";
	if (mm < 10) {
		str = str + "0";
	} else {
	}
	str = str + (string)mm + "/";
	if (dd < 10) {
		str = str + "0";
	} else {
	}
	str = str + (string)dd;
	return str;
}
end_body
member
public: string date_str_2(list datetime);
body
{
	var string yyyy, mm, dd, str;
	yyyy = datetime.head;
	mm = datetime.tail.head;
	dd = datetime.tail.tail.head;
	str = (string)yyyy;
	if (mm < 10) {
		str = str + "0";
	} else {
	}
	str = str + (string)mm;
	if (dd < 10) {
		str = str + "0";
	} else {
	}
	str = str + (string)dd;
	return str;
}
end_body
member
public: list date_xml(list datetime);
body
{
	var string yyyy, mm, dd, str;
	var file f;
	var list xml;
	yyyy = datetime.head;
	mm = datetime.tail.head;
	dd = datetime.tail.tail.head;
	str = al_copy("");
	al_append_str(str, "<Date>");
	al_append_str(str, "<Year>");
	al_append_str(str, (string)yyyy);
	al_append_str(str, "</Year>");
	al_append_str(str, "<Month>");
	al_append_str(str, (string)mm);
	al_append_str(str, "</Month>");
	al_append_str(str, "<Day>");
	al_append_str(str, (string)dd);
	al_append_str(str, "</Day>");
	al_append_str(str, "</Date>");
	f = al_file_open(str, "sr");
	xml = al_xml("parse", f, null, null);
	xml = xml.head;
	return xml;
}
end_body
member
public: string from_date_html(list xml);
body
{
	var string xml_str;
	xml_str = XmlUtility::xslTransform(XmlUtility::xsl_base + "/bizsoft/from_date.xsl", xml);
	return xml_str;
}
end_body
member
public: string to_date_html(list xml);
body
{
	var string xml_str;
	xml_str = XmlUtility::xslTransform(XmlUtility::xsl_base + "/bizsoft/to_date.xsl", xml);
	return xml_str;
}
end_body
member
public: integer date_int(string date_str);
body
{
	var list ls, itr;
	var integer yyyy, mm, dd;
	ls = al_str_misc("split", date_str, '/');
	itr = al_dst_itr(ls);
	yyyy = (integer)al_next(itr);
	mm = (integer)al_next(itr);
	dd = (integer)al_next(itr);
	return al_list6(yyyy, mm, dd, 0, 0, 0);
}
end_body
end_class
end_class
class HttpRequest
member
public: WebServer _server;
member
public: HttpResponse _response;
member
public: string _command;
member
public: string _path;
member
public: string _params;
member
public: list bin_raw_http_header;
member
public: list headers;
member
public: string fromIP;
member
public: list cert_info;
member
public: list input;
member
public: string input_file;
member
public: list getParameters();
body
{
	if (parameters) {
		return parameters;
	} else {
	}
	parameters = al_cons(null, null);
	var list ls, itr, nv;
	var string name_value, name, value;
	ls = al_str_misc("split", _params, '&');
	itr = al_dst_itr(ls);
	loop {
		if (name_value = al_next(itr)) {
		} else {
			break;
		}
		nv = splitNameValue(name_value);
		name = al_str_misc("param_to_string", nv.head, null);
		value = nv.tail.head;
		al_create_arc(parameters, value, name);
	}
	if (_command == "POST") {
		var string contentType;
		var list mimeMultipart, mimeBody, itr, hdr, hdr_val;
		var integer idx, size;
		contentType = al_dst_node_i(headers, "Content-Type");
		if (al_str_misc("strcmpi", contentType, "multipart/form-data") == 0) {
			mimeMultipart = al_crypt("mime_multipart_read", input, headers, null);
			itr = al_dst_itr(mimeMultipart);
			loop {
				if (mimeBody = al_next(itr)) {
				} else {
					break;
				}
				size = al_misc("binary_size", mimeBody, null);
				hdr = al_crypt("mime_headers_read", mimeBody, null, null);
				if (hdr) {
					idx = hdr.tail.head;
					hdr = hdr.head;
					hdr_val = al_dst_node_i(hdr, "Content-Disposition");
					if (hdr_val == "form-data") {
						name = al_dst_node_i(hdr_val, "name");
						value = al_misc("binary_to_string", al_list3(mimeBody, idx, size - idx), null);
						al_create_arc(parameters, value, name);
					} else {
					}
				} else {
				}
			}
			return parameters;
		} else {
		}
		var string params;
		size = al_misc("binary_size", input, null);
		params = al_misc("binary_to_string", al_list3(input, 0, size), null);
		ls = al_str_misc("split", params, '&');
		itr = al_dst_itr(ls);
		loop {
			if (name_value = al_next(itr)) {
			} else {
				break;
			}
			nv = splitNameValue(name_value);
			name = al_str_misc("param_to_string", nv.head, null);
			value = nv.tail.head;
			value = al_str_misc("param_to_string", value, null);
			al_create_arc(parameters, value, name);
		}
	} else {
	}
	return parameters;
}
end_body
member
public: string getParameter(string name);
body
{
	parameters = getParameters();
	return al_dst_node_i(parameters, name);
}
end_body
member
public: list parameters;
member
public: HttpSession createSession();
body
{
	var HttpSession session;
	if (session = getSession()) {
		return session;
	} else {
	}
	session = new HttpSession;
	session._create(_server);
	getCookies();
	al_create_arc(cookies, session._sessionId, "AltairSession");
	var string cookie;
	cookie = "AltairSession=" + session._sessionId + "; Path=" + getBasePath();
	al_create_arc(_response.headers, cookie, "Set-Cookie");
	return session;
}
end_body
member
public: HttpSession getSession();
body
{
	if (_server.sessions) {
	} else {
		return null;
	}
	getCookies();
	var string session_id;
	var list itr;
	itr = al_dst_itr(cookies);
	loop {
		if (session_id = al_next(itr)) {
		} else {
			break;
		}
		if (al_str_misc("strcmpi", al_arc_a(itr), "AltairSession") != 0) {
			continue;
		} else {
		}
		var HttpSession session;
		if (session = al_dst_node_i(_server.sessions, session_id)) {
			session._time = 0;
			return session;
		} else {
		}
	}
	return null;
}
end_body
member
public: list getCookies();
body
{
	if (cookies) {
		return cookies;
	} else {
	}
	cookies = al_cons(null, null);
	var list itr, nv, itr2;
	var string name_value, name, value;
	itr = al_dst_itr(headers);
	loop {
		if (name_value = al_next(itr)) {
		} else {
			break;
		}
		if (al_str_misc("strcmpi", al_arc_a(itr), "Cookie") != 0) {
			continue;
		} else {
		}
		nv = splitNameValue(name_value);
		name = nv.head;
		value = nv.tail.head;
		al_create_arc(cookies, value, name);
		itr2 = al_dst_itr(name_value);
		loop {
			if (value = al_next(itr2)) {
			} else {
				break;
			}
			name = al_arc_a(itr2);
			al_create_arc(cookies, value, name);
		}
	}
	return cookies;
}
end_body
member
public: string getCookie(string name);
body
{
	getCookies();
	return al_dst_node_i(cookies, name);
}
end_body
member
public: list cookies;
member
public: string getBasePath();
body
{
	var string path;
	var integer idx;
	idx = al_strlen(_path) - 1;
	loop {
		if (idx < 0 || al_get_char(_path, idx) == '/') {
			path = al_substr(_path, 0, idx + 1);
			break;
		} else {
		}
		idx = idx - 1;
	}
	return path;
}
end_body
member
public: static list splitNameValue(string name_value);
body
{
	var string name, value;
	var integer idx;
	idx = al_search_str(name_value, 0, "=");
	if (idx >= 0) {
		name = al_substr(name_value, 0, idx);
		value = al_substr(name_value, idx + 1, al_strlen(name_value));
	} else {
		name = name_value;
		value = "";
	}
	return al_list2(name, value);
}
end_body
end_class
class HttpResponse
member
public: void _create();
body
{
	response_code = 200;
	headers = al_cons(null, null);
	max_size = 4096;
	output = al_misc("binary", max_size, null);
	content_length = 0;
}
end_body
member
public: HttpRequest _request;
member
public: integer response_code;
member
public: list headers;
member
public: list output;
member
public: integer max_size;
member
public: integer content_length;
member
public: void out(string s);
body
{
	var integer len;
	len = al_strlen(s);
	if (content_length + len > max_size) {
		al_misc("extend_binary", output, len);
		max_size = max_size + len;
	} else {
	}
	al_misc("binary_copy", al_list2(output, content_length), s);
	content_length = content_length + len;
	if (content_length > _server.maxMsgSize * 1000) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "response message too large: size >= " + (string)content_length;
		throw ex;
	} else {
	}
}
end_body
member
public: void out(list binary);
body
{
	var integer size;
	size = al_misc("binary_size", binary, null);
	out(binary, 0, size);
}
end_body
member
public: void out(list binary, integer index, integer size);
body
{
	if (content_length + size > max_size) {
		al_misc("extend_binary", output, size);
		max_size = max_size + size;
	} else {
	}
	al_misc("binary_copy", al_list2(output, content_length), al_list3(binary, index, size));
	content_length = content_length + size;
	if (content_length > _server.maxMsgSize * 1000) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "response message too large: size >= " + (string)content_length;
		throw ex;
	} else {
	}
}
end_body
member
public: void redirect(string url);
body
{
	if (al_strlen(url) >= 4 && al_substr(url, 0, 4) == "http") {
	} else {
		var string host;
		if (host = al_dst_node_i(_request.headers, "Host")) {
		} else {
			host = "localhost";
		}
		if (al_strlen(url) >= 1 && al_get_char(url, 0) == '/') {
			if (_server.ssl == null) {
				url = "http://" + host + url;
			} else {
				url = "https://" + host + url;
			}
		} else {
			if (_server.ssl == null) {
				url = "http://" + host + _request.getBasePath() + url;
			} else {
				url = "https://" + host + _request.getBasePath() + url;
			}
		}
	}
	// redirect
	response_code = 302;
	al_set_dst_node(headers, "Location", url);
	if (http_ver == "HTTP/1.1") {
		al_set_dst_node(headers, "Connection", "Close");
	} else {
	}
	out("<HTML><HEAD><TITLE>Document moved</TITLE><HEAD><BODY>\n");
	out("<H1>Document moved</H1>\n");
	out("This document has moved <A HREF=\"");
	out(url);
	out("\">here</A>.<P>\n");
	out("</BODY></HTML>\n");
}
end_body
member
public: void redirectWithSession(string url);
body
{
	var HttpSession session;
	if (session = _request.getSession()) {
		var string cookie;
		cookie = "AltairSession=" + session._sessionId + "; Path=" + _request.getBasePath();
		al_set_dst_node(headers, "Set-Cookie", cookie);
	} else {
	}
	redirect(url);
}
end_body
member
public: WebServer _server;
member
public: string http_ver;
member
public: string system_command;
member
public: string response_filepath;
member
public: string response_content_disposition;
end_class
class HttpSession
member
public: void _create(WebServer server);
body
{
	_server = server;
	_sessionId = al_crypt("random", 64, null, null);
	_time = 0;
	if (_server.sessions) {
	} else {
		_server.sessions = al_cons(null, null);
	}
	al_set_dst_node(_server.sessions, _sessionId, this);
}
end_body
member
public: WebServer _server;
member
public: string _sessionId;
member
public: integer _time;
member
public: void invalidate();
body
{
	var list itr;
	var HttpSession s;
	itr = al_dst_itr(_server.sessions);
	loop {
		if (s = al_next(itr)) {
		} else {
			break;
		}
		if (al_addr_eq(s, this)) {
			al_remove(itr);
			break;
		} else {
		}
	}
}
end_body
member
public: list getAttributes();
body
{
	return attrs;
}
end_body
member
public: list getAttribute(string name);
body
{
	if (attrs) {
	} else {
		return null;
	}
	return al_dst_node(attrs, name);
}
end_body
member
public: void setAttribute(string name, list attr);
body
{
	if (attrs) {
	} else {
		attrs = al_cons(null, null);
	}
	al_set_dst_node(attrs, name, attr);
}
end_body
member
public: void setAttribute(string name, integer attr);
body
{
	setAttribute(name, (list)attr);
}
end_body
member
public: void setAttribute(string name, string attr);
body
{
	setAttribute(name, (list)attr);
}
end_body
member
public: void setAttribute(string name, AlObject attr);
body
{
	setAttribute(name, (list)attr);
}
end_body
member
public: list attrs;
end_class
end_class
class MultipartSecureMessage
member
public: void setHeader(string name, string value);
body
{
	_genContentType();
	al_set_dst_node(header, name, value);
}
end_body
member
public: void addHeaderSubType(string name, string subtype, string value);
body
{
	_genContentType();
	var list ls;
	if (ls = al_dst_node_i(header, name)) {
		al_set_dst_node(ls, subtype, value);
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "not found name '" + (string)name + "'";
		throw ex;
	}
}
end_body
member
public: void setBodyHeader(string name, string value);
body
{
	if (body_header) {
	} else {
		body_header = al_cons(null, null);
	}
	al_set_dst_node(body_header, name, value);
}
end_body
member
public: void addBodyHeaderSubType(string name, string subtype, string value);
body
{
	if (body_header) {
	} else {
		body_header = al_cons(null, null);
	}
	var list ls;
	if (ls = al_dst_node_i(body_header, name)) {
		al_set_dst_node(ls, subtype, value);
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "not found name '" + (string)name + "'";
		throw ex;
	}
}
end_body
member
public: void addBodyText(string text);
body
{
	var integer len;
	var list bin;
	len = al_strlen(text);
	bin = al_misc("binary", len, null);
	al_misc("binary_copy", al_list2(bin, 0), text);
	addBodyBinary(bin, 0, len);
}
end_body
member
public: void addBodyFile(string filename);
body
{
	var integer len;
	var list bin;
	var file in;
	if (al_file_manip("does_exist", filename, null)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "file not found '" + (string)filename + "'.";
		throw ex;
	}
	len = al_file_manip("get_size", filename, null);
	bin = al_misc("binary", len, null);
	if (in = al_file_open(filename, "rb")) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "can't open file '" + (string)filename + "'.";
		throw ex;
	}
	if (al_file_read(in, al_list3(bin, 0, len))) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "file read error '" + (string)filename + "'.";
		throw ex;
	} else {
	}
	addBodyBinary(bin, 0, len);
}
end_body
member
public: void addBodyBinary(list content_bin, integer from, integer content_len);
body
{
	_genContentType();
	if (multipart) {
	} else {
		multipart = al_cons(header, null);
	}
	var list bin, header_bin;
	var integer header_len;
	if (header_bin = al_crypt("mime_headers_write", body_header, null, null)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "can't generate mime body header.";
		throw ex;
	}
	header_len = al_misc("binary_size", header_bin, null);
	var string encoding;
	encoding = al_dst_node_i(body_header, "Content-Transfer-Encoding");
	if (encoding == "base64") {
		// NG: following codes do not work well, may be due to OpenSSL bug
		// content_bin = al_crypt("base64_encode", content_bin, null, null);
		// use temporary file in order to avoid this bug
		var string tmp_filename;
		try {
			tmp_filename = FileUtility::tempFile();
			if (al_crypt("base64_encode", content_bin, tmp_filename, null)) {
			} else {
				var AlException ex;
				ex = new AlException;
				ex.msg = "fail to encode mime body header by base64.";
				throw ex;
			}
			content_bin = FileUtility::readBinary(tmp_filename);
			content_len = al_misc("binary_size", content_bin, null);
			al_file_manip("remove", tmp_filename, null);
		} catch (AlException e) {
			if (tmp_filename && al_file_manip("does_exist", tmp_filename, null)) {
				al_file_manip("remove", tmp_filename, null);
			} else {
			}
			throw e;
		}
	} else {
	}
	bin = al_misc("binary", header_len + content_len, null);
	al_misc("binary_copy", al_list2(bin, 0), al_list3(header_bin, 0, header_len));
	al_misc("binary_copy", al_list2(bin, header_len), al_list3(content_bin, 0, content_len));
	var list itr;
	itr = al_dst_itr(multipart);
	al_create_arc(multipart, bin, al_count(itr));
	body_header = null;
}
end_body
member
public: void addMultipartSecureMessage(MultipartSecureMessage msm);
body
{
	if (multipart && msm && msm.multipart) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "not multipart object.";
		throw ex;
	}
	var list itr, body;
	var integer count;
	itr = al_dst_itr(multipart);
	count = al_count(itr);
	itr = al_dst_itr(msm.multipart);
	loop {
		if (body = al_next(itr)) {
		} else {
			break;
		}
		al_create_arc(multipart, body, count);
		count = count + 1;
	}
}
end_body
member
public: string _genContentType();
body
{
	if (header) {
	} else {
		header = al_cons(null, null);
	}
	var list ls;
	if (ls = al_dst_node_i(header, "Content-Type")) {
	} else {
		al_set_dst_node(header, "Content-Type", ls = al_copy("multipart/related"));
	}
	var string boundary;
	if (boundary = al_dst_node(ls, "boundary")) {
	} else {
		boundary = al_crypt("random", 64, null, null);
		al_create_arc(ls, boundary, "boundary");
	}
	return boundary;
}
end_body
member
public: void writeHeader(file out);
body
{
	var list header_bin;
	var integer header_len;
	if (header_bin = al_crypt("mime_headers_write", header, null, null)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "can't generate mime message header.";
		throw ex;
	}
	header_len = al_misc("binary_size", header_bin, null);
	if (al_file_write(out, al_list3(header_bin, 0, header_len), null)) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "write error: (mime message header).";
		throw ex;
	} else {
	}
}
end_body
member
public: void writeMultipart(file out);
body
{
	var list content_bin;
	var integer content_len;
	if (content_bin = al_crypt("mime_multipart_write", multipart, null, null)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "can't generate mime multipart.";
		throw ex;
	}
	content_len = al_misc("binary_size", content_bin, null);
	var string encoding;
	if (encoding = al_dst_node_i(header, "Content-Transfer-Encoding")) {
	} else {
		encoding = al_dst_node_i(header, "Transfer-Encoding");
	}
	if (encoding == "base64") {
		// NG: following codes do not work well, may be due to OpenSSL bug
		// content_bin = al_crypt("base64_encode", content_bin, null, null);
		// use temporary file in order to avoid this bug
		var string tmp_filename, tmp_str;
		try {
			tmp_filename = FileUtility::tempFile();
			if (al_crypt("base64_encode", content_bin, tmp_filename, null)) {
			} else {
				var AlException ex;
				ex = new AlException;
				ex.msg = "fail to encode mime body header by base64.";
				throw ex;
			}
			content_bin = FileUtility::readBinary(tmp_filename);
			content_len = al_misc("binary_size", content_bin, null);
			al_file_manip("remove", tmp_filename, null);
		} catch (AlException e) {
			if (tmp_filename && al_file_manip("does_exist", tmp_filename, null)) {
				al_file_manip("remove", tmp_filename, null);
			} else {
			}
			throw e;
		}
	} else {
	}
	if (al_file_write(out, al_list3(content_bin, 0, content_len), null)) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "write error: (mime multipart).";
		throw ex;
	} else {
	}
}
end_body
member
public: void writeMultipartMessage(file out);
body
{
	writeHeader(out);
	writeMultipart(out);
}
end_body
member
public: list header;
member
public: list body_header;
member
public: list body_header_bin;
member
public: integer body_index;
member
public: list body_content;
member
public: void readMultipartMessage(string filename);
body
{
	var list bin;
	var integer len;
	bin = FileUtility::readBinary(filename);
	len = al_misc("binary_size", bin, null);
	readMultipartMessage(bin, len);
}
end_body
member
public: void readMultipartMessage(list bin, integer size);
body
{
	var list result;
	var integer i;
	if (result = al_crypt("mime_headers_read", al_list3(bin, 0, size), null, null)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "can't read mime message header.";
		throw ex;
	}
	header = result.head;
	i = result.tail.head;
	var string encoding;
	if (encoding = al_dst_node_i(header, "Content-Transfer-Encoding")) {
	} else {
		encoding = al_dst_node_i(header, "Transfer-Encoding");
	}
	if (encoding == "base64") {
		var list buf;
		buf = al_misc("binary", size - i, null);
		al_misc("binary_copy", al_list2(buf, 0), al_list3(bin, i, size - i));
		bin = null;
		if (buf = al_crypt("base64_decode", buf, null, null)) {
		} else {
			var AlException ex;
			ex = new AlException;
			ex.msg = "fail to decode mime message by base64.";
			throw ex;
		}
		multipart = al_crypt("mime_multipart_read", buf, header, null);
		buf = null;
	} else {
		multipart = al_crypt("mime_multipart_read", al_list3(bin, i, size - i), header, null);
		bin = null;
	}
	if (multipart) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "can't read mime multipart.";
		throw ex;
	}
	body_header = body_content = body_index = null;
}
end_body
member
public: void readMultipartMessage2(list bin, integer size);
body
{
	var list result;
	var integer i;
	if (result = al_crypt("mime_headers_read", al_list3(bin, 0, size), null, null)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "can't read mime message header.";
		throw ex;
	}
	header = result.head;
	i = result.tail.head;
	multipart = al_crypt("mime_multipart_read", al_list3(bin, i, size - i), header, null);
	bin = null;
	if (multipart) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "can't read mime multipart.";
		throw ex;
	}
	body_header = body_content = body_index = null;
}
end_body
member
public: string getHeader(string name);
body
{
	if (header) {
	} else {
		return null;
	}
	return al_dst_node_i(header, name);
}
end_body
member
public: string getHeaderSubType(string name, string subtype);
body
{
	if (header) {
	} else {
		return null;
	}
	var list ls;
	if (ls = al_dst_node_i(header, name)) {
	} else {
		return null;
	}
	return al_dst_node_i(ls, subtype);
}
end_body
member
public: integer getCount();
body
{
	if (multipart) {
	} else {
		return 0;
	}
	var list itr;
	itr = al_dst_itr(multipart);
	return al_count(itr);
}
end_body
member
public: string getBodyHeader(integer index, string name);
body
{
	getBody(index);
	if (body_header) {
	} else {
		return null;
	}
	return al_dst_node_i(body_header, name);
}
end_body
member
public: string getBodyHeaderSubType(integer index, string name, string subtype);
body
{
	getBody(index);
	if (body_header) {
	} else {
		return null;
	}
	var list ls;
	if (ls = al_dst_node_i(body_header, name)) {
	} else {
		return null;
	}
	return al_dst_node_i(ls, subtype);
}
end_body
member
public: string getBodyText(integer index);
body
{
	getBody(index);
	var integer len;
	len = al_misc("binary_size", body_content, null);
	return al_misc("binary_to_string", al_list3(body_content, 0, len), null);
}
end_body
member
public: list getBodyBinary(integer index);
body
{
	getBody(index);
	return body_content;
}
end_body
member
public: void getBody(integer index);
body
{
	var list bin;
	var integer size;
	if (index == body_index) {
		return;
	} else {
	}
	if (multipart) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "multipart is null.";
		throw ex;
	}
	if (bin = al_dst_node(multipart, index)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "body index is out of range: index = " + (string)index + ".";
		throw ex;
	}
	size = al_misc("binary_size", bin, null);
	var list result;
	var integer i;
	if (result = al_crypt("mime_headers_read", al_list3(bin, 0, size), null, null)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "can't read mime body header: index = " + (string)index + ".";
		throw ex;
	}
	body_header = result.head;
	i = result.tail.head;
	body_header_bin = al_misc("binary", i, null);
	al_misc("binary_copy", al_list2(body_header_bin, 0), al_list3(bin, 0, i));
	body_content = al_misc("binary", size - i, null);
	al_misc("binary_copy", al_list2(body_content, 0), al_list3(bin, i, size - i));
	var string encoding;
	encoding = al_dst_node_i(body_header, "Content-Transfer-Encoding");
	if (encoding == "base64") {
		if (body_content = al_crypt("base64_decode", body_content, null, null)) {
		} else {
			var AlException ex;
			ex = new AlException;
			ex.msg = "fail to decode mime body header by base64.";
			throw ex;
		}
	} else {
	}
	body_index = index;
}
end_body
member
public: list multipart;
member
public: void encrypt(string cipher, string cert);
body
{
	if (cipher) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "MultipartSecureMessage.encrypt: encryption algorithm is null.";
		throw ex;
	}
	if (cert) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "MultipartSecureMessage.encrypt: partner cert is null.";
		throw ex;
	}
	var list files, bin, out_bin;
	files = al_list4(cipher, cert, null, null);
	var list header_bin, content_bin;
	var integer header_len, content_len, out_bin_len;
	if (header_bin = al_crypt("mime_headers_write", header, null, null)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "can't generate mime message header.";
		throw ex;
	}
	header_len = al_misc("binary_size", header_bin, null);
	if (content_bin = al_crypt("mime_multipart_write", multipart, null, null)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "can't generate mime multipart.";
		throw ex;
	}
	content_len = al_misc("binary_size", content_bin, null);
	bin = al_misc("binary", header_len + content_len, null);
	al_misc("binary_copy", al_list2(bin, 0), al_list3(header_bin, 0, header_len));
	al_misc("binary_copy", al_list2(bin, header_len), al_list3(content_bin, 0, content_len));
	if (out_bin = al_crypt("smime_encrypt", bin, null, files)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "fail to_encrypt.";
		throw ex;
	}
	out_bin_len = al_misc("binary_size", out_bin, null);
	var list result;
	result = al_crypt("mime_headers_read", al_list3(out_bin, 0, out_bin_len), null, null);
	body_header = result.head;
	al_set_dst_node(body_header, "MIME-Version", null);
	header = multipart = null;
	addBodyBinary(out_bin, (integer)result.tail.head, (integer)(out_bin_len - result.tail.head));
}
end_body
member
public: void sign(string cert, string key);
body
{
	if (cert) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "MultipartSecureMessage.sign: my cert is null.";
		throw ex;
	}
	if (key) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "MultipartSecureMessage.sign: my key is null.";
		throw ex;
	}
	var list files, out_bin;
	var integer out_bin_len;
	files = al_list4(null, cert, key, null);
	// NG: following codes do not work well, may be due to OpenSSL bug
	// if (out_bin = al_crypt("smime_sign", bin, null, files)) {
	// use temporary file in order to avoid this bug
	var string tmp1, tmp2;
	try {
		tmp1 = FileUtility::tempFile();
		tmp2 = FileUtility::tempFile();
		var file f;
		if (f = al_file_open(tmp1, "wb")) {
		} else {
			var AlException ex;
			ex = new AlException;
			ex.msg = "can't open temp file.";
			throw ex;
		}
		writeMultipartMessage(f);
		f = null;
		if (al_crypt("smime_sign", tmp1, tmp2, files)) {
		} else {
			var AlException ex;
			ex = new AlException;
			ex.msg = "fail to sign.";
			throw ex;
		}
		out_bin = FileUtility::readBinary(tmp2);
		out_bin_len = al_misc("binary_size", out_bin, null);
		al_file_manip("remove", tmp1, null);
		al_file_manip("remove", tmp2, null);
	} catch (AlException e) {
		if (tmp1 && al_file_manip("does_exist", tmp1, null)) {
			al_file_manip("remove", tmp1, null);
		} else {
		}
		if (tmp2 && al_file_manip("does_exist", tmp2, null)) {
			al_file_manip("remove", tmp2, null);
		} else {
		}
		throw e;
	}
	var list result;
	result = al_crypt("mime_headers_read", al_list3(out_bin, 0, out_bin_len), null, null);
	header = result.head;
	al_set_dst_node(header, "MIME-Version", null);
	multipart = al_crypt("mime_multipart_read", al_list3(out_bin, (integer)result.tail.head, (integer)(out_bin_len - result.tail.head)), header, null);
}
end_body
member
public: list isEncrypted(integer index);
body
{
	var string content_type;
	content_type = getBodyHeader(index, "Content-Type");
	if (al_str_misc("strcmpi", content_type, "application/x-pkcs7-mime") == 0) {
		return 1;
	} else {
	}
	if (al_str_misc("strcmpi", content_type, "application/pkcs7-mime") == 0) {
		return 1;
	} else {
	}
	return null;
}
end_body
member
public: void decrypt(integer index, string cert, string key);
body
{
	if (cert) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "MultipartSecureMessage.decrypt: my cert is null.";
		throw ex;
	}
	if (key) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "MultipartSecureMessage.decrypt: my key is null.";
		throw ex;
	}
	var list files, bin, out_bin;
	var integer out_bin_size;
	files = al_list4(null, cert, key, null);
	bin = getBodyBinary(index);
	if (out_bin = al_crypt("smime_decrypt", bin, null, files)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "fail to_decrypt.";
		throw ex;
	}
	out_bin_size = al_misc("binary_size", out_bin, null);
	readMultipartMessage(out_bin, out_bin_size);
}
end_body
member
public: list isSigned();
body
{
	var string content_type;
	content_type = getHeader("Content-Type");
	if (al_str_misc("strcmpi", content_type, "multipart/signed") == 0) {
		return 1;
	} else {
	}
	return null;
}
end_body
member
public: list verify(string cert, string ca_cert);
body
{
	if (cert) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "MultipartSecureMessage.verify: partner cert is null.";
		throw ex;
	}
	if (ca_cert) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "MultipartSecureMessage.verify: CA cert is null.";
		throw ex;
	}
	var list files, bin;
	files = al_list4(null, cert, null, ca_cert);
	var list header_bin, content_bin;
	var integer header_len, content_len;
	if (header_bin = al_crypt("mime_headers_write", header, null, null)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "can't generate mime message header.";
		throw ex;
	}
	header_len = al_misc("binary_size", header_bin, null);
	if (content_bin = al_crypt("mime_multipart_write", multipart, null, null)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "can't generate mime multipart.";
		throw ex;
	}
	content_len = al_misc("binary_size", content_bin, null);
	bin = al_misc("binary", header_len + content_len, null);
	al_misc("binary_copy", al_list2(bin, 0), al_list3(header_bin, 0, header_len));
	al_misc("binary_copy", al_list2(bin, header_len), al_list3(content_bin, 0, content_len));
	var list digest;
	if (digest = al_crypt("smime_verify", bin, null, files)) {
		// verify OK
		return digest;
	} else {
		// verify NG
		return null;
	}
}
end_body
member
public: void multipartToOneBody();
body
{
	var list content_bin;
	var integer content_len;
	if (content_bin = al_crypt("mime_multipart_write", multipart, null, null)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "can't generate mime multipart.";
		throw ex;
	}
	content_len = al_misc("binary_size", content_bin, null);
	body_header = header;
	header = multipart = null;
	addBodyBinary(content_bin, 0, content_len);
}
end_body
member
public: void oneBodyToMultipart(integer index);
body
{
	var list header_bin, content_bin, bin;
	var integer header_len, content_len;
	content_bin = getBodyBinary(index);
	header_bin = body_header_bin;
	content_len = al_misc("binary_size", content_bin, null);
	header_len = al_misc("binary_size", header_bin, null);
	bin = al_misc("binary", header_len + content_len, null);
	al_misc("binary_copy", al_list2(bin, 0), al_list3(header_bin, 0, header_len));
	al_misc("binary_copy", al_list2(bin, header_len), al_list3(content_bin, 0, content_len));
	readMultipartMessage2(bin, header_len + content_len);
}
end_body
member
public: static void getBody(string in_file, string name, string out_file);
body
{
	var file in, out;
	var list buffer, block, hdr, last_block, current_block, work_block;
	var integer buffer_size, read_bytes, read_index, tail_size;
	var integer size1, size2, idx, size;
	var string content_type, boundary;
	var string content_disposition, name2;
	if (al_file_manip("does_exist", in_file, null)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "not found: filename = " + (string)in_file;
		throw ex;
	}
	if (in = al_file_open(in_file, "rb")) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "can't open: filename = " + (string)in_file;
		throw ex;
	}
	buffer_size = 4096;
	buffer = al_misc("binary", buffer_size, null);
	block = al_list3(buffer, 0, buffer_size);
	if (read_bytes = al_file_read(in, block)) {
		if (read_bytes < 0) {
			var AlException ex;
			ex = new AlException;
			ex.msg = "read error: filename = " + (string)in_file;
			throw ex;
		} else {
		}
	} else {
		read_bytes = buffer_size;
	}
	if (hdr = al_crypt("mime_headers_read", al_list3(buffer, 0, buffer_size), null, null)) {
		read_index = hdr.tail.head;
		hdr = hdr.head;
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "mime header read error.";
		throw ex;
	}
	if (content_type = al_dst_node_i(hdr, "Content-Type")) {
		boundary = al_dst_node_i(content_type, "boundary");
	} else {
	}
	if (boundary) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "boundary of multipart not found.";
		throw ex;
	}
	boundary = "--" + boundary;
	current_block = al_misc("binary", read_bytes, null);
	al_misc("binary_copy", al_list2(current_block, 0), al_list3(buffer, 0, read_bytes));
	loop {
		last_block = current_block;
		if (read_bytes = al_file_read(in, block)) {
			if (read_bytes < 0) {
				var AlException ex;
				ex = new AlException;
				ex.msg = "read error: filename = " + (string)in_file;
				throw ex;
			} else {
			}
		} else {
			read_bytes = buffer_size;
		}
		if (read_bytes >= 0) {
			current_block = al_misc("binary", read_bytes, null);
			al_misc("binary_copy", al_list2(current_block, 0), al_list3(buffer, 0, read_bytes));
		} else {
			if (out == null) {
				var AlException ex;
				ex = new AlException;
				ex.msg = "expected mime body not found.";
				throw ex;
			} else {
				var AlException ex;
				ex = new AlException;
				ex.msg = "mime body not terminated.";
				throw ex;
			}
		}
		size1 = al_misc("binary_size", last_block, null);
		size2 = read_bytes;
		work_block = al_misc("binary", size1 + size2, null);
		al_misc("binary_copy", al_list2(work_block, 0), al_list3(last_block, 0, size1));
		al_misc("binary_copy", al_list2(work_block, size1), al_list3(current_block, 0, size2));
		idx = al_misc("binary_search_str", al_list2(work_block, read_index), boundary);
		if (out == null) {
			if (idx >= 0 && idx < size1) {
				read_index = idx + al_strlen(boundary);
				if (al_misc("get_byte", al_list2(work_block, read_index), null) == '\r') {
					read_index = read_index + 1;
				} else {
				}
				if (al_misc("get_byte", al_list2(work_block, read_index), null) == '\n') {
					read_index = read_index + 1;
				} else {
				}
				if (hdr = al_crypt("mime_headers_read", al_list3(work_block, read_index, size1 + size2 - read_index), null, null)) {
					size = hdr.tail.head;
					hdr = hdr.head;
				} else {
					var AlException ex;
					ex = new AlException;
					ex.msg = "mime body header read error.";
					throw ex;
				}
				if (content_disposition = al_dst_node_i(hdr, "Content-Disposition")) {
					name2 = al_dst_node_i(content_disposition, "name");
				} else {
				}
				if (name2) {
				} else {
					var AlException ex;
					ex = new AlException;
					ex.msg = "content-disposition name not found.";
					throw ex;
				}
				read_index = read_index + size;
				if (name2 != name) {
					continue;
				} else {
				}
				if (out = al_file_open(out_file, "wb")) {
				} else {
					var AlException ex;
					ex = new AlException;
					ex.msg = "can't open: filename = " + (string)out_file;
					throw ex;
				}
				idx = al_misc("binary_search_str", al_list2(work_block, read_index), boundary);
				if (idx >= 0) {
					if (al_misc("get_byte", al_list2(work_block, idx - 1), null) == '\n') {
						idx = idx - 1;
					} else {
					}
					if (al_misc("get_byte", al_list2(work_block, idx - 1), null) == '\r') {
						idx = idx - 1;
					} else {
					}
					tail_size = idx - read_index;
				} else {
					tail_size = size1 - read_index;
				}
				if (tail_size > 0 && al_file_write(out, al_list3(work_block, read_index, tail_size), null)) {
					var AlException ex;
					ex = new AlException;
					ex.msg = "write error: filename = " + (string)out_file;
					throw ex;
				} else {
				}
				if (idx >= 0) {
					out = null;
					break;
				} else {
					read_index = 0;
				}
			} else {
			}
		} else {
			if (idx >= 0) {
				if (al_misc("get_byte", al_list2(work_block, idx - 1), null) == '\n') {
					idx = idx - 1;
				} else {
				}
				if (al_misc("get_byte", al_list2(work_block, idx - 1), null) == '\r') {
					idx = idx - 1;
				} else {
				}
				tail_size = idx;
			} else {
				tail_size = size1;
			}
			if (tail_size > 0 && al_file_write(out, al_list3(work_block, read_index, tail_size), null)) {
				var AlException ex;
				ex = new AlException;
				ex.msg = "write error: filename = " + (string)out_file;
				throw ex;
			} else {
			}
			if (idx >= 0) {
				out = null;
				break;
			} else {
			}
		}
	}
}
end_body
end_class
class ProxyServer
member
public: string name;
member
public: integer port;
member
public: integer connect_timeout;
member
public: ProxyServerConnectionMgr conn_mgr;
member
public: integer connectionTimeout;
member
public: AltairServer ap_server;
member
public: integer maxMsgSize;
member
public: void proxy_log(string fromIP, string path, string reason);
body
{
	if (ap_server) {
		if (proxy_log_filepath) {
			var string s;
			s = fromIP + " \"" + path + "\" " + reason;
			ap_server.log(proxy_log_filepath, s);
		} else {
		}
		if (proxy_log_db) {
			var DbConnection conn;
			var string db_type;
			try {
				conn = DbManager::getConnection(WebUIServlet::pool_name);
				db_type = DbManager::getDbType(WebUIServlet::pool_name);
				var string sql, time;
				time = al_misc("get_time", null, null);
				time = al_misc("get_localtime", time, null);
				time = al_misc("format_time", time, "yyyy'/'MM'/'dd'-'HH':'mm':'ss");
				sql = al_copy("insert into ProxyLog (ProxyLogId, Time, FromIP, Path, Reason) values ('");
				al_append_str(sql, conn.getNextSeq("ProxyLogId_seq"));
				al_append_str(sql, "','");
				al_append_str(sql, time);
				al_append_str(sql, "','");
				al_append_str(sql, (string)fromIP);
				al_append_str(sql, "','");
				al_append_str(sql, DbUtility::convChar((string)path));
				al_append_str(sql, "','");
				al_append_str(sql, (string)reason);
				al_append_str(sql, "')");
				conn.executeUpdate(sql);
				conn.commit();
				conn.close();
			} catch (AlException e) {
				if (conn) {
					try {
						conn.rollback();
					} catch (AlException e) {
					}
					try {
						conn.close();
					} catch (AlException e) {
					}
				} else {
				}
			}
		} else {
		}
	} else {
	}
}
end_body
member
public: string proxy_log_filepath;
member
public: string proxy_log_db;
member
public: void error_log(string str);
body
{
	ap_server.system_log("error", "ProxyServer: " + str);
}
end_body
class ProxyServerConnectionMgr
member
public: ProxyServer server;
member
public: list connections;
member
public: integer server_socket_id;
member
public: integer hwnd;
member
public: integer msg;
end_class
class ProxyServerConnection
member
public: void close();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! ProxyServerConnection::close: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! ProxyServerConnection::close: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	var integer id;
	id = socket_id;
	if (socket_id) {
		al_socket("close", socket_id, null, null);
		socket_id = null;
	} else {
	}
	if (hwnd && msg && msg2) {
		al_wnd_message(null, "msg_callback", msg, null);
		al_wnd_message(null, "msg_callback", msg2, null);
		al_wnd_message(null, "unregister_msg", msg, null);
		al_wnd_message(null, "unregister_msg", msg2, null);
		hwnd = msg = msg2 = null;
	} else {
	}
	var list connections;
	if (connections = al_src_node(this, id)) {
		al_set_dst_node(connections, id, null);
	} else {
	}
	if (conn && conn.socket_id) {
		conn.close();
		conn = null;
	} else {
	}
}
end_body
member
public: ProxyServer server;
member
public: integer socket_id;
member
public: integer hwnd;
member
public: integer msg;
member
public: integer msg2;
member
public: integer _time;
member
public: void startReceiveHeaders();
body
{
	if (msg) {
	} else {
		return;
	}
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! ProxyServerConnection::startReceiveHeaders: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! ProxyServerConnection::startReceiveHeaders: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	var list cb, buf, err;
	cb = al_list3(al_root_class(), this, ProxyServerConnection::headersReceived);
	al_wnd_message(null, "msg_callback", msg, cb);
	buffer = al_misc("binary", buffer_size, null);
	buf = al_list3(buffer, 0, buffer_size);
	if (al_socket("recv", socket_id, buf, al_list3(hwnd, msg, 2))) {
		err = (string)al_socket("get_last_error", socket_id, null, null);
		// *** server.error_log("recv error.(" + err + ")");
		close();
		return;
	} else {
	}
}
end_body
member
public: void startReceive();
body
{
	if (msg) {
	} else {
		return;
	}
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! ProxyServerConnection::startReceive: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! ProxyServerConnection::startReceive: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	var list cb, buf, err;
	cb = al_list3(al_root_class(), this, ProxyServerConnection::received);
	al_wnd_message(null, "msg_callback", msg, cb);
	buf = al_list3(buffer, 0, buffer_size);
	if (al_socket("recv", socket_id, buf, al_list2(hwnd, msg))) {
		err = (string)al_socket("get_last_error", socket_id, null, null);
		// *** server.error_log("recv error.(" + err + ")");
		close();
		return;
	} else {
	}
}
end_body
member
public: void headersReceived();
body
{
	var list err;
	var integer read_bytes;
	read_bytes = al_wnd_message(null, "lParam", null, null);
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! ProxyServerConnection::headersReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes);
		} else {
			al_print("!!! ProxyServerConnection::headersReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes + "\n");
		}
	} else {
	}
	if (read_bytes < 0) {
		err = (string)al_socket("get_last_error", socket_id, null, null);
		// *** server.error_log("recv error. (" + err + ")");
		close();
		return;
	} else {
	}
	if (send_status) {
		startReceive();
	} else {
		var string cmd_str, hdrs_str;
		var integer size;
		cmd_str = command + " " + conn.path + " " + http_ver + "\n";
		headers = al_misc("binary", read_bytes, null);
		al_misc("binary_copy", al_list2(headers, 0), al_list3(buffer, 0, read_bytes));
		if (debug2) {
			size = al_misc("binary_size", headers, null);
			hdrs_str = al_misc("binary_to_string", al_list3(headers, 0, size), null);
			if (debug_log_file && appServer) {
				appServer.log(debug_log_file, "======== Recv Proxy Request Header: proxy_server_socket_id = " + (string)socket_id + ", proxy_client_socket_id = " + (string)conn.socket_id + "\n" + cmd_str + hdrs_str);
			} else {
				al_print("======== Recv Proxy Request Header: proxy_server_socket_id = " + (string)socket_id + ", proxy_client_socket_id = " + (string)conn.socket_id + "\n" + cmd_str + hdrs_str);
			}
		} else {
		}
		headers = al_crypt("remove_header", headers, "Proxy-Connection", null);
		headers = al_crypt("add_header", headers, "Connection: Close\n", null);
		// ignore cache-control
		headers = al_crypt("remove_header", headers, "If-Modified-Since", null);
		headers = al_crypt("remove_header", headers, "If-Match", null);
		headers = al_crypt("remove_header", headers, "If-None-Match", null);
		headers = al_crypt("remove_header", headers, "If-Range", null);
		headers = al_crypt("remove_header", headers, "If-Unmodified-Since", null);
		headers = al_crypt("remove_header", headers, "Pragma", null);
		size = al_misc("binary_size", headers, null);
		hdrs_str = al_misc("binary_to_string", al_list3(headers, 0, size), null);
		if (debug2) {
			if (debug_log_file && appServer) {
				appServer.log(debug_log_file, "======== Send Proxy Request Header: proxy_server_socket_id = " + (string)socket_id + ", proxy_client_socket_id = " + (string)conn.socket_id + "\n" + cmd_str + hdrs_str);
			} else {
				al_print("======== Send Proxy Request Header: proxy_server_socket_id = " + (string)socket_id + ", proxy_client_socket_id = " + (string)conn.socket_id + "\n" + cmd_str + hdrs_str);
			}
		} else {
		}
		send_status = "proxy_response";
		if (err = conn.send(cmd_str + hdrs_str)) {
			close();
			return;
		} else {
		}
		if (err = conn.startReceiveCommand()) {
			close();
			return;
		} else {
		}
	}
}
end_body
member
public: void received();
body
{
	var list err;
	var integer read_bytes;
	read_bytes = al_wnd_message(null, "lParam", null, null);
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! ProxyServerConnection::received: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes);
		} else {
			al_print("!!! ProxyServerConnection::received: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes + "\n");
		}
	} else {
	}
	if (read_bytes < 0) {
		err = (string)al_socket("get_last_error", socket_id, null, null);
		// *** server.error_log("recv error. (" + err + ")");
		close();
		return;
	} else {
	}
	if (read_bytes > 0 && conn) {
		conn.send(buffer, 0, read_bytes);
	} else {
	}
}
end_body
member
public: integer buffer_size;
member
public: list buffer;
member
public: string command_line;
member
public: string command;
member
public: string request_url;
member
public: string path;
member
public: string http_ver;
member
public: list headers;
member
public: list send(string str);
body
{
	var integer size;
	var list binary;
	size = al_strlen(str);
	binary = al_misc("binary", size, null);
	al_misc("binary_copy", al_list2(binary, 0), str);
	return send(binary, 0, size);
}
end_body
member
public: list send(list binary);
body
{
	var integer size;
	size = al_misc("binary_size", binary, null);
	return send(binary, 0, size);
}
end_body
member
public: list send(list binary, integer index, integer size);
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! ProxyServerConnection::send: socket_id = " + (string)socket_id + ", size = " + (string)size);
		} else {
			al_print("!!! ProxyServerConnection::send: socket_id = " + (string)socket_id + ", size = " + (string)size + "\n");
		}
	} else {
	}
	var list cb, block;
	cb = al_list3(al_root_class(), this, ProxyServerConnection::sendCompleted);
	al_wnd_message(null, "msg_callback", msg2, cb);
	block = al_list3(binary, index, size);
	if (debug3) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "---- send to Browser\n" + (string)al_misc("binary_to_string", block, null));
		} else {
			al_print("---- send to Browser\n" + (string)al_misc("binary_to_string", block, null));
		}
	} else {
	}
	if (al_socket("send", socket_id, block, al_list2(hwnd, msg2))) {
		return "send error. (" + (string)al_socket("get_last_error", socket_id, null, null) + ")";
	} else {
	}
	sending = 1;
	return null;
}
end_body
member
public: void sendCompleted();
body
{
	sending = null;
	var string err;
	var integer send_bytes;
	send_bytes = al_wnd_message(null, "lParam", null, null);
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! ProxyServerConnection::sendCompleted: socket_id = " + (string)socket_id + ", send_bytes = " + (string)send_bytes);
		} else {
			al_print("!!! ProxyServerConnection::sendCompleted: socket_id = " + (string)socket_id + ", send_bytes = " + (string)send_bytes + "\n");
		}
	} else {
	}
	if (send_bytes < 0) {
		err = (string)al_socket("get_last_error", socket_id, null, null);
		// *** server.error_log("send error. (" + err + ")");
		close();
		return;
	} else {
	}
	if (exiting) {
		close();
		return;
	} else {
	}
	if (send_status == "proxy_response_200") {
		send_status = "proxy_response";
		if (err = startReceiveHeaders()) {
			close();
			return;
		} else {
		}
		_time = 0;
		return;
	} else {
	}
	if (send_status == "proxy_response") {
		if (conn && conn.socket_id) {
			if (err = conn.startReceive()) {
				close();
				return;
			} else {
			}
			return;
		} else {
		}
		_time = 0;
		return;
	} else {
	}
	close();
	return;
}
end_body
member
public: string send_status;
member
public: list exiting;
member
public: file in;
member
public: string fromIP;
member
public: ProxyClientConnection conn;
member
public: list sending;
end_class
class ProxyClientConnection
member
public: list create(ProxyServer server, string url);
body
{
	connection_debug();
	this.server = server;
	if (url == null) {
		return "url is null.";
	} else {
	}
	this.url = url;
	var integer i;
	var string head, tail;
	i = al_search_str(url, 0, "//");
	if (i < 0) {
		return "http:// or https:// required: url = " + (string)url;
	} else {
	}
	head = al_substr(url, 0, i);
	if (head == "http:") {
		ssl = null;
	} else {
		if (head == "https:") {
			ssl = 1;
		} else {
			return "http:// or https:// required: url = " + (string)url;
		}
	}
	tail = al_tail_str(url, i + 2);
	i = al_search_str(tail, 0, "/");
	if (i > 0) {
		path = al_tail_str(tail, i);
		tail = al_substr(tail, 0, i);
	} else {
		path = "/";
	}
	i = al_search_str(tail, 0, ":");
	if (i >= 0) {
		host = al_substr(tail, 0, i);
		port = (integer)al_tail_str(tail, i + 1);
	} else {
		host = tail;
		if (ssl) {
			port = 443;
		} else {
			port = 80;
		}
	}
	buffer_size = 4096;
	buffer = al_misc("binary", buffer_size, null);
	// default timeout is 60 sec (1 minutes)
	_time = 0;
	timeout = 60;
	return null;
}
end_body
member
public: ProxyServer server;
member
public: list connect();
body
{
	var integer hostaddr;
	if (socket_id = al_socket("socket", null, null, null)) {
	} else {
		return "fail to create socket";
	}
	if (hostaddr_cache) {
	} else {
		hostaddr_cache = al_cons(null, null);
	}
	if (hostaddr = al_dst_node(hostaddr_cache, host)) {
	} else {
		if (hostaddr = al_socket("gethostbyname", host, null, null)) {
		} else {
			return "fail to get hostaddr: host = " + (string)host;
		}
		al_create_arc(hostaddr_cache, hostaddr, host);
	}
	if (al_socket("connect", socket_id, al_list2(hostaddr, port), server.connect_timeout)) {
		return "fail to connect socket.(" + (string)al_socket("get_last_error", socket_id, null, null) + ")";
	} else {
	}
	hwnd = al_wnd_message(null, "hwnd", null, null);
	msg = al_wnd_message(null, "register_msg", "ProxyClntConn-" + (string)socket_id, null);
	msg2 = al_wnd_message(null, "register_msg", "ProxyClntConn2-" + (string)socket_id, null);
	if (connections) {
	} else {
		connections = al_cons(null, null);
	}
	al_create_arc(connections, this, socket_id);
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! ProxyClientConnection::create: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! ProxyClientConnection::create: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	return null;
}
end_body
member
public: void close();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! ProxyClientConnection::close: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! ProxyClientConnection::close: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	var integer id;
	id = socket_id;
	if (socket_id) {
		al_socket("close", socket_id, null, null);
		socket_id = null;
	} else {
	}
	if (hwnd && msg && msg2) {
		al_wnd_message(null, "msg_callback", msg, null);
		al_wnd_message(null, "msg_callback", msg2, null);
		al_wnd_message(null, "unregister_msg", msg, null);
		al_wnd_message(null, "unregister_msg", msg2, null);
		hwnd = msg = msg2 = null;
	} else {
	}
	var list conns;
	if (conns = al_src_node(this, id)) {
		al_set_dst_node(conns, id, null);
	} else {
	}
	conn = null;
}
end_body
member
public: string url;
member
public: list ssl;
member
public: string host;
member
public: integer port;
member
public: string path;
member
public: integer socket_id;
member
public: integer hwnd;
member
public: integer msg;
member
public: integer msg2;
member
public: integer _time;
member
public: void setTimeout(integer sec);
body
{
	timeout = sec;
}
end_body
member
public: integer timeout;
member
public: list send(string str);
body
{
	var integer size;
	var list binary;
	size = al_strlen(str);
	binary = al_misc("binary", size, null);
	al_misc("binary_copy", al_list2(binary, 0), str);
	return send(binary, 0, size);
}
end_body
member
public: list send(list binary);
body
{
	var integer size;
	size = al_misc("binary_size", binary, null);
	return send(binary, 0, size);
}
end_body
member
public: list send(list binary, integer index, integer size);
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! ProxyClientConnection::send: socket_id = " + (string)socket_id + ", size = " + (string)size);
		} else {
			al_print("!!! ProxyClientConnection::send: socket_id = " + (string)socket_id + ", size = " + (string)size + "\n");
		}
	} else {
	}
	var list cb, block;
	cb = al_list3(al_root_class(), this, ProxyClientConnection::sendCompleted);
	al_wnd_message(null, "msg_callback", msg2, cb);
	block = al_list3(binary, index, size);
	if (debug3) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "---- send to Server\n" + (string)al_misc("binary_to_string", block, null));
		} else {
			al_print("---- send to Server\n" + (string)al_misc("binary_to_string", block, null));
		}
	} else {
	}
	if (al_socket("send", socket_id, block, al_list2(hwnd, msg2))) {
		return "send error. (" + (string)al_socket("get_last_error", socket_id, null, null) + ")";
	} else {
	}
	return null;
}
end_body
member
public: void sendCompleted();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! ProxyClientConnection::sendCompleted: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! ProxyClientConnection::sendCompleted: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	if (conn) {
		conn.startReceive();
	} else {
	}
}
end_body
member
public: list startReceiveCommand();
body
{
	if (msg) {
	} else {
		return "already closed.";
	}
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! ProxyClientConnection::startReceiveCommand: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! ProxyClientConnection::startReceiveCommand: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	var list cb, buf, err;
	cb = al_list3(al_root_class(), this, ProxyClientConnection::commandReceived);
	al_wnd_message(null, "msg_callback", msg, cb);
	buffer = al_misc("binary", buffer_size, null);
	buf = al_list3(buffer, 0, buffer_size);
	if (al_socket("recv", socket_id, buf, al_list3(hwnd, msg, 1))) {
		err = (string)al_socket("get_last_error", socket_id, null, null);
		err = "recv error.(" + err + ")";
		// *** server.error_log(err);
		close();
		return err;
	} else {
	}
	return null;
}
end_body
member
public: list startReceiveHeaders();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! ProxyClientConnection::startReceiveHeaders: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! ProxyClientConnection::startReceiveHeaders: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	var list cb, buf, err;
	cb = al_list3(al_root_class(), this, ProxyClientConnection::headersReceived);
	al_wnd_message(null, "msg_callback", msg, cb);
	buf = al_list3(buffer, 0, buffer_size);
	if (al_socket("recv", socket_id, buf, al_list3(hwnd, msg, 2))) {
		err = (string)al_socket("get_last_error", socket_id, null, null);
		err = "recv error. (" + err + ")";
		// *** server.error_log(err);
		return err;
	} else {
	}
	return null;
}
end_body
member
public: list startReceive();
body
{
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! ProxyClientConnection::startReceive: socket_id = " + (string)socket_id);
		} else {
			al_print("!!! ProxyClientConnection::startReceive: socket_id = " + (string)socket_id + "\n");
		}
	} else {
	}
	var list cb, buf, err;
	cb = al_list3(al_root_class(), this, ProxyClientConnection::received);
	al_wnd_message(null, "msg_callback", msg, cb);
	buf = al_list3(buffer, 0, buffer_size);
	if (al_socket("recv", socket_id, buf, al_list2(hwnd, msg))) {
		err = (string)al_socket("get_last_error", socket_id, null, null);
		// *** server.error_log("recv error.(" + err + ")");
		close();
		return err;
	} else {
	}
	return null;
}
end_body
member
public: void commandReceived();
body
{
	var list err;
	var integer read_bytes;
	read_bytes = al_wnd_message(null, "lParam", null, null);
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! ProxyClientConnection::commandReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes);
		} else {
			al_print("!!! ProxyClientConnection::commandReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes + "\n");
		}
	} else {
	}
	if (read_bytes < 0) {
		err = (string)al_socket("get_last_error", socket_id, null, null);
		// *** server.error_log("recv error. (" + err + ")");
		close();
		return;
	} else {
	}
	if (al_misc("get_byte", al_list2(buffer, read_bytes - 1), null) == '\r') {
		command_line = al_misc("binary_to_string", al_list3(buffer, 0, read_bytes - 1), null);
	} else {
		command_line = al_misc("binary_to_string", al_list3(buffer, 0, read_bytes), null);
	}
	startReceiveHeaders();
}
end_body
member
public: void headersReceived();
body
{
	if (socket_id) {
	} else {
		return;
	}
	var list err;
	var integer read_bytes;
	read_bytes = al_wnd_message(null, "lParam", null, null);
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! ProxyClientConnection::headersReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes);
		} else {
			al_print("!!! ProxyClientConnection::headersReceived: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes + "\n");
		}
	} else {
	}
	if (read_bytes < 0) {
		err = (string)al_socket("get_last_error", socket_id, null, null);
		// *** server.error_log("recv error. (" + err + ")");
		close();
		return;
	} else {
	}
	var string cmd_str, hdrs_str;
	var integer size;
	cmd_str = command_line + "\n";
	headers = al_misc("binary", read_bytes, null);
	al_misc("binary_copy", al_list2(headers, 0), al_list3(buffer, 0, read_bytes));
	if (debug2) {
		size = al_misc("binary_size", headers, null);
		hdrs_str = al_misc("binary_to_string", al_list3(headers, 0, size), null);
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "======== Recv Proxy Response Header: proxy_server_socket_id = " + (string)conn.socket_id + ", proxy_client_socket_id = " + (string)socket_id + "\n" + cmd_str + hdrs_str);
		} else {
			al_print("======== Recv Proxy Response Header: proxy_server_socket_id = " + (string)conn.socket_id + ", proxy_client_socket_id = " + (string)socket_id + "\n" + cmd_str + hdrs_str);
		}
	} else {
	}
	headers = al_crypt("remove_header", headers, "Connection", null);
	headers = al_crypt("add_header", headers, "Proxy-Connection: Close\n", null);
	// ignore cache control
	headers = al_crypt("remove_header", headers, "Cache-Control", null);
	headers = al_crypt("remove_header", headers, "ETag", null);
	if (content_length = al_crypt("get_header", headers, "Content-Length", null)) {
		content_length = (integer)content_length;
		if (debug2) {
			if (debug_log_file && appServer) {
				appServer.log(debug_log_file, "Content-Length = " + (string)content_length + "\n");
			} else {
				al_print("Content-Length = " + (string)content_length + "\n");
			}
		} else {
		}
		if (content_length < 0) {
			close();
			return;
		} else {
		}
		total_read_bytes = 0;
	} else {
	}
	size = al_misc("binary_size", headers, null);
	hdrs_str = al_misc("binary_to_string", al_list3(headers, 0, size), null);
	if (debug2) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "======== Send Proxy Response Header: proxy_server_socket_id = " + (string)conn.socket_id + ", proxy_client_socket_id = " + (string)socket_id + "\n" + cmd_str + hdrs_str);
		} else {
			al_print("======== Send Proxy Response Header: proxy_server_socket_id = " + (string)conn.socket_id + ", proxy_client_socket_id = " + (string)socket_id + "\n" + cmd_str + hdrs_str);
		}
	} else {
	}
	if (err = conn.send(cmd_str + hdrs_str)) {
		close();
		return;
	} else {
	}
}
end_body
member
public: void received();
body
{
	var list err;
	var integer read_bytes;
	read_bytes = al_wnd_message(null, "lParam", null, null);
	if (debug) {
		if (debug_log_file && appServer) {
			appServer.log(debug_log_file, "!!! ProxyClientConnection::received: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes);
		} else {
			al_print("!!! ProxyClientConnection::received: socket_id = " + (string)socket_id + ", read_bytes = " + (string)read_bytes + "\n");
		}
	} else {
	}
	if (read_bytes <= 0) {
		err = (string)al_socket("get_last_error", socket_id, null, null);
		if (conn && conn.sending == null) {
			conn.close();
		} else {
			close();
		}
		return;
	} else {
	}
	if (read_bytes > 0 && conn) {
		if (content_length) {
			total_read_bytes = total_read_bytes + read_bytes;
			if (total_read_bytes >= content_length) {
				conn.exiting = 1;
			} else {
			}
		} else {
		}
		conn.send(buffer, 0, read_bytes);
	} else {
	}
}
end_body
member
public: list error;
member
public: integer buffer_size;
member
public: list buffer;
member
public: string command_line;
member
public: list headers;
member
public: integer content_length;
member
public: integer total_read_bytes;
member
public: static list connections;
member
public: ProxyServerConnection conn;
member
public: static list hostaddr_cache;
end_class
end_class
class XmlUtility
member
public: static void Initialize();
body
{
	if (init) {
		return;
	} else {
	}
	var list bin;
	bin = al_misc("binary", 1, null);
	al_misc("put_byte", al_list2(bin, 0), 0x0000000000000001);
	ctrl_a = al_misc("binary_to_string", al_list3(bin, 0, 1), null);
	dtd_base = ".";
	content_validation_base = ".";
	XmlDbObject::MAX_VALUE_SIZE = 3000;
	init = 1;
}
end_body
member
public: static list init;
member
public: static string ctrl_a;
member
public: static list parseXML(string xml, list debug);
body
{
	var file in;
	in = al_file_open(xml, "sr");
	return parseXML(in, debug);
}
end_body
member
public: static list parseXML(file in, list debug);
body
{
	var list tree_error, opt, err;
	opt = (debug ? 1 : null);
	tree_error = al_xml("parse", in, null, opt);
	if (err = tree_error.tail.head) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "xml: parse error: " + (string)err;
		throw ex;
	} else {
	}
	return tree_error.head;
}
end_body
member
public: static list parseXML(string filename);
body
{
	var file in;
	if (in = al_file_open(filename, "r")) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "xml: can't open file '" + (string)filename + "'";
		throw ex;
	}
	return parseXML(in, null);
}
end_body
member
public: static string xslTransform(string xsl_filename, list xml);
body
{
	var list xsl, str, err;
	var file f;
	xsl = loadXSL(xsl_filename);
	str = al_copy("");
	f = al_file_open(str, "sw");
	err = al_xml("xslt", xsl, xml, f);
	if (err) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "xsl transform error: reason=" + al_str_misc("xml_encode", (string)err, 0x0000000000000001);
		throw ex;
	} else {
	}
	var integer idx;
	idx = al_search_str(str, 0, "\n");
	str = al_tail_str(str, idx + 1);
	return str;
}
end_body
member
public: static string getDocType(list parse_tree);
body
{
	var list tree_itr;
	var string text, attr, str;
	var file f;
	tree_itr = al_dst_itr(parse_tree);
	loop {
		if (text = al_next(tree_itr)) {
		} else {
			return null;
		}
		attr = al_arc_a(tree_itr);
		if (attr != "!comment") {
			return null;
		} else {
		}
		f = al_file_open(text, "sr");
		if (al_file_match_str(f, "!DOCTYPE")) {
		} else {
			continue;
		}
		return al_file_read(f, "string");
	}
}
end_body
member
public: static string getDTDfile(list parse_tree);
body
{
	var list tree_itr;
	var string text, attr, str;
	var file f;
	tree_itr = al_dst_itr(parse_tree);
	loop {
		if (text = al_next(tree_itr)) {
		} else {
			return null;
		}
		attr = al_arc_a(tree_itr);
		if (attr != "!comment") {
			return null;
		} else {
		}
		f = al_file_open(text, "sr");
		if (al_file_match_str(f, "!DOCTYPE")) {
		} else {
			continue;
		}
		loop {
			if (str = al_file_read(f, "string")) {
			} else {
				return null;
			}
			if (str == "SYSTEM") {
				return al_file_read(f, "quote_string");
			} else {
			}
		}
	}
}
end_body
member
public: static list loadDTD(string filename);
body
{
	if (dtd_cache) {
	} else {
		dtd_cache = al_cons(null, null);
	}
	var list ret;
	if (ret = al_dst_node(dtd_cache, filename)) {
		return ret;
	} else {
	}
	var DtdLoader loader;
	var file in, out;
	var list err;
	var string tmp_file;
	loader = new ExtendedDtdLoader;
	loader.log_level = 20;
	loop {
		if (in = al_file_open(filename, "r")) {
		} else {
			err = "can't open DTD file \"" + filename + "\"";
			break;
		}
		if (err = loader.read_entities(in)) {
			break;
		} else {
		}
		if (tmp_file = FileUtility::tempFile()) {
		} else {
			err = "can't get temp file name";
			break;
		}
		if (in = al_file_open(filename, "r")) {
		} else {
			err = "can't open DTD file \"" + filename + "\"";
			break;
		}
		if (out = al_file_open(tmp_file, "w")) {
		} else {
			err = "can't open temp file \"" + tmp_file + "\"";
			break;
		}
		if (err = loader.apply_entities(in, out)) {
			break;
		} else {
		}
		in = out = null;
		if (in = al_file_open(tmp_file, "r")) {
		} else {
			err = "can't open temp file \"" + tmp_file + "\"";
			break;
		}
		if (err = loader.read_element(in)) {
			break;
		} else {
		}
		in = null;
		if (in = al_file_open(tmp_file, "r")) {
		} else {
			err = "can't open temp file \"" + tmp_file + "\"";
			break;
		}
		if (err = loader.elem_attr(in)) {
			break;
		} else {
		}
		in = null;
		break;
	}
	in = out = null;
	if (tmp_file) {
		al_file_manip("remove", tmp_file, null);
	} else {
	}
	if (err) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "xml: " + (string)err;
		throw ex;
	} else {
	}
	ret = loader.root_elem;
	al_set_dst_node(dtd_cache, filename, ret);
	return ret;
}
end_body
member
public: static list loadXmlSchema(string filename);
body
{
	if (dtd_cache) {
	} else {
		dtd_cache = al_cons(null, null);
	}
	var list ret;
	if (ret = al_dst_node(dtd_cache, filename)) {
		return ret;
	} else {
	}
	var XmlSchemaLoader loader;
}
end_body
member
public: static list loadXSL(string filename);
body
{
	if (xsl_cache) {
	} else {
		xsl_cache = al_cons(null, null);
	}
	var list ret;
	if (ret = al_dst_node(xsl_cache, filename)) {
		return ret;
	} else {
	}
	ret = parseXML(filename);
	al_set_dst_node(xsl_cache, filename, ret);
	return ret;
}
end_body
member
public: static void validateXML(list dtd, list parse_tree);
body
{
	var XmlValidator validator;
	var list err;
	validator = new XmlValidator;
	if (err = validator.validate(dtd, parse_tree)) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "xml: validation error: " + (string)err;
		throw ex;
	} else {
	}
}
end_body
member
public: static string dtd_base;
member
public: static string xsl_base;
member
public: static string content_validation_base;
member
public: static list dtd_cache;
member
public: static list xsl_cache;
member
public: static XmlDbObject createMsgData(string msgId, string msgType, string msgVersion, string dtdFilename, DbConnection conn);
body
{
	var XmlDbAccessor acc;
	var XmlDbObject obj;
	acc = new XmlDbAccessor;
	acc.create(msgType, msgVersion, conn);
	acc.setDTDfilename(dtdFilename);
	if (msgId) {
	} else {
		msgId = Context::genMsgId();
	}
	obj = acc.create(msgId);
	return obj;
}
end_body
member
public: static XmlDbObject getMsgData(string msgId, string msgType, string msgVersion, string dtdFilename, DbConnection conn);
body
{
	var XmlDbAccessor acc;
	var XmlDbObject obj;
	acc = new XmlDbAccessor;
	acc.create(msgType, msgVersion, conn);
	acc.setDTDfilename(dtdFilename);
	obj = acc.get(msgId);
	return obj;
}
end_body
member
public: list isLike(string value);
body
{
	var integer len, ch1, ch2;
	len = al_strlen(value);
	if (len > 2) {
	} else {
		return null;
	}
	ch1 = al_get_char(value, 0);
	ch2 = al_get_char(value, len - 1);
	if (ch1 == '%' && ch2 == '%') {
		return al_substr(value, 1, len - 1);
	} else {
		return null;
	}
}
end_body
member
public: void skip_optional();
body
{
	var integer count;
	var string type;
	count = 1;
	loop {
		type = dtd_itr.Next((list)1);
		if (type == "end") {
			printStackTrace();
			al_print("%%% end appears during finding end_optional.\n");
			break;
		} else {
		}
		if (type == "optional") {
			count = count + 1;
		} else {
		}
		if (type == "end_optional") {
			count = count - 1;
			if (count == 0) {
				break;
			} else {
			}
		} else {
		}
	}
}
end_body
member
public: void skip_choice();
body
{
	var integer count;
	var string type;
	count = 1;
	loop {
		type = dtd_itr.Next((list)1);
		if (type == "end") {
			al_print("%%% end appears during finding end_choice.\n");
			break;
		} else {
		}
		if (type == "choice") {
			count = count + 1;
			continue;
		} else {
		}
		if (type == "end_choice") {
			count = count - 1;
			if (count == 0) {
				break;
			} else {
			}
		} else {
		}
	}
}
end_body
member
public: void skip_case();
body
{
	var integer count;
	var string type;
	count = 1;
	loop {
		type = dtd_itr.Next((list)1);
		if (type == "end") {
			al_print("%%% end appears during finding end_case.\n");
			break;
		} else {
		}
		if (type == "choice") {
			skip_choice();
		} else {
		}
		if (type == "case") {
			count = count + 1;
			continue;
		} else {
		}
		if (type == "end_case") {
			count = count - 1;
			if (count == 0) {
				break;
			} else {
			}
		} else {
		}
	}
}
end_body
member
public: void skip_all_opt();
body
{
	var integer count;
	var string type;
	count = 1;
	loop {
		type = dtd_itr.Next((list)1);
		if (type == "end") {
			al_print("%%% end appears during finding end_all_opt.\n");
			break;
		} else {
		}
		if (type == "all_opt") {
			count = count + 1;
		} else {
		}
		if (type == "end_all_opt") {
			count = count - 1;
			if (count == 0) {
				break;
			} else {
			}
		} else {
		}
	}
}
end_body
member
public: DtdItr dtd_itr;
member
public: list content_validate;
member
public: string validation_errors;
member
public: static list content_validation_report;
class XmlSchemaLoader
end_class
class DtdLoader
member
public: list read_entities(file in);
body
{
	entities = al_cons(null, null);
	var string str, name, value, name2, value2;
	var integer ch;
	loop {
		if (al_file_match_str(in, "<")) {
		} else {
			if (str = al_file_read(in, "xident")) {
				error_log("unexpected string '" + str + "'");
				return "unexpected string '" + str + "'";
			} else {
			}
			return null;
		}
		al_file_manip("unput", in, 1);
		if (al_file_match_str(in, "<!ENTITY")) {
			if (al_file_match_str(in, "%")) {
			} else {
				warning_log("not found '%' after \"<!ENTITY\".");
				if (al_file_read(in, al_list2("find", '>'))) {
				} else {
					error_log("unexpected EOF (1)");
					return "unexpected EOF (1)";
				}
				continue;
			}
			if (name = al_file_read(in, "string")) {
			} else {
				error_log("entity_name expected.");
				return "entity_name expected.";
			}
			info_log("entity: " + name);
			if (value = al_file_read(in, "quote_string") || value = al_file_read(in, "single_quote_string")) {
				var file in2;
				var string value_ref;
				value_ref = value;
				in2 = al_file_open(value, "sr");
				value = al_copy("");
				loop {
					ch = al_file_read(in2, "char");
					if (ch ==  - 1) {
						break;
					} else {
					}
					if (ch != '%') {
						al_append_str(value, ch);
					} else {
						if (name2 = al_file_read(in2, "xident")) {
						} else {
							error_log("sub-entity_name expected.");
							return "sub-entity_name expected.";
						}
						info_log("sub-entity: " + name2);
						if (al_file_match_str(in2, ";")) {
						} else {
							error_log("';' expected after'" + name2 + "'.");
							return "';' expected after'" + name2 + "'.";
						}
						if (value2 = al_dst_node(entities, name2)) {
						} else {
							error_log("entity " + name2 + "not found.(in entity " + name + ")");
							return "entity " + name2 + "not found.(in entity " + name + ")";
						}
						al_append_str(value, value2);
					}
				}
			} else {
				error_log("entity_value expected. (entity " + name + ")");
				return "entity_value expected. (entity " + name + ")";
			}
			al_create_arc(entities, value, name);
			info_log("value: " + value);
			if (al_file_match_str(in, ">")) {
			} else {
				error_log("'>' expected.");
				return "'>' expected.";
			}
			continue;
		} else {
		}
		if (al_file_match_str(in, "<!--")) {
			if (al_file_read(in, al_list2("find", "-->"))) {
			} else {
				error_log("unexpected EOF (2)");
				return "unexpected EOF (2)";
			}
			continue;
		} else {
		}
		if (al_file_match_str(in, "<?")) {
			if (al_file_read(in, al_list2("find", "?>"))) {
			} else {
				error_log("unexpected EOF (3)");
				return "unexpected EOF (3)";
			}
			continue;
		} else {
		}
		if (al_file_match_str(in, "<!")) {
			if (al_file_read(in, al_list2("find", ">"))) {
			} else {
				error_log("unexpected EOF (4)");
				return "unexpected EOF (4)";
			}
			continue;
		} else {
		}
	}
}
end_body
member
public: list apply_entities(file in, file out);
body
{
	var string str, name, value;
	var integer pos, ch;
	loop {
		if (al_file_match_str(in, "<")) {
		} else {
			if (str = al_file_read(in, "string")) {
				error_log("unexpected string '" + str + "'");
				return "unexpected string '" + str + "'";
			} else {
			}
			return null;
		}
		al_file_manip("unput", in, 1);
		if (al_file_match_str(in, "<!ENTITY")) {
			if (al_file_read(in, al_list2("find", '>'))) {
			} else {
				error_log("unexpected EOF (5)");
				return "unexpected EOF (5)";
			}
			continue;
		} else {
		}
		if (al_file_match_str(in, "<!--")) {
			if (al_file_read(in, al_list2("find", "-->"))) {
			} else {
				error_log("unexpected EOF (6)");
				return "unexpected EOF (6)";
			}
			continue;
		} else {
		}
		if (al_file_match_str(in, "<!NOTATION")) {
			if (al_file_read(in, al_list2("find", ">"))) {
			} else {
				error_log("unexpected EOF (7)");
				return "unexpected EOF (7)";
			}
			continue;
		} else {
		}
		if (al_file_match_str(in, "<!")) {
			str = al_copy("<!");
			loop {
				pos = al_file_manip("curr_pos", in, null);
				if (al_file_match_str(in, ">")) {
					al_append_str(str, ">\n");
					al_file_write(out, "string", str);
					break;
				} else {
				}
				al_file_manip("back", in, pos);
				ch = al_file_read(in, "char");
				if (ch != '%') {
					al_append_str(str, ch);
				} else {
					if (name = al_file_read(in, "xident")) {
					} else {
						error_log("not found entity name");
						return "not found entity name";
					}
					if (value = al_dst_node(entities, name)) {
					} else {
						error_log("not found entity '" + name + "'");
						return "not found entity '" + name + "'";
					}
					if (al_file_match_str(in, ";")) {
					} else {
						error_log("';' expected after'" + name + "'.");
						return "';' expected after'" + name + "'.";
					}
					al_append_str(str, value);
					al_append_str(str, ' ');
				}
			}
			continue;
		} else {
		}
		if (al_file_match_str(in, "<?")) {
			if (al_file_read(in, al_list2("find", "?>"))) {
			} else {
				error_log("unexpected EOF (8)");
				return "unexpected EOF (8)";
			}
			continue;
		} else {
		}
	}
}
end_body
member
public: list entities;
member
public: list read_element(file in);
body
{
	var string tag, str;
	var list elem;
	elems = al_cons(null, null);
	loop {
		if (al_file_match_str(in, "<!ELEMENT")) {
			if (tag = al_file_read(in, "xident")) {
			} else {
				error_log("element tag name expected.");
				return "element tag name expected.";
			}
			info_log("element tag: " + tag);
			if (elem = al_dst_node(elems, tag)) {
			} else {
				elem = al_list5("elem", null, tag, "", null);
				al_create_arc(elems, elem, tag);
			}
			if (al_file_read(in, al_list2("find", ">"))) {
			} else {
				error_log("unexpected EOF (9)");
				return "unexpected EOF (9)";
			}
			continue;
		} else {
		}
		if (al_file_match_str(in, "<!ATTLIST")) {
			if (al_file_read(in, al_list2("find", ">"))) {
			} else {
				error_log("unexpected EOF (10)");
				return "unexpected EOF (10)";
			}
			continue;
		} else {
		}
		if (str = al_file_read(in, "string")) {
			error_log("unexpected token'" + str + "'");
			return "unexpected token'" + str + "'";
		} else {
		}
		return null;
	}
}
end_body
member
public: list elems;
member
public: list root_elem;
member
public: list elem_attr(file in);
body
{
	var string tag, str;
	var list elem, elem2, itr, tags, all_opt;
	loop {
		if (al_file_match_str(in, "<!ELEMENT")) {
			if (tag = al_file_read(in, "xident")) {
			} else {
				error_log("element tag name expected.");
				return "element tag name expected.";
			}
			info_log("element tag: " + tag);
			if (elem = al_dst_node(elems, tag)) {
			} else {
				error_log("element tag '" + tag + "' not found.");
				return "element tag '" + tag + "' not found.";
			}
			if (elem2 = load_elem(in)) {
				al_create_arc(elem, elem2, null);
			} else {
				error_log("element definition of tag name '" + tag + "' is illegal.");
				return "element definition of tag name '" + tag + "' is illegal.";
			}
			if (al_file_match_str(in, ">")) {
			} else {
				error_log("'>' expected at !ELEMENT (tag = " + tag + ").");
				return "'>' expected at !ELEMENT (tag = " + tag + ").";
			}
			continue;
		} else {
		}
		if (al_file_match_str(in, "<!ATTLIST")) {
			if (tag = al_file_read(in, "xident")) {
			} else {
				error_log("attlist tag name expected.");
				return "attlist tag name expected.";
			}
			info_log("attlist tag: " + tag);
			if (elem = al_dst_node(elems, tag)) {
			} else {
				error_log("attlist tag '" + tag + "' not found.");
				return "attlist tag '" + tag + "' not found.";
			}
			if (add_attr(elem, in)) {
				error_log("attr definition of tag name '" + tag + "' is illegal.");
				return "attr definition of tag name '" + tag + "' is illegal.";
			} else {
			}
			if (al_file_match_str(in, ">")) {
			} else {
				error_log("'>' expected at !ATTLIST (tag = " + tag + ").");
				return "'>' expected at !ATTLIST (tag = " + tag + ").";
			}
			continue;
		} else {
		}
		if (str = al_file_read(in, "string")) {
			error_log("unexpected token'" + str + "'");
			return "unexpected token'" + str + "'";
		} else {
		}
		itr = al_dst_itr(elems);
		root_elem = al_next(itr);
		normalize();
		elems = null;
		tags = al_cons(null, null);
		check_recursive(root_elem, tags);
		return null;
	}
}
end_body
member
public: list load_elem(file in);
body
{
	var list elem, elem2;
	if (elem = load_elem1(in)) {
	} else {
		error_log("<elem1> expected.");
		return null;
	}
	if (al_file_match_str(in, "?")) {
		elem.tail.tail.tail.head = "?";
		return elem;
	} else {
	}
	if (al_file_match_str(in, "*")) {
		elem.tail.tail.tail.head = "*";
		return elem;
	} else {
	}
	if (al_file_match_str(in, "+")) {
		elem.tail.tail.tail.head = "+";
		return elem;
	} else {
	}
	return elem;
}
end_body
member
public: list load_elem1(file in);
body
{
	var list elem, elem2, opt;
	if (al_file_match_str(in, "(")) {
		elem = al_list5("elem", null, null, "", 1);
		loop {
			if (elem2 = load_elem(in)) {
			} else {
				error_log("<elem> expected.");
				return null;
			}
			if (elem2.head == "elem") {
				if (elem2.tail.tail.head) {
					// elem_tag
					opt = elem2.tail.tail.tail.head;
					if (opt == "?" || opt == "*") {
					} else {
						elem.tail.tail.tail.tail.head = null;
					}
				} else {
					// not elem tag
					if (elem2.tail.tail.tail.tail.head) {
					} else {
						elem.tail.tail.tail.tail.head = null;
					}
				}
			} else {
			}
			if (al_file_match_str(in, ")")) {
				if (elem.tail.head == null) {
					elem.tail.head = ",";
				} else {
				}
				if (elem.tail.head == "|") {
					var list elem3;
					elem3 = al_list5(null, null, null, null, null);
					al_create_arc(elem, elem3, null);
					al_create_arc(elem3, elem2, null);
				} else {
					al_create_arc(elem, elem2, null);
				}
				return elem;
			} else {
			}
			if (elem.tail.head) {
				if (al_file_match_str(in, elem.tail.head)) {
					if (elem.tail.head == "|") {
						var list elem3;
						elem3 = al_list5(null, null, null, null, null);
						al_create_arc(elem, elem3, null);
						al_create_arc(elem3, elem2, null);
					} else {
						al_create_arc(elem, elem2, null);
					}
					continue;
				} else {
					error_log("'" + elem.tail.head + "' expected.");
					return null;
				}
			} else {
				if (al_file_match_str(in, "|")) {
					elem.tail.head = "|";
					var list elem3;
					elem3 = al_list5(null, null, null, null, null);
					al_create_arc(elem, elem3, null);
					al_create_arc(elem3, elem2, null);
					continue;
				} else {
				}
				if (al_file_match_str(in, ",")) {
					elem.tail.head = ",";
					al_create_arc(elem, elem2, null);
					continue;
				} else {
				}
			}
		}
	} else {
		if (elem2 = load_elem2(in)) {
			return elem2;
		} else {
			error_log("<elem2> expected.");
			return null;
		}
	}
}
end_body
member
public: list load_elem2(file in);
body
{
	var list elem;
	if (elem = load_elem_empty_any(in)) {
		return elem;
	} else {
	}
	if (elem = load_elem_tag(in)) {
		return elem;
	} else {
	}
	if (elem = load_elem_data(in)) {
		return elem;
	} else {
	}
	return null;
}
end_body
member
public: list load_elem_tag(file in);
body
{
	var list tag, elem, elem2;
	if (tag = al_file_read(in, "xident")) {
		if (elem = al_dst_node(elems, tag)) {
			elem2 = al_list_misc("copy", elem, null);
			al_create_arc(elem, elem2, "$refer");
			return elem2;
		} else {
			error_log("element not found (tag = '" + tag + ").");
			return null;
		}
	} else {
		return null;
	}
}
end_body
member
public: list load_elem_empty_any(file in);
body
{
	var list ident;
	var integer pos;
	pos = al_file_manip("curr_pos", in, null);
	if (ident = al_file_read(in, "ident")) {
		if (ident == "EMPTY" || ident == "ANY") {
			return al_list5("elem", ident, null, "", null);
		} else {
		}
		al_file_manip("back", in, pos);
	} else {
	}
	return null;
}
end_body
member
public: list load_elem_data(file in);
body
{
	if (al_file_match_str(in, "#PCDATA")) {
		return al_list5("elem", "#PCDATA", null, "", null);
	} else {
	}
	return null;
}
end_body
member
public: list add_attr(list elem, file in);
body
{
	var list name, kind, type, default_value;
	loop {
		if (name = al_file_read(in, "xident")) {
		} else {
			return null;
		}
		if (al_file_match_str(in, "(")) {
			var list tag;
			kind = load_attr_choice(in);
			if (al_file_match_str(in, ")")) {
			} else {
				error_log("')' expected at attribute kind.");
				return "')' expected at attribute kind.";
			}
		} else {
			if (kind = al_file_read(in, "string")) {
			} else {
				error_log("attribute kind expected.");
				return "attribute kind expected.";
			}
		}
		if (al_file_match_str(in, "#")) {
			if (type = al_file_read(in, "ident")) {
			} else {
				error_log("attribute type expected.");
				return "attribute type expected.";
			}
			type = "#" + type;
		} else {
			if (type = al_file_read(in, "single_quote_string")) {
			} else {
				if (type = al_file_read(in, "quote_string")) {
				} else {
					error_log("attribute type expected.");
					return "attribute type expected.";
				}
			}
		}
		if (type == "#FIXED") {
			if (default_value = al_file_read(in, "quote_string")) {
			} else {
				error_log("attribute default_value expected.");
				return "attribute default_value expected.";
			}
		} else {
		}
		var list attr;
		attr = al_list5("attr", name, kind, type, default_value);
		al_create_arc(elem, attr, "attr");
	}
}
end_body
member
public: list attr;
member
public: list load_attr_choice(file in);
body
{
	var list kind;
	var string value;
	kind = al_cons("|", null);
	loop {
		if (value = al_file_read(in, "xident")) {
			al_create_arc(kind, al_cons(null, null), value);
		} else {
			return kind;
		}
		if (al_file_match_str(in, "|")) {
			continue;
		} else {
			return kind;
		}
	}
}
end_body
member
public: void normalize();
body
{
	var list itr, elem, itr2, elem2, itr3, dst, attr, opt, all_opt;
	itr = al_dst_itr(elems);
	loop {
		if (elem = al_next(itr)) {
		} else {
			break;
		}
		{
			all_opt = 1;
			itr3 = al_dst_itr(elem);
			loop {
				if (dst = al_next(itr3)) {
				} else {
					break;
				}
				attr = al_arc_a(itr3);
				if (al_is_type(attr, "string") && al_strlen(attr) > 0 && al_get_char(attr, 0) == '$') {
					continue;
				} else {
				}
				if (dst.head == "elem") {
					if (dst.tail.tail.head) {
						// elem tag
						opt = dst.tail.tail.tail.head;
						if (opt == "?" || opt == "*") {
						} else {
							all_opt = null;
						}
					} else {
						// not elem tag
						if (dst.tail.tail.tail.tail.head) {
						} else {
							all_opt = null;
						}
					}
				} else {
				}
			}
			elem.tail.tail.tail.tail.head = all_opt;
		}
		itr2 = al_dst_itr(elem);
		loop {
			if (elem2 = al_next_a(itr2, "$refer")) {
			} else {
				break;
			}
			elem2.tail.tail.tail.tail.head = all_opt;
			itr3 = al_dst_itr(elem);
			loop {
				if (dst = al_next(itr3)) {
				} else {
					break;
				}
				attr = al_arc_a(itr3);
				if (attr == "$refer") {
					continue;
				} else {
				}
				al_create_arc(elem2, dst, attr);
			}
			al_remove(itr2);
		}
	}
}
end_body
member
public: list check_recursive(list elem, list tags);
body
{
	var string tag;
	var list recursive, itr, elem2, ret;
	if (elem.head == "elem") {
		if (tag = elem.tail.tail.head) {
			if (al_dst_node(tags, tag)) {
				recursive = 1;
			} else {
			}
		} else {
		}
	} else {
	}
	if (recursive) {
		al_set_dst_node(elem, "$recursive", 0);
		return tag;
	} else {
	}
	al_create_arc(tags = al_copy(tags), 0, tag);
	itr = al_dst_itr(elem);
	loop {
		if (elem2 = al_next_a(itr, null)) {
		} else {
			break;
		}
		if (al_dst_node(elem2, "$recursive")) {
			continue;
		} else {
		}
		var list tag2;
		if (tag2 = check_recursive(elem2, tags)) {
			if (ret) {
			} else {
				ret = al_cons(null, null);
			}
			al_create_arc(ret, tag2, tag2);
		} else {
			if (data_duplicate) {
				al_arc_dst(itr, al_copy(elem2));
			} else {
			}
		}
	}
	if (al_dst_node(elem, "$recursive") != 0) {
		if (ret) {
			if (tag = elem.tail.tail.head) {
				if (check_recursive(ret, tag)) {
					al_set_dst_node(elem, "$recursive", 1);
				} else {
					al_set_dst_node(elem, "$recursive", 2);
				}
			} else {
				al_set_dst_node(elem, "$recursive", 2);
			}
		} else {
		}
	} else {
	}
	return ret;
}
end_body
member
public: list check_recursive(list ret, string tag);
body
{
	if (al_is_type(ret, "string")) {
		if (tag == ret) {
			return 1;
		} else {
			return null;
		}
	} else {
	}
	var list itr, ret2;
	itr = al_dst_itr(ret);
	loop {
		if (ret2 = al_next(itr)) {
		} else {
			break;
		}
		if (check_recursive(ret2, tag)) {
			return 1;
		} else {
		}
	}
	return null;
}
end_body
member
public: list data_duplicate;
member
public: void error_log(string s);
body
{
	if (log_level >= 10) {
		al_print("[Error] " + s + "\n");
	} else {
	}
}
end_body
member
public: void warning_log(string s);
body
{
	if (log_level >= 20) {
		al_print("[Warning] " + s + "\n");
	} else {
	}
}
end_body
member
public: void info_log(string s);
body
{
	if (log_level >= 30) {
		al_print("[Info] " + s + "\n");
	} else {
	}
}
end_body
member
public: list log_level;
member
public: static void attach_content_validation_data(list dtd, string csv_filename);
body
{
	if (al_dst_node(dtd, "$validation_data")) {
		return;
	} else {
	}
	var file in, in2;
	var list data, node, dics, dic, ret, itr;
	var string type_dic, xpath;
	var string dic_id, value;
	var string type, repr;
	var integer min, max, idx;
	dics = al_cons(null, null);
	if (in = al_file_open(csv_filename, "r")) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "can't open " + (string)csv_filename;
		throw ex;
	}
	loop {
		if (data = al_file_read(in, "csv") && data != 1) {
		} else {
			break;
		}
		type_dic = al_dst_node(data, 1);
		if (type_dic == "type") {
			xpath = al_dst_node(data, 2);
			idx = al_search_str(xpath, 1, "/");
			xpath = al_tail_str(xpath, idx + 1);
			ret = al_cons(null, null);
			get_node(ret, dtd, xpath);
			itr = al_dst_itr(ret);
			if (al_count(itr) == 0) {
				var AlException ex;
				ex = new AlException;
				ex.msg = "dtd node not found: validation-csv-file = " + (string)csv_filename + ", xpath = " + (string)xpath;
				throw ex;
			} else {
			}
			type = al_dst_node(data, 3);
			min = al_dst_node(data, 4);
			if (min != "") {
				min = (integer)min;
			} else {
			}
			max = al_dst_node(data, 5);
			if (max != "") {
				max = (integer)max;
			} else {
			}
			repr = al_dst_node(data, 6);
			loop {
				if (node = al_next(itr)) {
				} else {
					break;
				}
				if (al_dst_node(node, "$type")) {
				} else {
					al_create_arc(node, al_list4(type, min, max, repr), "$type");
				}
			}
		} else {
		}
		if (type_dic == "dic") {
			xpath = al_dst_node(data, 2);
			idx = al_search_str(xpath, 1, "/");
			xpath = al_tail_str(xpath, idx + 1);
			ret = al_cons(null, null);
			get_node(ret, dtd, xpath);
			itr = al_dst_itr(ret);
			if (al_count(itr) == 0) {
				var AlException ex;
				ex = new AlException;
				ex.msg = "dtd node not found: validation-csv-file = " + (string)csv_filename + ", xpath = " + (string)xpath;
				throw ex;
			} else {
			}
			dic_id = al_dst_node(data, 3);
			if (dic = al_dst_node(dics, dic_id)) {
			} else {
				in2 = al_file_open(csv_filename, "r");
				loop {
					if (data = al_file_read(in2, "csv") && data != 1) {
					} else {
						var AlException ex;
						ex = new AlException;
						ex.msg = "unexpected EOF: validation-csv-file = " + (string)csv_filename + ", xpath = " + (string)xpath;
						throw ex;
					}
					type_dic = al_dst_node(data, 1);
					if (type_dic == "end-" + dic_id) {
						break;
					} else {
					}
					if (type_dic != dic_id) {
						continue;
					} else {
					}
					value = al_dst_node(data, 2);
					dic = al_cons(value, dic);
				}
				al_create_arc(dics, dic, dic_id);
			}
			loop {
				if (node = al_next(itr)) {
				} else {
					break;
				}
				if (al_dst_node(node, "$dic")) {
				} else {
					al_create_arc(node, dic, "$dic");
				}
			}
		} else {
		}
	}
	al_create_arc(dtd, al_cons(null, null), "$validation_data");
}
end_body
member
public: static void get_node(list ret, list elem, string xpath);
body
{
	if (xpath == "" && elem.tail.head == "#PCDATA") {
		al_create_arc(ret, elem, null);
		return;
	} else {
	}
	var integer idx;
	var string h, t;
	idx = al_search_str(xpath, 0, "/");
	if (idx >= 0) {
		h = al_substr(xpath, 0, idx);
		t = al_tail_str(xpath, idx + 1);
	} else {
		h = xpath;
		t = "";
	}
	var list choice, itr, elem2;
	var string tag;
	choice = (elem.tail.head == "|");
	itr = al_dst_itr(elem);
	loop {
		if (elem2 = al_next_a(itr, null)) {
		} else {
			break;
		}
		if (choice) {
			elem2 = al_dst_node(elem2, null);
		} else {
		}
		if (elem2.head == "elem") {
			tag = elem2.tail.tail.head;
			if (tag) {
				if (tag == h) {
					get_node(ret, elem2, t);
				} else {
				}
			} else {
				get_node(ret, elem2, xpath);
			}
		} else {
		}
		if (elem2.head == "attr") {
			if ("@" + elem2.tail.head == h && t == "") {
				al_create_arc(ret, elem2, null);
			} else {
			}
		} else {
		}
	}
}
end_body
class ExtendedDtdLoader
member
public: list read_element(file in);
body
{
	var string tag, str;
	var list elem;
	elems = al_cons(null, null);
	loop {
		if (al_file_match_str(in, "<!ELEMENT")) {
			if (tag = al_file_read(in, "xident")) {
			} else {
				error_log("element tag name expected.");
				return "element tag name expected.";
			}
			info_log("element tag: " + tag);
			if (elem = al_dst_node(elems, tag)) {
			} else {
				elem = al_list5("elem", null, tag, "", null);
				al_create_arc(elems, elem, tag);
			}
			if (al_file_read(in, al_list2("find", ">"))) {
			} else {
				error_log("unexpected EOF (11)");
				return "unexpected EOF (11)";
			}
			continue;
		} else {
		}
		if (al_file_match_str(in, "<!ATTLIST")) {
			if (al_file_read(in, al_list2("find", ">"))) {
			} else {
				error_log("unexpected EOF (12)");
				return "unexpected EOF (12)";
			}
			continue;
		} else {
		}
		if (al_file_match_str(in, "<!METAINFO")) {
			if (al_file_read(in, al_list2("find", ">"))) {
			} else {
				error_log("unexpected EOF (13)");
				return "unexpected EOF (13)";
			}
			continue;
		} else {
		}
		if (str = al_file_read(in, "string")) {
			error_log("unexpected token'" + str + "'");
			return "unexpected token'" + str + "'";
		} else {
		}
		return null;
	}
}
end_body
member
public: list elem_attr(file in);
body
{
	var string tag, str;
	var list elem, elem2, itr, tags, all_opt;
	loop {
		if (al_file_match_str(in, "<!ELEMENT")) {
			if (tag = al_file_read(in, "xident")) {
			} else {
				error_log("element tag name expected.");
				return "element tag name expected.";
			}
			info_log("element tag: " + tag);
			if (elem = al_dst_node(elems, tag)) {
			} else {
				error_log("element tag '" + tag + "' not found.");
				return "element tag '" + tag + "' not found.";
			}
			if (elem2 = load_elem(in)) {
				al_create_arc(elem, elem2, null);
			} else {
				error_log("element definition of tag name '" + tag + "' is illegal.");
				return "element definition of tag name '" + tag + "' is illegal.";
			}
			if (al_file_match_str(in, ">")) {
			} else {
				error_log("'>' expected at !ELEMENT (tag = " + tag + ").");
				return "'>' expected at !ELEMENT (tag = " + tag + ").";
			}
			continue;
		} else {
		}
		if (al_file_match_str(in, "<!ATTLIST")) {
			if (tag = al_file_read(in, "xident")) {
			} else {
				error_log("attlist tag name expected.");
				return "attlist tag name expected.";
			}
			info_log("attlist tag: " + tag);
			if (elem = al_dst_node(elems, tag)) {
			} else {
				error_log("attlist tag '" + tag + "' not found.");
				return "attlist tag '" + tag + "' not found.";
			}
			if (add_attr(elem, in)) {
				error_log("attr definition of tag name '" + tag + "' is illegal.");
				return "attr definition of tag name '" + tag + "' is illegal.";
			} else {
			}
			if (al_file_match_str(in, ">")) {
			} else {
				error_log("'>' expected at !ATTLIST (tag = " + tag + ").");
				return "'>' expected at !ATTLIST (tag = " + tag + ").";
			}
			continue;
		} else {
		}
		if (al_file_match_str(in, "<!METAINFO")) {
			var string name, value;
			if (tag = al_file_read(in, "xident")) {
			} else {
				error_log("metainfo tag name expected.");
				return "metainfo tag name expected.";
			}
			info_log("metainfo tag: " + tag);
			if (elem = al_dst_node(elems, tag)) {
			} else {
				error_log("metainfo tag '" + tag + "' not found.");
				return "metainfo tag '" + tag + "' not found.";
			}
			if (name = al_file_read(in, "quote_string")) {
			} else {
				error_log("metainfo property name expected (tag = " + tag + ").");
				return "metainfo property name expected (tag = " + tag + ").";
			}
			if (value = al_file_read(in, "quote_string")) {
			} else {
				error_log("metainfo property value expected (tag = " + tag + ").");
				return "metainfo property value expected (tag = " + tag + ").";
			}
			al_create_arc(elem, value, "$" + name);
			if (al_file_match_str(in, ">")) {
			} else {
				error_log("'>' expected at !METAINFO (tag = " + tag + ").");
				return "'>' expected at !METAINFO (tag = " + tag + ").";
			}
			continue;
		} else {
		}
		if (str = al_file_read(in, "string")) {
			error_log("unexpected token'" + str + "'");
			return "unexpected token'" + str + "'";
		} else {
		}
		itr = al_dst_itr(elems);
		root_elem = al_next(itr);
		data_duplicate = (al_dst_node(root_elem, "$data.duplicate") != "false");
		normalize();
		elems = null;
		tags = al_cons(null, null);
		check_recursive(root_elem, tags);
		return null;
	}
}
end_body
member
public: list add_attr(list elem, file in);
body
{
	var list name, kind, type, default_value;
	loop {
		if (name = al_file_read(in, "xident")) {
		} else {
			return null;
		}
		if (al_file_match_str(in, "(")) {
			var list tag;
			kind = load_attr_choice(in);
			if (al_file_match_str(in, ")")) {
			} else {
				error_log("')' expected at attribute kind.");
				return "')' expected at attribute kind.";
			}
		} else {
			if (kind = al_file_read(in, "string")) {
			} else {
				error_log("attribute kind expected.");
				return "attribute kind expected.";
			}
		}
		if (al_file_match_str(in, "#")) {
			if (type = al_file_read(in, "ident")) {
			} else {
				error_log("attribute type expected.");
				return "attribute type expected.";
			}
			type = "#" + type;
		} else {
			if (type = al_file_read(in, "single_quote_string")) {
			} else {
				if (type = al_file_read(in, "quote_string")) {
				} else {
					error_log("attribute type expected.");
					return "attribute type expected.";
				}
			}
		}
		if (type == "#FIXED") {
			if (default_value = al_file_read(in, "quote_string")) {
			} else {
				error_log("attribute default_value expected.");
				return "attribute default_value expected.";
			}
		} else {
		}
		var list attr;
		attr = al_list5("attr", name, kind, type, default_value);
		al_create_arc(elem, attr, "attr");
		loop {
			if (al_file_match_str(in, "METAINFO")) {
				var string name2, value2;
				if (name2 = al_file_read(in, "quote_string")) {
				} else {
					error_log("metainfo property name expected (attr = " + name + ").");
					return "metainfo property name expected (attr = " + name + ").";
				}
				if (value2 = al_file_read(in, "quote_string")) {
				} else {
					error_log("metainfo property value expected (attr = " + name + ").");
					return "metainfo property value expected (attr = " + name + ").";
				}
				al_create_arc(attr, value2, "$" + name2);
			} else {
				break;
			}
		}
	}
}
end_body
end_class
end_class
class DtdItr
member
public: void Reset(list node0);
body
{
	var list itr, info;
	var string tag;
	itr = al_dst_itr(node = node0);
	stack = al_cons(al_list6("main", itr, node0, "attr", null, al_cons(null, null)), null);
	if (node0.tail.head == null) {
		tag = node0.tail.tail.head;
		abs_xpath = "/" + tag;
		rel_xpath = tag;
		if (handler) {
			handler.startElement(tag);
		} else {
		}
	} else {
		abs_xpath = "";
		rel_xpath = "";
	}
	info = al_list2(abs_xpath, rel_xpath);
	xpath_stack = al_cons(info, null);
	ns_stack = al_cons(null, null);
	type = "begin";
}
end_body
member
public: list Next(list skip_flag);
body
{
	if (type == "elem2") {
		var list info;
		info = xpath_stack.head;
		abs_xpath = info.head;
		rel_xpath = info.tail.head;
		xpath_stack = xpath_stack.tail;
	} else {
	}
	recursive_expanded = null;
	attr = null;
	var list itr, node2, info, kind, attr2;
	if (all_tag && type == "begin") {
		type = "elem3";
		opt = "";
		return type;
	} else {
	}
	if (type == "end") {
		return type;
	} else {
	}
	if (type == "end_repetition") {
		repetition_stack = repetition_stack.tail;
		if (pop()) {
			return type;
		} else {
		}
	} else {
	}
	if (type == "end_optional") {
		if (pop()) {
			return type;
		} else {
		}
	} else {
	}
	if (type == "end_choice") {
		node2 = stack.head.tail.tail.head;
		opt = node2.tail.tail.tail.head;
		if (opt == "*" || opt == "+") {
			stack.head.head = type = "end_repetition";
			return type;
		} else {
			if (opt == "?") {
				stack.head.head = type = "end_optional";
				return type;
			} else {
			}
		}
		if (pop()) {
			return type;
		} else {
		}
	} else {
	}
	if (type == "end_case") {
		stack = stack.tail;
		itr = stack.head.tail.head;
		if (node = al_next_a(itr, null)) {
			itr = al_dst_itr(node);
			stack = al_cons(al_list6(null, itr, node, "attr", null, al_cons(null, null)), stack);
			stack.head.head = type = "case";
			return type;
		} else {
			stack.head.head = type = "end_choice";
			return type;
		}
	} else {
	}
	if (type == "end_all_opt") {
		if (stack.head.head == "case") {
			type = "end_case";
			return type;
		} else {
		}
	} else {
	}
	if (type == "repetition") {
		info = al_list6(stack, node, opt, abs_xpath, xpath_stack, repetition_tag);
		repetition_stack = al_cons(info, repetition_stack);
		rel_xpath = "";
		node2 = stack.head.tail.tail.head;
		if (node2.tail.head == "|") {
			stack.head.head = type = "choice";
			return type;
		} else {
		}
	} else {
	}
	if (type == "choice") {
		itr = stack.head.tail.head;
		if (node = al_next_a(itr, null)) {
			itr = al_dst_itr(node);
			stack = al_cons(al_list6(null, itr, node, "attr", null, al_cons(null, null)), stack);
			stack.head.head = type = "case";
			return type;
		} else {
			stack.head.head = type = "end_choice";
			return type;
		}
	} else {
	}
	if (type == "all_opt") {
		node = stack.head.tail.tail.head;
		opt = node.tail.tail.tail.head;
		if (opt == "*" || opt == "+") {
			if (node.tail.head == null) {
				repetition_tag = node.tail.tail.head;
			} else {
				repetition_tag = null;
			}
			stack.head.head = type = "repetition";
			return type;
		} else {
		}
		if (opt == "?") {
			stack.head.head = type = "optional";
			return type;
		} else {
		}
		if (node.tail.head == "|") {
			stack.head.head = type = "choice";
			return type;
		} else {
		}
		if (al_dst_node(node, null) == null) {
			type = "elem";
			attr = null;
			return type;
		} else {
			if (all_tag && node.tail.tail.head) {
				type = "elem3";
				attr = null;
				return type;
			} else {
			}
		}
	} else {
	}
	loop {
		itr = stack.head.tail.head;
		kind = stack.head.tail.tail.tail.head;
		if (kind == "attr") {
			if (node = al_next_a(itr, "attr")) {
				attr = node.tail.head;
				if (attr == "xml:lang") {
					continue;
				} else {
				}
				opt = node.tail.tail.tail.head;
				if (opt == "#REQUIRED") {
					opt = "";
				} else {
					opt = "?";
				}
				if (al_str_misc("starts_with", attr, "xmlns")) {
					// push namespace stack
					var string ns_name, ns_url;
					if (al_strlen(attr) >= 6) {
						ns_name = al_tail_str(attr, 6);
					} else {
						ns_name = al_copy("");
					}
					if (ns_url = node.tail.tail.tail.tail.head) {
					} else {
						ns_url = "";
					}
					var list itr2;
					itr2 = al_dst_itr(ns_stack);
					if (node2 = al_next(itr2)) {
						al_insert_before(ns_stack, node2, ns_name, ns_url);
					} else {
						al_create_arc(ns_stack, ns_name, ns_url);
					}
					al_create_arc(ns_name, node, "$attr_node");
					al_create_arc(stack.head.tail.tail.tail.tail.tail.head, ns_name, ns_name);
					if (al_dst_node(node, "$scope") != "global") {
						if (handler) {
							handler.setNamespace(ns_name);
						} else {
						}
					} else {
					}
				} else {
				}
				type = "attr";
				return type;
			} else {
				stack.head.tail.tail.tail.head = null;
				node2 = stack.head.tail.tail.head;
				stack.head.tail.head = itr = al_dst_itr(node2);
				{
					if (al_dst_node(node2, "$treat.below.as.text") == "true") {
						al_prev(itr);
						type = "as_text";
						return type;
					} else {
					}
				}
			}
			continue;
		} else {
		}
		if (node = al_next_a(itr, null)) {
			if (skip_flag) {
				if (al_dst_node(node, "$recursive") == 0) {
					if (stack.head.head == "case") {
						type = "end_case";
						return type;
					} else {
					}
					// continue;
					info = al_list2(abs_xpath, rel_xpath);
					xpath_stack = al_cons(info, xpath_stack);
					tag = node.tail.tail.head;
					abs_xpath = abs_xpath + "/" + tag;
					if (rel_xpath == "") {
						rel_xpath = tag;
					} else {
						rel_xpath = rel_xpath + "/" + tag;
					}
					type = "elem2";
					attr = null;
					return type;
				} else {
				}
				if (skip_flag == 1) {
					if (stack.head.head == "case") {
					} else {
						continue;
					}
				} else {
				}
			} else {
			}
			expand_recursive();
			itr = al_dst_itr(node);
			stack = al_cons(al_list6(null, itr, node, "attr", null, al_cons(null, null)), stack);
			if (node.tail.head == null) {
				info = al_list2(abs_xpath, rel_xpath);
				xpath_stack = al_cons(info, xpath_stack);
				tag = node.tail.tail.head;
				abs_xpath = abs_xpath + "/" + tag;
				if (rel_xpath == "") {
					rel_xpath = tag;
				} else {
					rel_xpath = rel_xpath + "/" + tag;
				}
				if (handler) {
					handler.startElement(tag);
				} else {
				}
			} else {
			}
			opt = node.tail.tail.tail.head;
			{
				var list is_tag, all_opt;
				is_tag = node.tail.tail.head;
				all_opt = node.tail.tail.tail.tail.head;
				if (is_tag && all_opt && (opt == "" || opt == "+")) {
					stack.head.tail.tail.tail.tail.head = "all_opt";
					type = "all_opt";
					return type;
				} else {
				}
			}
			if (opt == "*" || opt == "+") {
				if (node.tail.head == null) {
					repetition_tag = tag;
				} else {
					repetition_tag = null;
				}
				stack.head.head = type = "repetition";
				return type;
			} else {
			}
			if (opt == "?") {
				stack.head.head = type = "optional";
				return type;
			} else {
			}
			if (node.tail.head == "|") {
				stack.head.head = type = "choice";
				return type;
			} else {
			}
			if (al_dst_node(node, null) == null) {
				type = "elem";
				attr = null;
				return type;
			} else {
				if (all_tag && node.tail.tail.head) {
					type = "elem3";
					attr = null;
					return type;
				} else {
				}
			}
		} else {
			node2 = stack.head.tail.tail.head;
			if (node2.head == "elem" && node2.tail.head == null) {
				info = xpath_stack.head;
				if (abs_xpath == info.head) {
					tag = al_tail_str(abs_xpath, 1);
				} else {
					tag = al_tail_str(abs_xpath, al_strlen(info.head) + 1);
				}
				abs_xpath = info.head;
				rel_xpath = info.tail.head;
				xpath_stack = xpath_stack.tail;
				repetition_tag = null;
				if (handler) {
					handler.endElement(tag);
				} else {
				}
				{
					// pop namespace stack
					var string ns_name;
					var list itr2, itr3;
					itr2 = al_dst_itr(stack.head.tail.tail.tail.tail.tail.head);
					loop {
						if (ns_name = al_next(itr2)) {
						} else {
							break;
						}
						itr3 = al_dst_itr(ns_stack);
						loop {
							if (al_next(itr3) == ns_name) {
							} else {
								break;
							}
							al_remove(itr3);
							break;
						}
					}
					itr3 = al_dst_itr(ns_stack);
					loop {
						if (ns_name = al_next(itr3)) {
						} else {
							if (handler) {
								handler.setNamespace(ns_name);
							} else {
							}
							break;
						}
						if (node2 = al_dst_node(ns_name, "$attr_node") && al_dst_node(node2, "$scope") == "global") {
							continue;
						} else {
						}
						if (handler) {
							handler.setNamespace(ns_name);
						} else {
						}
						break;
					}
				}
			} else {
			}
			kind = stack.head.head;
			if (kind == "repetition") {
				type = "end_repetition";
				return type;
			} else {
			}
			if (kind == "optional") {
				type = "end_optional";
				return type;
			} else {
			}
			if (kind == "main") {
				stack = stack.tail;
				type = "end";
				return type;
			} else {
			}
			if (pop()) {
				return type;
			} else {
			}
			if (stack.head.head == "case") {
				type = "end_case";
				return type;
			} else {
			}
		}
	}
}
end_body
member
public: list pop();
body
{
	if (stack.head.tail.tail.tail.tail.head == "all_opt") {
		type = "end_all_opt";
		attr = tag = null;
		stack = stack.tail;
		return 1;
	} else {
		stack = stack.tail;
		return null;
	}
}
end_body
member
public: list stack;
member
public: list type;
member
public: list node;
member
public: list opt;
member
public: void ContinueRepetition();
body
{
	var list itr, info, node2;
	info = repetition_stack.head;
	repetition_stack = repetition_stack.tail;
	stack = info.head;
	node = info.tail.head;
	opt = info.tail.tail.head;
	abs_xpath = info.tail.tail.tail.head;
	xpath_stack = info.tail.tail.tail.tail.head;
	repetition_tag = info.tail.tail.tail.tail.tail.head;
	node2 = stack.head.tail.tail.head;
	itr = al_dst_itr(node2);
	stack.head.tail.head = itr;
	stack.head.head = type = "repetition";
	stack.head.tail.tail.tail.head = "attr";
	if (handler && repetition_tag) {
		handler.startElement(repetition_tag);
	} else {
	}
}
end_body
member
public: void BreakRepetition();
body
{
	var integer count;
	count = 1;
	loop {
		if (type == "end_repetition") {
			count = count - 1;
			if (count == 0) {
				break;
			} else {
			}
		} else {
		}
		Next((list)1);
		if (type == "end") {
			al_print("%%% BreakRepetition: end appears during finding end_repetition.\n");
			break;
		} else {
		}
		if (type == "repetition") {
			count = count + 1;
		} else {
		}
	}
}
end_body
member
public: list repetition_stack;
member
public: string abs_xpath;
member
public: string rel_xpath;
member
public: string attr;
member
public: string tag;
member
public: list xpath_stack;
member
public: void expand_recursive();
body
{
	if (al_dst_node(node, "$recursive") == 0) {
	} else {
		return;
	}
	recursive_expanded = 1;
	var list node2, itr, elem, itr2, elem2;
	node2 = al_copy(node);
	mark(node2);
	unmark(node2);
	al_graph_misc("mark", node2, null);
	itr = al_src_itr(node2);
	loop {
		if (elem = al_next(itr)) {
		} else {
			break;
		}
		al_arc_dst(itr, node);
	}
	itr = al_src_itr(node);
	loop {
		if (elem = al_next(itr)) {
		} else {
			break;
		}
		if (al_graph_misc("is_marked", elem, null)) {
			continue;
		} else {
		}
		al_arc_dst(itr, node2);
	}
	itr = al_dst_itr(node);
	itr2 = al_dst_itr(node2);
	loop {
		if (al_next(itr)) {
		} else {
			break;
		}
		elem2 = al_next(itr2);
		al_arc_dst(itr, elem2);
	}
	al_graph_misc("unmark", node2, null);
	node = node2;
}
end_body
member
public: void mark(list elem);
body
{
	if (al_dst_node(elem, "$mark")) {
		return;
	} else {
	}
	al_set_dst_node(elem, "$mark", "mark");
	if (al_dst_node(elem, "$recursive") == 0) {
		al_set_dst_node(elem, "$recursive", 1);
	} else {
	}
	var list itr, elem2;
	itr = al_dst_itr(elem);
	loop {
		if (elem2 = al_next_a(itr, null)) {
		} else {
			break;
		}
		mark(elem2);
	}
}
end_body
member
public: void unmark(list elem);
body
{
	if (al_dst_node(elem, "$mark")) {
	} else {
		return;
	}
	al_set_dst_node(elem, "$mark", null);
	var list itr, elem2;
	itr = al_dst_itr(elem);
	loop {
		if (elem2 = al_next_a(itr, null)) {
		} else {
			break;
		}
		unmark(elem2);
	}
}
end_body
member
public: list recursive_expanded;
member
public: string repetition_tag;
member
public: DtdHandler handler;
member
public: DtdItr Copy();
body
{
	var DtdItr itr;
	itr = new DtdItr;
	itr.stack = stack_copy(stack);
	itr.type = type;
	itr.node = node;
	itr.opt = opt;
	itr.repetition_stack = repetition_stack_copy(repetition_stack);
	itr.abs_xpath = abs_xpath;
	itr.rel_xpath = rel_xpath;
	itr.attr = attr;
	itr.xpath_stack = xpath_stack;
	itr.repetition_tag = repetition_tag;
	itr.ns_stack = al_copy(ns_stack);
	return itr;
}
end_body
member
public: list stack_copy(list stack);
body
{
	if (stack) {
	} else {
		return null;
	}
	var list info, info2;
	info = stack.head;
	info2 = al_list6(info.head, al_copy(info.tail.head), info.tail.tail.head, info.tail.tail.tail.head, info.tail.tail.tail.tail.head, info.tail.tail.tail.tail.tail.head);
	return al_cons(info2, stack_copy(stack.tail));
}
end_body
member
public: list repetition_stack_copy(list repetition_stack);
body
{
	if (repetition_stack) {
	} else {
		return null;
	}
	var list info, info2;
	info = repetition_stack.head;
	info2 = al_list6(stack_copy(info.head), info.tail.head, info.tail.tail.head, info.tail.tail.tail.head, info.tail.tail.tail.tail.head, info.tail.tail.tail.tail.tail.head);
	return al_cons(info2, repetition_stack_copy(repetition_stack.tail));
}
end_body
member
public: list getFieldList();
body
{
	var DtdItr itr;
	var list field_list, type;
	var string path;
	itr = Copy();
	field_list = al_cons(null, null);
	loop {
		type = itr.Next((list)2);
		if (type == "end_repetition" || type == "end") {
			break;
		} else {
		}
		if (type == "elem" || type == "all_opt") {
			path = itr.rel_xpath;
			al_create_arc(field_list, path, path);
			continue;
		} else {
		}
		if (type == "attr") {
			if (rel_xpath == "") {
				path = "@" + itr.attr;
			} else {
				path = itr.rel_xpath + "/@" + itr.attr;
			}
			al_create_arc(field_list, path, path);
			continue;
		} else {
		}
		if (type == "optional" || type == "end_optional") {
			continue;
		} else {
		}
		if (type == "choice" || type == "end_choice") {
			continue;
		} else {
		}
		if (type == "case" || type == "end_case") {
			continue;
		} else {
		}
		if (type == "repetition") {
			var integer count;
			count = 1;
			loop {
				type = itr.Next((list)1);
				if (type == "end") {
					al_print("%%% getFieldList: end appears during finding end_repetition.\n");
					break;
				} else {
				}
				if (type == "end_repetition") {
					count = count - 1;
					if (count == 0) {
						break;
					} else {
					}
				} else {
				}
				if (type == "repetition") {
					count = count + 1;
				} else {
				}
			}
			continue;
		} else {
		}
	}
	return field_list;
}
end_body
member
public: list getChildList();
body
{
	var DtdItr itr;
	var list child_list, type;
	var string path;
	itr = Copy();
	child_list = al_cons(null, null);
	loop {
		type = itr.Next((list)2);
		if (type == "end_repetition" || type == "end") {
			break;
		} else {
		}
		if (type == "elem") {
			continue;
		} else {
		}
		if (type == "attr") {
			continue;
		} else {
		}
		if (type == "optional" || type == "end_optional") {
			continue;
		} else {
		}
		if (type == "choice" || type == "end_choice") {
			continue;
		} else {
		}
		if (type == "case" || type == "end_case") {
			continue;
		} else {
		}
		if (type == "repetition") {
			al_create_arc(child_list, itr.rel_xpath, itr.rel_xpath);
			var integer count;
			count = 1;
			loop {
				type = itr.Next((list)1);
				if (type == "end") {
					al_print("%%% getChildList: end appears during finding end_repetition.\n");
					break;
				} else {
				}
				if (type == "end_repetition") {
					count = count - 1;
					if (count == 0) {
						break;
					} else {
					}
				} else {
				}
				if (type == "repetition") {
					count = count + 1;
				} else {
				}
			}
			continue;
		} else {
		}
	}
	return child_list;
}
end_body
member
public: DtdItr getChild(string xpath);
body
{
	var DtdItr itr;
	var list field_list, type;
	itr = Copy();
	field_list = al_cons(null, null);
	loop {
		type = itr.Next((list)2);
		if (type == "end_repetition" || type == "end") {
			break;
		} else {
		}
		if (type == "elem" || type == "attr") {
			continue;
		} else {
		}
		if (type == "optional" || type == "end_optional") {
			continue;
		} else {
		}
		if (type == "choice" || type == "end_choice") {
			continue;
		} else {
		}
		if (type == "case" || type == "end_case") {
			continue;
		} else {
		}
		if (type == "repetition") {
			if (itr.rel_xpath == xpath) {
				return itr;
			} else {
			}
			var integer count;
			count = 1;
			loop {
				type = itr.Next((list)1);
				if (type == "end") {
					al_print("%%% getChild: end appears during finding end_repetition.\n");
					break;
				} else {
				}
				if (type == "end_repetition") {
					count = count - 1;
					if (count == 0) {
						break;
					} else {
					}
				} else {
				}
				if (type == "repetition") {
					count = count + 1;
				} else {
				}
			}
			continue;
		} else {
		}
	}
	return null;
}
end_body
member
public: list getFieldList2();
body
{
	var DtdItr itr;
	var list field_list, pkey_list, fkey_list, rev_field_list, type;
	var string path;
	itr = Copy();
	field_list = al_cons(null, null);
	pkey_list = al_cons(null, null);
	fkey_list = al_cons(null, null);
	rev_field_list = al_cons(null, null);
	loop {
		type = itr.Next((list)2);
		if (type == "end_repetition" || type == "end") {
			break;
		} else {
		}
		if (type == "elem" || type == "all_opt") {
			if (tag2) {
			} else {
				tag2 = al_dst_node(al_str_misc("split", itr.rel_xpath, '/'), null);
			}
			path = itr.rel_xpath;
			al_create_arc(field_list, itr.tag, path);
			al_create_arc(rev_field_list, path, itr.tag);
			continue;
		} else {
		}
		if (type == "attr") {
			if (itr.attr == "primary-key") {
				al_create_arc(pkey_list, itr.tag, null);
			} else {
				al_create_arc(fkey_list, itr.attr, itr.tag);
			}
			continue;
		} else {
		}
		if (type == "optional" || type == "end_optional") {
			continue;
		} else {
		}
		if (type == "choice" || type == "end_choice") {
			continue;
		} else {
		}
		if (type == "case" || type == "end_case") {
			continue;
		} else {
		}
		if (type == "repetition") {
			var integer count;
			count = 1;
			loop {
				type = itr.Next((list)1);
				if (type == "end") {
					al_print("%%% getFieldList2: end appears during finding end_repetition.\n");
					break;
				} else {
				}
				if (type == "end_repetition") {
					count = count - 1;
					if (count == 0) {
						break;
					} else {
					}
				} else {
				}
				if (type == "repetition") {
					count = count + 1;
				} else {
				}
			}
			continue;
		} else {
		}
	}
	return al_list5(field_list, tag2, pkey_list, fkey_list, rev_field_list);
}
end_body
member
public: list getChild2(string xpath);
body
{
	var DtdItr itr;
	var list field_list, type;
	itr = Copy();
	field_list = al_cons(null, null);
	loop {
		type = itr.Next((list)2);
		if (type == "end_repetition" || type == "end") {
			break;
		} else {
		}
		if (type == "elem" || type == "attr") {
			continue;
		} else {
		}
		if (type == "optional" || type == "end_optional") {
			continue;
		} else {
		}
		if (type == "choice" || type == "end_choice") {
			continue;
		} else {
		}
		if (type == "case" || type == "end_case") {
			continue;
		} else {
		}
		if (type == "repetition") {
			if (itr.rel_xpath == xpath) {
				var list itr2;
				itr2 = al_dst_itr(al_str_misc("split", xpath, '/'));
				return al_list2(itr, al_prev(itr2));
			} else {
			}
			var integer count;
			count = 1;
			loop {
				type = itr.Next((list)1);
				if (type == "end") {
					al_print("%%% getChild2: end appears during finding end_repetition.\n");
					break;
				} else {
				}
				if (type == "end_repetition") {
					count = count - 1;
					if (count == 0) {
						break;
					} else {
					}
				} else {
				}
				if (type == "repetition") {
					count = count + 1;
				} else {
				}
			}
			continue;
		} else {
		}
	}
	return null;
}
end_body
member
public: list tag2;
member
public: list ns_stack;
member
public: list all_tag;
end_class
class DtdHandler
member
public: void startElement(string tag);
body
{
	al_print("startElement: tag = " + tag + "\n");
}
end_body
member
public: void endElement(string tag);
body
{
	al_print("endElement: tag = " + tag + "\n");
}
end_body
member
public: void setNamespace(string name);
body
{
	if (name) {
		al_print("setNamespace: name = " + name + "\n");
	} else {
		al_print("setNamespace: null is setted.\n");
	}
}
end_body
class XmlComposerHandler
member
public: void startElement(string tag);
body
{
	if (debug) {
		DtdHandler::startElement(tag);
	} else {
	}
	out_current_tag();
	current_tag = tag;
	ns_names = al_cons(null, null);
}
end_body
member
public: void endElement(string tag);
body
{
	if (debug) {
		DtdHandler::endElement(tag);
	} else {
	}
	out_current_tag();
	out_str("</");
	if (ns_name && ns_name != "") {
		out_str(ns_name);
		out_str(":");
	} else {
	}
	out_str(tag);
	out_str(">");
}
end_body
member
public: void setNamespace(string name);
body
{
	if (debug) {
		DtdHandler::setNamespace(name);
	} else {
	}
	ns_name = name;
}
end_body
member
public: XmlComposer composer;
member
public: void out_current_tag();
body
{
	if (current_tag) {
		out_str("<");
		if (ns_name && ns_name != "") {
			out_str(ns_name);
			out_str(":");
		} else {
		}
		out_str(current_tag);
		current_tag = null;
		if (current_attrs) {
			var list itr, nv;
			var string attr;
			itr = al_dst_itr(current_attrs);
			loop {
				if (nv = al_next(itr)) {
				} else {
					break;
				}
				out_str(" ");
				out_str((string)nv.head);
				out_str("=\"");
				attr = al_str_misc("xml_encode", nv.tail.head, 3);
				attr = al_str_misc("to_quote_string", attr, null);
				out_str(attr);
				out_str("\"");
			}
			var string ns_name2, ns_url2;
			itr = al_dst_itr(ns_names);
			loop {
				if (ns_name2 = al_next(itr)) {
				} else {
					break;
				}
				ns_url2 = al_arc_a(itr);
				out_str(" xmlns:");
				out_str(ns_name2);
				out_str("=\"");
				attr = al_str_misc("xml_encode", ns_url2, 3);
				attr = al_str_misc("to_quote_string", attr, null);
				out_str(attr);
				out_str("\"");
			}
			current_attrs = null;
		} else {
		}
		out_str(">");
	} else {
	}
	if (current_value) {
		out_str((string)al_str_misc("xml_encode", current_value, 3));
		current_value = null;
	} else {
	}
	if (raw_current_value) {
		out_str(raw_current_value);
		raw_current_value = null;
	} else {
	}
}
end_body
member
public: string current_tag;
member
public: list current_attrs;
member
public: string current_value;
member
public: string raw_current_value;
member
public: void out_str(string val);
body
{
	composer.out_str(val);
}
end_body
member
public: string ns_name;
member
public: list ns_names;
end_class
end_class
class XmlItr
member
public: void Reset(list parse_tree);
body
{
	var list itr;
	itr = al_dst_itr(parse_tree);
	xpath = "";
	stack = al_cons(al_list2(xpath, itr), null);
}
end_body
member
public: list Next();
body
{
	var list itr, tag, body, attr;
	loop {
		if (stack == null) {
			if (debug) {
				al_print("XmlItr::Next: stack is empty.\n");
			} else {
			}
			return null;
		} else {
		}
		xpath = stack.head.head;
		itr = stack.head.tail.head;
		if (debug) {
			al_print("XmlItr::Next: next xpath (1) = " + xpath + "\n");
		} else {
		}
		if (itr) {
			loop {
				if (tag = al_next(itr)) {
				} else {
					break;
				}
				attr = al_arc_a(itr);
				if (attr == "!comment") {
					continue;
				} else {
				}
				if (attr == "!text") {
					continue;
				} else {
				}
				xpath = xpath + "/" + attr;
				if (debug) {
					al_print("XmlItr::Next: next xpath (2) = " + xpath + "\n");
				} else {
				}
				if (body = al_dst_node(tag, "!body")) {
					itr = al_dst_itr(body);
					value = al_dst_node(body, "!text");
				} else {
					value = ctrl_a;
					itr = null;
				}
				stack = al_cons(al_list2(xpath, itr), stack);
				if (debug) {
					al_print("XmlItr::Next: value = " + (string)value + "\n");
				} else {
				}
				return tag;
			}
		} else {
		}
		stack = stack.tail;
	}
}
end_body
member
public: list Next2();
body
{
	var list itr, tag, body, attr;
	loop {
		if (stack == null) {
			if (debug) {
				al_print("XmlItr::Next2: stack is empty.\n");
			} else {
			}
			return null;
		} else {
		}
		xpath = stack.head.head;
		itr = stack.head.tail.head;
		if (itr) {
			loop {
				if (tag = al_next(itr)) {
				} else {
					break;
				}
				attr = al_arc_a(itr);
				if (attr == "!comment") {
					continue;
				} else {
				}
				if (attr == "!text") {
					continue;
				} else {
				}
				xpath = xpath + "/" + attr;
				if (body = al_dst_node(tag, "!body")) {
					itr = al_dst_itr(body);
					value = al_dst_node(body, "!text");
				} else {
					value = ctrl_a;
					itr = null;
				}
				stack = al_cons(al_list2(xpath, itr), stack);
				if (debug) {
					al_print("XmlItr::Next2: value = " + (string)value + "\n");
				} else {
				}
				return tag;
			}
		} else {
		}
		if (debug) {
			al_print("XmlItr::Next2: no more iterator element.\n");
		} else {
		}
		return null;
	}
}
end_body
member
public: list Next3();
body
{
	var string null_str;
	return Next3(null_str);
}
end_body
member
public: list Next3(string prev_rept_xpath);
body
{
	var list itr, tag, body, attr;
	loop {
		if (stack == null) {
			if (debug) {
				al_print("XmlItr::Next3: stack is empty.\n");
			} else {
			}
			return null;
		} else {
		}
		xpath = stack.head.head;
		itr = stack.head.tail.head;
		if (xpath == prev_rept_xpath) {
			if (debug) {
				al_print("XmlItr::Next2: xpath is previous xpath.\n");
			} else {
			}
			return null;
		} else {
		}
		if (debug) {
			al_print("XmlItr::Next3: next xpath = " + xpath + "\n");
		} else {
		}
		if (itr) {
			loop {
				if (tag = al_next(itr)) {
				} else {
					break;
				}
				attr = al_arc_a(itr);
				if (attr == "!comment") {
					continue;
				} else {
				}
				if (attr == "!text") {
					continue;
				} else {
				}
				al_prev(itr);
				if (debug) {
					al_print("XmlItr::Next3: next element found.\n");
				} else {
				}
				return tag;
			}
		} else {
		}
		stack = stack.tail;
	}
}
end_body
member
public: list stack;
member
public: list xpath;
member
public: string value;
member
public: list getNext(string xpath, string attr);
body
{
	var string null_str;
	return getNext(null_str, xpath, attr);
}
end_body
member
public: list getNext(string prev_rept_xpath, string xpath, string attr);
body
{
	var list tag;
	tag = Next3(prev_rept_xpath);
	var XmlItr xml_itr2;
	xml_itr2 = Copy();
	xml_itr2.value = null;
	if (debug) {
		if (attr) {
			al_print("XmlItr::getNext: required xpath = " + xpath + "/@" + attr + "\n");
		} else {
			al_print("XmlItr::getNext: required xpath = " + xpath + "\n");
		}
	} else {
	}
	loop {
		if (xpath == xml_itr2.xpath) {
			break;
		} else {
		}
		if (tag = xml_itr2.Next2()) {
		} else {
			if (debug) {
				al_print("XmlItr::getNext: not found\n");
			} else {
			}
			return null;
		}
		if (debug) {
			al_print("XmlItr::getNext: next xpath = " + xml_itr2.xpath + "\n");
		} else {
		}
	}
	if (attr) {
		if (xml_itr2.getAttribute(tag, attr)) {
		} else {
			if (debug) {
				al_print("XmlItr::getNext: not found(attr)\n");
			} else {
			}
			return null;
		}
	} else {
	}
	Copy(xml_itr2);
	if (debug) {
		al_print("XmlItr::getNext: found: value = " + (string)value + "\n");
	} else {
	}
	return 1;
}
end_body
member
public: list getAttribute(list tag, string attr);
body
{
	if (tag == null) {
		return null;
	} else {
	}
	var list val_ls;
	if (val_ls = al_dst_node(tag, attr)) {
		value = val_ls.head;
		if (value == "") {
			value = ctrl_a;
		} else {
		}
	} else {
		return null;
	}
	return 1;
}
end_body
member
public: list getNodeAsText(string xpath);
body
{
	Next3();
	var list tag;
	var XmlItr xml_itr2;
	xml_itr2 = Copy();
	xml_itr2.value = null;
	if (debug) {
		al_print("XmlItr::getNodeAsText: required xpath = " + xpath + "\n");
	} else {
	}
	loop {
		if (xpath == xml_itr2.xpath) {
			break;
		} else {
		}
		if (tag = xml_itr2.Next2()) {
		} else {
			if (debug) {
				al_print("XmlItr::getNodeAsText: not found\n");
			} else {
			}
			return null;
		}
		if (debug) {
			al_print("XmlItr::getNodeAsText: next xpath = " + xml_itr2.xpath + "\n");
		} else {
		}
	}
	{
		var list body;
		var file out;
		if (body = al_dst_node(tag, "!body")) {
			value = al_copy("");
			out = al_file_open(value, "sw");
			if (al_xml("generate", out, body, al_cons(2, null))) {
				return null;
			} else {
			}
			loop {
				xml_itr2.Next();
				var integer idx;
				idx = al_search_str(xml_itr2.xpath, 0, xpath);
				if (idx < 0) {
					break;
				} else {
				}
			}
			xml_itr2.value = value;
		} else {
			xml_itr2.value = ctrl_a;
		}
	}
	Copy(xml_itr2);
	if (debug) {
		al_print("XmlItr::getNodeAsText: found: value = " + (string)value + "\n");
	} else {
	}
	return 1;
}
end_body
member
public: XmlItr Copy();
body
{
	return al_copy(this);
}
end_body
member
public: void Copy(XmlItr xml_itr);
body
{
	stack = xml_itr.stack;
	xpath = xml_itr.xpath;
	value = xml_itr.value;
	debug = xml_itr.debug;
}
end_body
end_class
class XmlValidator
member
public: list validate(list dtd, list xml);
body
{
	xml_debug();
	var list err;
	dtd_itr = new DtdItr;
	dtd_itr.Reset(dtd);
	var XmlItr xml_itr;
	xml_itr = new XmlItr;
	if (debug2) {
		xml_itr.debug = 1;
	} else {
	}
	xml_itr.Reset(xml);
	if (save) {
		Begin();
	} else {
	}
	read_tag_count = 0;
	read_elem_count = read_tag_count;
	read_recursive_tag_count = 0;
	if (err = validate1(xml_itr)) {
		return err;
	} else {
	}
	if (dtd_itr.type != "end") {
		return "xml is not enough: xpath = \"" + dtd_itr.abs_xpath + "\"";
	} else {
	}
	if (save) {
		End();
	} else {
	}
	return null;
}
end_body
member
public: list validate1(XmlItr xml_itr);
body
{
	var list err;
	var string type, abs_xpath, attr, opt;
	var integer count, read_tag_count_save, read_recursive_tag_count_save;
	var XmlItr xml_itr2, xml_itr3;
	loop {
		type = dtd_itr.Next(null);
		if (al_dst_node(dtd_itr.node, "$recursive") && dtd_itr.node.tail.tail.head) {
			read_recursive_tag_count = read_recursive_tag_count + 1;
		} else {
		}
		if (type == "end_optional" || type == "end_repetition" || type == "end_case" || type == "end_all_opt" || type == "end") {
			return null;
		} else {
		}
		abs_xpath = dtd_itr.abs_xpath;
		attr = dtd_itr.attr;
		opt = dtd_itr.opt;
		if (type == "repetition") {
			var string prev_rept_xpath;
			var list brk_rep, all_opt;
			if (debug) {
				al_print("Enter repetition: xpath = " + abs_xpath + "\n\n");
			} else {
			}
			if (stack) {
				prev_rept_xpath = stack.head.tail.tail.tail.tail.tail.tail.tail.head;
			} else {
			}
			all_opt = (dtd_itr.node.tail.tail.head && dtd_itr.node.tail.tail.tail.tail.head);
			if (save) {
				BeginRepetition(abs_xpath, dtd_itr.rel_xpath);
			} else {
			}
			count = 0;
			loop {
				read_tag_count_save = read_tag_count;
				read_elem_count = read_tag_count;
				if (debug) {
					al_print("repetition: count = " + (string)(count + 1) + "\n\n");
				} else {
				}
				xml_itr2 = xml_itr.Copy();
				if (xml_itr2.getNext(prev_rept_xpath, abs_xpath, attr)) {
					xml_itr3 = xml_itr.Copy();
					xml_itr3.Next3(prev_rept_xpath);
					if (err = validate1(xml_itr3)) {
						brk_rep = 1;
					} else {
						xml_itr.Copy(xml_itr3);
						if (read_tag_count == read_tag_count_save) {
							if (all_opt) {
								xml_itr.Copy(xml_itr2);
							} else {
								xml_itr.Next();
								brk_rep = 1;
							}
						} else {
							if (read_elem_count == read_tag_count_save) {
								if (all_opt) {
									xml_itr.Copy(xml_itr2);
								} else {
								}
							} else {
							}
						}
					}
				} else {
					brk_rep = 1;
				}
				if (brk_rep) {
					if (count == 0) {
						if (opt != "*") {
							if (save) {
								BreakRepetition();
							} else {
							}
							if (debug) {
								al_print("Leave repetition(no item(a) at +): xpath = " + abs_xpath + "\n\n");
							} else {
							}
							return "repetition xpath \"" + abs_xpath + "\" requrired.";
						} else {
						}
					} else {
					}
					dtd_itr.BreakRepetition();
					if (save) {
						BreakRepetition();
					} else {
					}
					break;
				} else {
				}
				count = count + 1;
				dtd_itr.ContinueRepetition();
				if (save) {
					ContinueRepetition();
				} else {
				}
			}
			if (debug) {
				al_print("Leave repetition: xpath = " + abs_xpath + "\n\n");
			} else {
			}
			continue;
		} else {
		}
		if (type == "optional") {
			if (debug) {
				al_print("Enter optional: xpath = " + abs_xpath + "\n\n");
			} else {
			}
			var string tmp_str;
			read_tag_count_save = read_tag_count;
			tmp_str = dtd_itr.abs_xpath;
			xml_itr2 = xml_itr.Copy();
			var list found, skip;
			if (xml_itr2.getNext(abs_xpath, attr)) {
				xml_itr2 = xml_itr.Copy();
				if (validate1(xml_itr2)) {
					skip = 1;
				} else {
					if (read_tag_count == read_tag_count_save) {
					} else {
						xml_itr.Copy(xml_itr2);
						found = 1;
					}
				}
			} else {
				skip = 1;
			}
			if (found) {
				if (debug) {
					al_print("Leave optional(found): xpath = " + abs_xpath + "\n\n");
				} else {
				}
			} else {
				if (skip) {
					skip_optional();
				} else {
				}
				if (debug) {
					al_print("Leave optional(not found): xpath = " + abs_xpath + "\n\n");
				} else {
				}
			}
			continue;
		} else {
		}
		if (type == "choice") {
			if (debug) {
				al_print("Enter choice: xpath = " + abs_xpath + "\n\n");
			} else {
			}
			var integer num;
			num = 0;
			loop {
				type = dtd_itr.Next((list)1);
				if (type == "choice") {
					skip_choice();
				} else {
				}
				if (type == "end_choice") {
					if (opt != "?") {
						return "choice xpath \"" + abs_xpath + "\" requrired.";
					} else {
					}
					break;
				} else {
				}
				if (type == "case") {
					if (debug) {
						al_print("Enter choice_case: xpath = " + abs_xpath + "\n\n");
					} else {
					}
					read_tag_count_save = read_tag_count;
					read_recursive_tag_count_save = read_recursive_tag_count;
					var list found;
					xml_itr2 = xml_itr.Copy();
					if (xml_itr2.getNext(abs_xpath, attr)) {
						xml_itr2 = xml_itr.Copy();
						if (validate1(xml_itr2)) {
						} else {
							if (read_tag_count == read_tag_count_save && read_recursive_tag_count > read_recursive_tag_count_save) {
							} else {
								xml_itr.Copy(xml_itr2);
								found = 1;
							}
						}
					} else {
					}
					if (found) {
						skip_choice();
						if (debug) {
							al_print("Leave choice_case(found): xpath = " + abs_xpath + "\n\n");
						} else {
						}
						break;
					} else {
						if (read_tag_count == read_tag_count_save && read_recursive_tag_count > read_recursive_tag_count_save) {
						} else {
							skip_case();
						}
						if (debug) {
							al_print("Leave choice_case(not found): xpath = " + abs_xpath + "\n\n");
						} else {
						}
					}
				} else {
				}
			}
			if (debug) {
				al_print("Leave choice: xpath = " + abs_xpath + "\n\n");
			} else {
			}
			continue;
		} else {
		}
		if (type == "all_opt") {
			if (debug) {
				al_print("Enter all_opt: xpath = " + abs_xpath + "\n\n");
			} else {
			}
			var string path;
			path = dtd_itr.rel_xpath;
			xml_itr2 = xml_itr.Copy();
			read_tag_count_save = read_tag_count;
			if (validate1(xml_itr2)) {
				skip_all_opt();
			} else {
				if (read_tag_count == read_tag_count_save) {
					var string null_str;
					if (xml_itr.getNext(abs_xpath, null_str)) {
						if (debug) {
							al_print("tag with all optional empty child: path = " + path + ", abs_xpath = " + abs_xpath + "\n\n");
						} else {
						}
						if (save) {
							putValue("0", path, ctrl_a);
						} else {
						}
						read_tag_count = read_tag_count + 1;
					} else {
					}
				} else {
					xml_itr.Copy(xml_itr2);
				}
			}
			if (debug) {
				al_print("Leave all_opt: xpath = " + abs_xpath + "\n\n");
			} else {
			}
			continue;
		} else {
		}
		if (type == "attr") {
			var string p;
			if (dtd_itr.rel_xpath == "") {
				p = "@" + attr;
			} else {
				p = dtd_itr.rel_xpath + "/@" + attr;
			}
			xml_itr2 = xml_itr.Copy();
			if (xml_itr2.getNext(abs_xpath, attr)) {
				if (save) {
					putValue("0", p, xml_itr2.value);
				} else {
				}
				read_tag_count = read_tag_count + 1;
				if (debug) {
					al_print("attr: value = " + (string)xml_itr2.value + ", xpath = " + abs_xpath + "/@" + attr + "\n\n");
				} else {
				}
			} else {
				if (dtd_itr.node.tail.tail.tail.head == "#REQUIRED") {
					if (debug) {
						al_print("attr(not found): xpath = " + abs_xpath + "/@" + attr + "\n\n");
					} else {
					}
					return "xpath \"" + abs_xpath + "\" requrired.";
				} else {
				}
			}
			continue;
		} else {
		}
		if (type == "elem") {
			if (xml_itr.getNext(abs_xpath, attr)) {
				if (xml_itr.value) {
					if (save) {
						putValue("0", dtd_itr.rel_xpath, xml_itr.value);
					} else {
					}
				} else {
					if (opt != "?") {
						if (debug) {
							al_print("elem(not found): xpath = " + abs_xpath + "\n\n");
						} else {
						}
						return "xpath \"" + abs_xpath + "\" requrired.";
					} else {
					}
				}
				read_tag_count = read_tag_count + 1;
				read_elem_count = read_elem_count + 1;
				if (debug) {
					al_print("elem: value = " + (string)xml_itr.value + ", xpath = " + abs_xpath + "\n\n");
				} else {
				}
			} else {
				if (opt != "?") {
					if (debug) {
						al_print("elem(not found): xpath = " + abs_xpath + "\n\n");
					} else {
					}
					return "xpath \"" + abs_xpath + "\" requrired.";
				} else {
				}
			}
			continue;
		} else {
		}
		if (type == "as_text") {
			if (xml_itr.getNodeAsText(abs_xpath)) {
				if (save && xml_itr.value) {
					putValue("0", dtd_itr.rel_xpath, xml_itr.value);
				} else {
				}
				read_tag_count = read_tag_count + 1;
				if (debug) {
					al_print("as_text: value = " + (string)xml_itr.value + ", xpath = " + abs_xpath + "\n\n");
				} else {
				}
			} else {
				if (opt != "?") {
					if (debug) {
						al_print("as_text(not found): xpath = " + abs_xpath + "\n\n");
					} else {
					}
					return "xpath \"" + abs_xpath + "\" requrired.";
				} else {
				}
			}
			continue;
		} else {
		}
	}
}
end_body
member
public: void save;
member
public: void Begin();
body
{
	dataId = getMsgId();
	if (msgId) {
	} else {
		msgId = dataId;
	}
	parentId = "0";
	if (msgType && msgVersion) {
		tagId = msgType + "-" + msgVersion;
	} else {
		tagId = "0";
	}
	child_seq = field_seq = 0;
	values = al_cons(null, null);
}
end_body
member
public: void End();
body
{
	Flush();
}
end_body
member
public: void BeginRepetition(string abs_xpath, string xpath);
body
{
	var list info;
	child_seq = child_seq + 1;
	info = al_list8(dataId, parentId, tagId, child_seq, field_seq, values, null, abs_xpath);
	stack = al_cons(info, stack);
	parentId = dataId;
	dataId = dataId + "c" + XmlDbAccessor::digit5(child_seq);
	tagId = stack.head.tail.tail.tail.tail.tail.tail.head = XPath2TagId(xpath);
	child_seq = field_seq = 0;
	values = al_cons(null, null);
}
end_body
member
public: void ContinueRepetition();
body
{
	Flush();
	child_seq = stack.head.tail.tail.tail.head;
	child_seq = child_seq + 1;
	stack.head.tail.tail.tail.head = child_seq;
	parentId = stack.head.head;
	dataId = stack.head.head + "c" + XmlDbAccessor::digit5(child_seq);
	tagId = stack.head.tail.tail.tail.tail.tail.tail.head;
	child_seq = field_seq = 0;
	values = al_cons(null, null);
}
end_body
member
public: void BreakRepetition();
body
{
	var list info;
	info = stack.head;
	dataId = info.head;
	parentId = info.tail.head;
	tagId = info.tail.tail.head;
	child_seq = info.tail.tail.tail.head;
	field_seq = info.tail.tail.tail.tail.head;
	values = info.tail.tail.tail.tail.tail.head;
	stack = stack.tail;
}
end_body
member
public: string getMsgId();
body
{
	return "1";
}
end_body
member
public: string msgType;
member
public: string msgVersion;
member
public: string putValue(string kind, string xpath, string value);
body
{
	if (kind == "0") {
		al_create_arc(values, value, xpath);
	} else {
	}
}
end_body
member
public: void Flush();
body
{
	var list itr;
	var string path2, value2, dataId2;
	itr = al_dst_itr(values);
	loop {
		if (value2 = al_next(itr)) {
		} else {
			break;
		}
		path2 = al_arc_a(itr);
		dataId2 = dataId + "f" + XmlDbAccessor::digit5(field_seq = field_seq + 1);
		value2 = al_str_misc("to_csv_string", value2, null);
		al_print("F," + dataId2 + "," + msgId + "," + dataId + "," + value2 + "," + path2 + "\n");
	}
	al_print("C," + dataId + "," + msgId + "," + parentId + ",," + tagId + "\n");
}
end_body
member
public: string XPath2TagId(string xpath);
body
{
	return xpath;
}
end_body
member
public: string dataId;
member
public: string msgId;
member
public: string parentId;
member
public: string tagId;
member
public: integer child_seq;
member
public: integer field_seq;
member
public: string last_repetition_xpath;
member
public: list values;
member
public: list stack;
member
public: integer read_tag_count;
member
public: integer read_elem_count;
member
public: integer read_recursive_tag_count;
class SimpleXml2Db
member
public: void Begin();
body
{
	if (msgType) {
	} else {
		msgType = "default";
	}
	if (msgVersion) {
	} else {
		msgVersion = "default";
	}
	createXPathTagIdMap();
	XmlValidator::Begin();
}
end_body
member
public: void End();
body
{
	XmlValidator::End();
}
end_body
member
public: void BeginRepetition(string abs_xpath, string xpath);
body
{
	XmlValidator::BeginRepetition(abs_xpath, xpath);
}
end_body
member
public: void ContinueRepetition();
body
{
	XmlValidator::ContinueRepetition();
}
end_body
member
public: void BreakRepetition();
body
{
	XmlValidator::BreakRepetition();
}
end_body
member
public: string getMsgId();
body
{
	if (acc) {
	} else {
		acc = new XmlDbAccessor;
		acc.create(msgType, msgVersion, conn);
	}
	return acc.getMsgId();
}
end_body
member
public: string putValue(string kind, string xpath, string value);
body
{
	if (content_validate) {
		var list t, d;
		var string e;
		if (t = al_dst_node(dtd_itr.node, "$type")) {
			if (al_xml("type_check", value, t, null)) {
				e = "dictionary type check error, value = " + (value == ctrl_a ? "" : value) + ", tag = " + dtd_itr.abs_xpath;
				if (validation_errors) {
					validation_errors = validation_errors + "; " + e;
				} else {
					validation_errors = e;
				}
				if (content_validation_report) {
					al_print("putXML: type check error: value = " + value + ", tag = " + dtd_itr.abs_xpath + ", type = " + (string)t + "\n");
				} else {
				}
			} else {
			}
		} else {
		}
		if (d = al_dst_node(dtd_itr.node, "$dic")) {
			if (al_xml("dic_check", value, d, null)) {
				e = "dictionary check error, value = " + (value == ctrl_a ? "" : value) + ", tag = " + dtd_itr.abs_xpath;
				if (validation_errors) {
					validation_errors = validation_errors + "; " + e;
				} else {
					validation_errors = e;
				}
				if (content_validation_report) {
					al_print("putXML: dic check error: value = " + value + ", tag = " + dtd_itr.abs_xpath + ", dic = " + (string)d + "\n");
				} else {
				}
			} else {
			}
		} else {
		}
	} else {
	}
	XmlValidator::putValue(kind, xpath, value);
}
end_body
member
public: void Flush();
body
{
	var string sql, path2, tagId2, value2, dataId2;
	var list itr;
	itr = al_dst_itr(values);
	loop {
		if (value2 = al_next(itr)) {
		} else {
			break;
		}
		if (al_strlen(value2) > XmlDbObject::MAX_VALUE_SIZE) {
			value2 = al_substr(value2, 0, XmlDbObject::MAX_VALUE_SIZE);
		} else {
		}
		path2 = al_arc_a(itr);
		tagId2 = XPath2TagId(path2);
		dataId2 = dataId + "f" + XmlDbAccessor::digit5(field_seq = field_seq + 1);
		sql = al_copy("");
		al_append_str(sql, "insert into MsgData (dataId,msgId,parentId,tagId,value) values('");
		al_append_str(sql, dataId2);
		al_append_str(sql, "','");
		al_append_str(sql, msgId);
		al_append_str(sql, "','");
		al_append_str(sql, dataId);
		al_append_str(sql, "','");
		al_append_str(sql, tagId2);
		al_append_str(sql, "','");
		al_append_str(sql, DbUtility::convChar(value2));
		al_append_str(sql, "')");
		conn.executeUpdate(sql);
	}
	sql = al_copy("");
	if (parentId == "0") {
		al_append_str(sql, "insert into ParentRelation (dataId,msgId,msgType,msgVersion,dtdFile,parentId,tagId,fieldSeq,childSeq) values('");
	} else {
		al_append_str(sql, "insert into ParentRelation (dataId,msgId,parentId,tagId,fieldSeq,childSeq) values('");
	}
	al_append_str(sql, dataId);
	al_append_str(sql, "','");
	al_append_str(sql, msgId);
	al_append_str(sql, "','");
	if (parentId == "0") {
		al_append_str(sql, DbUtility::convChar(msgType));
		al_append_str(sql, "','");
		al_append_str(sql, DbUtility::convChar(msgVersion));
		al_append_str(sql, "','");
		al_append_str(sql, DbUtility::convChar(acc._dtd_filename));
		al_append_str(sql, "','");
	} else {
	}
	al_append_str(sql, parentId);
	al_append_str(sql, "','");
	al_append_str(sql, tagId);
	al_append_str(sql, "','");
	al_append_str(sql, (string)field_seq);
	al_append_str(sql, "','");
	al_append_str(sql, (string)child_seq);
	al_append_str(sql, "')");
	conn.executeUpdate(sql);
}
end_body
member
public: string getTagId();
body
{
	if (acc) {
	} else {
		acc = new XmlDbAccessor;
		acc.create(msgType, msgVersion, conn);
	}
	return acc.getTagId();
}
end_body
member
public: string XPath2TagId(string xpath);
body
{
	if (acc) {
	} else {
		acc = new XmlDbAccessor;
		acc.create(msgType, msgVersion, conn);
	}
	return acc.XPath2TagId(xpath);
}
end_body
member
public: void createXPathTagIdMap();
body
{
	if (acc) {
	} else {
		acc = new XmlDbAccessor;
		acc.create(msgType, msgVersion, conn);
	}
	acc.createTagPathMap();
	map = acc.map;
}
end_body
member
public: list map;
member
public: DbConnection conn;
member
public: string db_type;
member
public: XmlDbAccessor acc;
end_class
end_class
class XmlComposer
member
public: list compose(list dtd);
body
{
	xml_debug();
	var list err;
	handler = new XmlComposerHandler;
	handler.debug = debug;
	handler.composer = this;
	if (err = Begin()) {
		return err;
	} else {
	}
	xml = al_copy("");
	out_str("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
	if (doctype && dtd_filename) {
		out_str("<!DOCTYPE ");
		out_str(doctype);
		out_str(" SYSTEM \"");
		out_str(dtd_filename);
		out_str("\">");
	} else {
	}
	dtd_itr = new DtdItr;
	dtd_itr.handler = handler;
	dtd_itr.Reset(dtd);
	read_tag_count = 0;
	if (err = compose1()) {
		clear();
		return err;
	} else {
	}
	if (dtd_itr.type != "end") {
		err = "data is not enough: xpath = \"" + dtd_itr.abs_xpath + "\"";
		clear();
		return err;
	} else {
	}
	clear();
	return null;
}
end_body
member
public: list compose1();
body
{
	var list err;
	var string type, abs_xpath, attr, opt, xml_save1, xml_save2;
	var integer count, read_tag_count_save;
	loop {
		type = dtd_itr.Next(null);
		if (al_dst_node(dtd_itr.node, "$recursive") && dtd_itr.node.tail.tail.head) {
			var string check_xpath;
			check_xpath = recursive_check_xpath(dtd_itr.abs_xpath);
			if (recursive_expand_tag_count) {
				if (count = al_dst_node(recursive_expand_tag_count, check_xpath)) {
					if (read_tag_count == count) {
						if (debug) {
							al_print("compose1: return; recursive tag '" + dtd_itr.abs_xpath + "' expanded although no tags are readed after last recursive tag is expanded.\n\n");
						} else {
						}
						return "recursive tag '" + dtd_itr.abs_xpath + "' expanded although no tags are readed after last recursive tag is expanded.";
					} else {
					}
				} else {
				}
			} else {
				recursive_expand_tag_count = al_cons(null, null);
			}
			al_set_dst_node(recursive_expand_tag_count, check_xpath, read_tag_count);
		} else {
		}
		if (type == "end_optional" || type == "end_repetition" || type == "end_case" || type == "end_all_opt" || type == "end") {
			return null;
		} else {
		}
		abs_xpath = dtd_itr.abs_xpath;
		attr = dtd_itr.attr;
		opt = dtd_itr.opt;
		if (type == "repetition") {
			if (debug) {
				al_print("Enter repetition: xpath = " + abs_xpath + "\n\n");
			} else {
			}
			if (GetChildren(dtd_itr.rel_xpath)) {
			} else {
				if (opt != "*") {
					BreakRepetition();
					return "repetition xpath \"" + abs_xpath + "\" requrired.";
				} else {
					xml_save1 = xml;
					xml = null;
					dtd_itr.BreakRepetition();
					xml = xml_save1;
					BreakRepetition();
					continue;
				}
			}
			count = 0;
			loop {
				if (nextChild()) {
					if (GetFields()) {
					} else {
						BreakRepetition();
						return "data is not enough: xpath = \"" + dtd_itr.abs_xpath + "\"";
					}
					if (compose1()) {
						break;
					} else {
						count = count + 1;
						dtd_itr.ContinueRepetition();
						continue;
					}
				} else {
					break;
				}
			}
			if (count == 0) {
				if (opt != "*") {
					BreakRepetition();
					return "repetition xpath \"" + abs_xpath + "\" requrired.";
				} else {
				}
			} else {
				xml_save1 = xml;
				xml = null;
				dtd_itr.BreakRepetition();
				xml = xml_save1;
				BreakRepetition();
			}
			if (debug) {
				al_print("Leave repetition: xpath = " + abs_xpath + "\n\n");
			} else {
			}
			continue;
		} else {
		}
		if (type == "optional") {
			var list found;
			if (debug) {
				al_print("Enter optional: xpath = " + abs_xpath + "\n\n");
			} else {
			}
			var list recursive_expand_tag_count_save;
			read_tag_count_save = read_tag_count;
			recursive_expand_tag_count_save = al_copy(recursive_expand_tag_count);
			xml_save1 = xml;
			xml = al_copy("");
			if (compose1()) {
				handler.out_current_tag();
				skip_optional();
				xml = xml_save1;
				read_tag_count = read_tag_count_save;
				recursive_expand_tag_count = recursive_expand_tag_count_save;
			} else {
				if (read_tag_count > read_tag_count_save) {
					xml_save2 = xml;
					xml = xml_save1;
					out_str(xml_save2);
					found = 1;
				} else {
					xml = xml_save1;
				}
			}
			if (found) {
				if (debug) {
					al_print("Leave optional(found): xpath = " + abs_xpath + "\n\n");
				} else {
				}
			} else {
				if (debug) {
					al_print("Leave optional(not found): xpath = " + abs_xpath + "\n\n");
				} else {
				}
			}
			continue;
		} else {
		}
		if (type == "choice") {
			if (debug) {
				al_print("Enter choice: xpath = " + abs_xpath + "\n\n");
			} else {
			}
			handler.out_current_tag();
			loop {
				type = dtd_itr.Next(null);
				if (type == "case") {
					break;
				} else {
				}
			}
			xml_save1 = xml;
			loop {
				xml = al_copy("");
				if (type == "case") {
					if (debug) {
						al_print("Enter choice_case: xpath = " + abs_xpath + "\n\n");
					} else {
					}
					read_tag_count_save = read_tag_count;
					var list found;
					if (compose1()) {
					} else {
						if (read_tag_count == read_tag_count_save) {
						} else {
							handler.out_current_tag();
							xml_save2 = xml;
							xml = xml_save1;
							out_str(xml_save2);
							found = 1;
						}
					}
					if (found) {
						xml_save1 = xml;
						xml = null;
						skip_choice();
						xml = xml_save1;
						if (debug) {
							al_print("Leave choice_case(found): xpath = " + abs_xpath + "\n\n");
						} else {
						}
						break;
					} else {
						if (read_tag_count == read_tag_count_save) {
						} else {
							xml = null;
							skip_case();
						}
						if (debug) {
							al_print("Leave choice_case(not found): xpath = " + abs_xpath + "\n\n");
						} else {
						}
					}
				} else {
				}
				type = dtd_itr.Next((list)1);
				if (type == "choice") {
					skip_choice();
				} else {
				}
				if (type == "end_choice") {
					if (opt != "?") {
						if (debug) {
							al_print("Leave choice(not found): xpath = " + abs_xpath + "\n\n");
						} else {
						}
						return "choice xpath \"" + abs_xpath + "\" requrired.";
					} else {
					}
					break;
				} else {
				}
			}
			if (debug) {
				al_print("Leave choice(found): xpath = " + abs_xpath + "\n\n");
			} else {
			}
			continue;
		} else {
		}
		if (type == "all_opt") {
			if (debug) {
				al_print("Enter all_opt: xpath = " + abs_xpath + "\n\n");
			} else {
			}
			var list all_opt, brk_all_opt;
			var string tag, path, xml_save;
			tag = dtd_itr.tag;
			path = dtd_itr.rel_xpath;
			if (getValue(path)) {
				all_opt = 1;
				handler.out_current_tag();
				read_tag_count = read_tag_count + 1;
				brk_all_opt = 1;
				if (debug) {
					al_print("elem(all opt): value = " + (string)value + ", xpath = " + abs_xpath + "\n\n");
				} else {
				}
			} else {
				if (compose1()) {
					brk_all_opt = 1;
				} else {
				}
			}
			if (brk_all_opt) {
				xml_save = xml;
				xml = al_copy("");
				skip_all_opt();
				xml = xml_save;
			} else {
			}
			if (all_opt) {
				handler.out_str("</");
				handler.out_str(tag);
				handler.out_str(">");
			} else {
			}
			if (debug) {
				al_print("Leave all_opt: xpath = " + path + ", abs_xpath = " + abs_xpath + "\n\n");
			} else {
			}
			continue;
		} else {
		}
		if (type == "attr") {
			if (dtd_itr.node.tail.tail.tail.head == "#FIXED" && al_dst_node(dtd_itr.node, "$scope") != "global") {
				value = dtd_itr.node.tail.tail.tail.tail.head;
				if (handler.current_attrs) {
				} else {
					handler.current_attrs = al_cons(null, null);
				}
				var string ns_name, ns_url, g_url;
				var list itr2;
				g_url = ns_url = al_dst_node(dtd_itr.node, "$namespace");
				itr2 = al_dst_itr(dtd_itr.ns_stack);
				if (ns_url || al_next(itr2) && ns_url = al_arc_a(itr2)) {
					if (ns_name = al_dst_node(dtd_itr.ns_stack, ns_url)) {
						if (handler && g_url) {
							if (al_dst_node(handler.ns_names, ns_url)) {
							} else {
								al_create_arc(handler.ns_names, ns_name, ns_url);
							}
						} else {
						}
					} else {
					}
				} else {
					if (handler) {
						ns_name = handler.ns_name;
					} else {
					}
				}
				if (ns_name && ns_name != "" && al_str_misc("starts_with", attr, "xmlns") == null) {
					al_create_arc(handler.current_attrs, al_list2(ns_name + ":" + attr, value), null);
				} else {
					al_create_arc(handler.current_attrs, al_list2(attr, value), null);
				}
				read_tag_count = read_tag_count + 1;
				if (debug) {
					al_print("attr: value = " + (string)value + ", xpath = " + abs_xpath + "/@" + attr + "\n\n");
				} else {
				}
				continue;
			} else {
			}
			var string p;
			if (dtd_itr.rel_xpath == "") {
				p = "@" + dtd_itr.attr;
			} else {
				p = dtd_itr.rel_xpath + "/@" + dtd_itr.attr;
			}
			if (getValue(p)) {
				if (handler.current_attrs) {
				} else {
					handler.current_attrs = al_cons(null, null);
				}
				var string ns_name, ns_url, g_url;
				var list itr2;
				g_url = ns_url = al_dst_node(dtd_itr.node, "$namespace");
				itr2 = al_dst_itr(dtd_itr.ns_stack);
				if (ns_url || al_next(itr2) && ns_url = al_arc_a(itr2)) {
					if (ns_name = al_dst_node(dtd_itr.ns_stack, ns_url)) {
						if (handler && g_url) {
							if (al_dst_node(handler.ns_names, ns_url)) {
							} else {
								al_create_arc(handler.ns_names, ns_name, ns_url);
							}
						} else {
						}
					} else {
					}
				} else {
					if (handler) {
						ns_name = handler.ns_name;
					} else {
					}
				}
				if (ns_name && ns_name != "" && al_str_misc("starts_with", attr, "xmlns") == null) {
					al_create_arc(handler.current_attrs, al_list2(ns_name + ":" + attr, value), null);
				} else {
					al_create_arc(handler.current_attrs, al_list2(attr, value), null);
				}
				read_tag_count = read_tag_count + 1;
				if (debug) {
					al_print("attr: value = " + (string)value + ", xpath = " + abs_xpath + "/@" + attr + "\n\n");
				} else {
				}
			} else {
				if (dtd_itr.node.tail.tail.tail.head == "#REQUIRED") {
					if (debug) {
						al_print("attr(not found): xpath = " + abs_xpath + "/@" + attr + "\n\n");
					} else {
					}
					return "xpath \"" + abs_xpath + "/@" + "\" requrired.";
				} else {
				}
			}
			continue;
		} else {
		}
		if (type == "elem") {
			if (getValue(dtd_itr.rel_xpath)) {
				if (handler.current_value) {
					al_print("%%% handler.current_value is not null.\n");
				} else {
				}
				if (handler.raw_current_value) {
					al_print("%%% handler.raw_current_value is not null.\n");
				} else {
				}
				if (value != ctrl_a) {
					handler.current_value = value;
				} else {
				}
				read_tag_count = read_tag_count + 1;
				if (debug) {
					al_print("elem: value = " + (string)value + ", xpath = " + abs_xpath + "\n\n");
				} else {
				}
			} else {
				if (debug) {
					al_print("elem(not found): xpath = " + abs_xpath + "\n\n");
				} else {
				}
				return "xpath \"" + abs_xpath + "\" requrired.";
			}
			continue;
		} else {
		}
		if (type == "as_text") {
			if (getValue(dtd_itr.rel_xpath)) {
				if (handler.current_value) {
					al_print("%%% handler.current_value is not null.\n");
				} else {
				}
				if (handler.raw_current_value) {
					al_print("%%% handler.raw_current_value is not null.\n");
				} else {
				}
				if (value != ctrl_a) {
					handler.raw_current_value = value;
				} else {
				}
				read_tag_count = read_tag_count + 1;
				if (debug) {
					al_print("as_text: value = " + (string)value + ", xpath = " + abs_xpath + "\n\n");
				} else {
				}
			} else {
				if (debug) {
					al_print("as_text(not found): xpath = " + abs_xpath + "\n\n");
				} else {
				}
				return "xpath \"" + abs_xpath + "\" requrired.";
			}
			continue;
		} else {
		}
	}
}
end_body
member
public: void clear();
body
{
	handler.composer = null;
	handler = null;
	dtd_itr.handler = null;
	dtd_itr = null;
}
end_body
member
public: string recursive_check_xpath(string xpath);
body
{
	var list ls, itr;
	var string last_tag, tag, check_xpath;
	ls = al_str_misc("split", xpath, '/');
	itr = al_dst_itr(ls);
	check_xpath = last_tag = al_prev(itr);
	loop {
		if (tag = al_prev(itr)) {
		} else {
			break;
		}
		if (tag == last_tag) {
			break;
		} else {
		}
		check_xpath = tag + "/" + check_xpath;
	}
	return check_xpath;
}
end_body
member
public: string doctype;
member
public: string dtd_filename;
member
public: string xml;
member
public: void out_str(string val);
body
{
	if (xml) {
		al_append_str(xml, val);
	} else {
	}
}
end_body
member
public: list Begin();
body
{
}
end_body
member
public: list GetFields();
body
{
}
end_body
member
public: list GetChildren(string path);
body
{
}
end_body
member
public: list nextChild();
body
{
}
end_body
member
public: void BreakRepetition();
body
{
}
end_body
member
public: string getValue(string path);
body
{
}
end_body
member
public: string msgType;
member
public: string msgVersion;
member
public: string value;
member
public: XmlComposerHandler handler;
member
public: integer read_tag_count;
member
public: list recursive_expand_tag_count;
class SimpleDb2Xml
member
public: list Begin();
body
{
	if (msgType) {
	} else {
		msgType = "default";
	}
	if (msgVersion) {
	} else {
		msgVersion = "default";
	}
	createTagIdPathMap();
	parentId = "0";
	tagId = msgType + "-" + msgVersion;
	var string path;
	if (GetChildren(path)) {
	} else {
		return "data not found: msgId = " + (string)msgId;
	}
	dataId = al_next(children);
	al_prev(children);
	if (GetFields()) {
	} else {
		return "data not found: msgId = " + (string)msgId;
	}
	return null;
}
end_body
member
public: list GetFields();
body
{
	var string sql, path2, tagId2, value2;
	var list rs, itr, rec;
	sql = al_copy("");
	al_append_str(sql, "select tagId, value from MsgData ");
	al_append_str(sql, "where msgId ='");
	al_append_str(sql, msgId);
	al_append_str(sql, "' and parentId='");
	al_append_str(sql, dataId);
	al_append_str(sql, "' order by dataId");
	rs = conn.executeQuery(2, sql);
	itr = al_dst_itr(rs);
	values = al_cons(null, null);
	loop {
		if (rec = al_next(itr)) {
		} else {
			break;
		}
		tagId2 = al_dst_node(rec, 1);
		value2 = al_dst_node(rec, 2);
		if (tagId2 && value2) {
		} else {
			break;
		}
		if (path2 = al_dst_node(map2, tagId2)) {
		} else {
			return null;
		}
		al_create_arc(values, value2, path2);
	}
	return 1;
}
end_body
member
public: list GetChildren(string path);
body
{
	var list info;
	info = al_list6(dataId, tagId, values, children, null, null);
	stack = al_cons(info, stack);
	var string sql, dataId2;
	if (path) {
		if (tagId = stack.head.tail.tail.tail.head = al_dst_node(map, path)) {
		} else {
			// return "not found tagId of path \'" + path + "\'";
			return null;
		}
	} else {
		tagId = stack.head.tail.tail.tail.head = msgType + "-" + msgVersion;
	}
	var list rs, itr, rec, ret;
	sql = al_copy("");
	al_append_str(sql, "select dataId from ParentRelation where msgId='");
	al_append_str(sql, msgId);
	al_append_str(sql, "' and parentId='");
	if (path) {
		al_append_str(sql, dataId);
	} else {
		al_append_str(sql, "0");
	}
	al_append_str(sql, "'  and tagId='");
	al_append_str(sql, tagId);
	al_append_str(sql, "' order by dataId");
	rs = conn.executeQuery(1, sql);
	itr = al_dst_itr(rs);
	children = al_cons(null, null);
	loop {
		if (rec = al_next(itr)) {
		} else {
			break;
		}
		dataId2 = al_dst_node(rec, 1);
		al_create_arc(children, dataId2, null);
		ret = 1;
	}
	children = stack.head.tail.tail.tail.tail.head = al_dst_itr(children);
	return ret;
}
end_body
member
public: list nextChild();
body
{
	children = stack.head.tail.tail.tail.tail.head;
	var list dataId2;
	if (dataId2 = al_next(children)) {
		dataId = dataId2;
		tagId = stack.head.tail.tail.tail.head;
		return 1;
	} else {
		return null;
	}
}
end_body
member
public: void BreakRepetition();
body
{
	var list info;
	info = stack.head;
	stack = stack.tail;
	dataId = info.head;
	tagId = info.tail.head;
	values = info.tail.tail.head;
	children = info.tail.tail.tail.head;
}
end_body
member
public: string getValue(string path);
body
{
	value = al_dst_node(values, path);
	if (value == ctrl_a) {
		value = "";
	} else {
	}
	if (content_validate) {
		var list t, d;
		var string e;
		if (t = al_dst_node(dtd_itr.node, "$type")) {
			if (al_xml("type_check", value, t, null)) {
				e = "dictionary type check error, value = " + value + ", tag = " + dtd_itr.abs_xpath;
				if (validation_errors) {
					validation_errors = validation_errors + "; " + e;
				} else {
					validation_errors = e;
				}
				if (content_validation_report) {
					al_print("getXML: type check error: value = " + value + ", tag = " + dtd_itr.abs_xpath + ", type = " + (string)t + "\n");
				} else {
				}
			} else {
			}
		} else {
		}
		if (d = al_dst_node(dtd_itr.node, "$dic")) {
			if (al_xml("dic_check", value, d, null)) {
				e = "dictionary check error, value = " + value + ", tag = " + dtd_itr.abs_xpath;
				if (validation_errors) {
					validation_errors = validation_errors + "; " + e;
				} else {
					validation_errors = e;
				}
				if (content_validation_report) {
					al_print("getXML: dic check error: value = " + value + ", tag = " + dtd_itr.abs_xpath + ", dic = " + (string)d + "\n");
				} else {
				}
			} else {
			}
		} else {
		}
	} else {
	}
	return value;
}
end_body
member
public: void createTagIdPathMap();
body
{
	if (acc) {
	} else {
		acc = new XmlDbAccessor;
		acc.create(msgType, msgVersion, conn);
	}
	acc.createTagPathMap();
	map = acc.map;
	map2 = acc.map2;
}
end_body
member
public: string dataId;
member
public: string msgId;
member
public: string parentId;
member
public: string tagId;
member
public: list values;
member
public: list children;
member
public: list stack;
member
public: list map;
member
public: list map2;
member
public: DbConnection conn;
member
public: string db_type;
member
public: XmlDbAccessor acc;
end_class
end_class
class XmlDataRetriver
member
public: void create(list tree);
body
{
	body_tree = tree;
}
end_body
member
public: list tag_tree;
member
public: list body_tree;
member
public: list itr;
member
public: string tag;
member
public: XmlDataRetriver getItr(string xpath);
body
{
	var list body_tree2, tag_tree2, tags, itr2;
	var string tag2;
	tag_tree2 = tag_tree;
	body_tree2 = body_tree;
	tags = al_str_misc("split", xpath, '/');
	itr2 = al_dst_itr(tags);
	loop {
		if (tag2 = al_next(itr2)) {
		} else {
			return null;
		}
		if (al_next(itr2)) {
			al_prev(itr2);
		} else {
			break;
		}
		if (tag_tree2 = al_dst_node(body_tree2, tag2)) {
		} else {
			return null;
		}
		if (body_tree2 = al_dst_node(tag_tree2, "!body")) {
		} else {
			return null;
		}
	}
	var XmlDataRetriver obj;
	obj = new XmlDataRetriver;
	obj.itr = al_dst_itr(body_tree2);
	obj.tag = tag2;
	return obj;
}
end_body
member
public: XmlDataRetriver getNext();
body
{
	var list tag_tree2, body_tree2;
	if (tag_tree2 = al_next_a(itr, tag)) {
	} else {
		return null;
	}
	if (body_tree2 = al_dst_node(tag_tree2, "!body")) {
	} else {
		return null;
	}
	var XmlDataRetriver obj;
	obj = new XmlDataRetriver;
	obj.tag_tree = tag_tree2;
	obj.body_tree = body_tree2;
	obj.itr = itr;
	obj.tag = tag;
	return obj;
}
end_body
member
public: string getValue(string xpath);
body
{
	var list body_tree2, tag_tree2, tags, itr2, param;
	var string tag2, text;
	tag_tree2 = tag_tree;
	body_tree2 = body_tree;
	tags = al_str_misc("split", xpath, '/');
	itr2 = al_dst_itr(tags);
	loop {
		if (tag2 = al_next(itr2)) {
		} else {
			return null;
		}
		if (al_next(itr2)) {
			al_prev(itr2);
		} else {
			break;
		}
		if (tag_tree2 = al_dst_node(body_tree2, tag2)) {
		} else {
			return null;
		}
		if (body_tree2 = al_dst_node(tag_tree2, "!body")) {
		} else {
			return null;
		}
	}
	if (al_strlen(tag2) > 0 && al_get_char(tag2, 0) == '@') {
		tag2 = al_substr(tag2, 1, al_strlen(tag2));
		if (param = al_dst_node(tag_tree2, tag2)) {
			text = param.head;
			return text == "" ? null : text;
		} else {
			return null;
		}
	} else {
		if (tag_tree2 = al_dst_node(body_tree2, tag2)) {
		} else {
			return null;
		}
		if (body_tree2 = al_dst_node(tag_tree2, "!body")) {
		} else {
			return null;
		}
		text = al_dst_node(body_tree2, "!text");
		return text == "" ? null : text;
	}
}
end_body
end_class
class XmlDbAccessor
member
public: void create(string msgType, string msgVersion, DbConnection conn);
body
{
	if (msgType && msgType != "") {
	} else {
		msgType = "default";
	}
	if (msgVersion && msgVersion != "") {
	} else {
		msgVersion = "default";
	}
	this.msgType = msgType;
	this.msgVersion = msgVersion;
	this.conn = conn;
	db_type = conn.db_type;
}
end_body
member
public: void setDTD(list dtd);
body
{
	_dtd = dtd;
}
end_body
member
public: void setDTDbase(string dtd_base);
body
{
	_dtd_base = dtd_base;
}
end_body
member
public: void setDTDfilename(string dtd_filename);
body
{
	_dtd_filename = dtd_filename;
}
end_body
member
public: void setContentValidationBase(string content_validation_base);
body
{
	_content_validation_base = content_validation_base;
}
end_body
member
public: void setContentValidation(list flag);
body
{
	content_validate = flag;
}
end_body
member
public: void setDocType(string doc_type);
body
{
	_doc_type = doc_type;
}
end_body
member
public: string putXML(string xml);
body
{
	var file in;
	var list parse_tree;
	var string msgId;
	in = al_file_open(xml, "sr");
	parse_tree = parseXML(in, null);
	return putXML(parse_tree, msgId);
}
end_body
member
public: string putXML(string xml, string msgId);
body
{
	var file in;
	var list parse_tree;
	in = al_file_open(xml, "sr");
	parse_tree = parseXML(in, null);
	return putXML(parse_tree, msgId);
}
end_body
member
public: string putXML(list parse_tree, string msgId);
body
{
	if (_dtd) {
	} else {
		if (_dtd_filename) {
		} else {
			if (_dtd_filename = getDTDfile(parse_tree)) {
			} else {
				var AlException ex;
				ex = new AlException;
				ex.msg = "xml: dtd required for XmlDbAccessor::putXML.";
				throw ex;
			}
		}
		if (_dtd_base) {
		} else {
			_dtd_base = dtd_base;
		}
		_dtd = loadDTD(_dtd_base + "/" + _dtd_filename);
		if (_content_validation_base) {
		} else {
			_content_validation_base = content_validation_base;
		}
		var string filename;
		filename = _content_validation_base + "/" + msgType + "-" + msgVersion + ".csv";
		if (al_file_manip("does_exist", filename, null)) {
			DtdLoader::attach_content_validation_data(_dtd, filename);
		} else {
		}
	}
	try {
		var SimpleXml2Db xml2db;
		xml2db = new SimpleXml2Db;
		xml2db.save = 1;
		xml2db.db_type = conn.db_type;
		xml2db.conn = conn;
		xml2db.acc = this;
		xml2db.msgType = msgType;
		xml2db.msgVersion = msgVersion;
		xml2db.msgId = msgId;
		xml2db.content_validate = content_validate;
		var list err;
		if (err = xml2db.validate(_dtd, parse_tree)) {
			var AlException ex;
			ex = new AlException;
			ex.msg = (string)err;
			throw ex;
		} else {
		}
		validation_errors = xml2db.validation_errors;
		return xml2db.msgId;
	} catch (AlException e) {
		e.msg = "xml: XmlDbAccessor::putXML: " + e.msg;
		throw e;
	}
}
end_body
member
public: string getXML(string msgId);
body
{
	if (_dtd) {
	} else {
		if (_dtd_filename) {
		} else {
			var AlException ex;
			ex = new AlException;
			ex.msg = "xml: dtd required for XmlDbAccessor::getXML.";
			throw ex;
		}
		if (_dtd_base) {
		} else {
			_dtd_base = dtd_base;
		}
		_dtd = loadDTD(_dtd_base + "/" + _dtd_filename);
		if (_content_validation_base) {
		} else {
			_content_validation_base = content_validation_base;
		}
		var string filename;
		filename = _content_validation_base + "/" + msgType + "-" + msgVersion + ".csv";
		if (al_file_manip("does_exist", filename, null)) {
			DtdLoader::attach_content_validation_data(_dtd, filename);
		} else {
		}
	}
	try {
		var SimpleDb2Xml db2xml;
		db2xml = new SimpleDb2Xml;
		db2xml.msgId = msgId;
		db2xml.db_type = conn.db_type;
		db2xml.conn = conn;
		db2xml.acc = this;
		db2xml.msgType = msgType;
		db2xml.msgVersion = msgVersion;
		db2xml.doctype = _doc_type;
		db2xml.dtd_filename = _dtd_filename;
		db2xml.content_validate = content_validate;
		var list err;
		if (err = db2xml.compose(_dtd)) {
			var AlException ex;
			ex = new AlException;
			ex.msg = (string)err;
			throw ex;
		} else {
		}
		validation_errors = db2xml.validation_errors;
		return db2xml.xml;
	} catch (AlException e) {
		e.msg = "xml: XmlDbAccessor::getXML: " + e.msg;
		throw e;
	}
}
end_body
member
public: XmlDbObject create();
body
{
	var string msgId;
	return create(msgId);
}
end_body
member
public: XmlDbObject create(string msgId);
body
{
	createFieldList();
	if (map && map2) {
	} else {
		createTagPathMap();
	}
	var XmlDbObject obj;
	obj = new XmlDbObject;
	obj.msgType = msgType;
	obj.msgVersion = msgVersion;
	obj.conn = conn;
	obj.db_type = db_type;
	obj.acc = this;
	obj.dataId = getMsgId();
	if (msgId) {
		obj.msgId = msgId;
	} else {
		obj.msgId = obj.dataId;
	}
	obj.parentId = "0";
	obj.tagId = msgType + "-" + msgVersion;
	obj.field_seq = obj.child_seq = 0;
	obj.values = al_cons(null, null);
	obj.fetched = 1;
	obj.xpath_list = xpath_list;
	obj.dtd_itr = dtd_itr;
	var string sql;
	sql = al_copy("");
	al_append_str(sql, "insert into ParentRelation (dataId,msgId,msgType,msgVersion,dtdFile,parentId,tagId,fieldSeq,childSeq) values('");
	al_append_str(sql, obj.dataId);
	al_append_str(sql, "','");
	al_append_str(sql, obj.msgId);
	al_append_str(sql, "','");
	al_append_str(sql, DbUtility::convChar(msgType));
	al_append_str(sql, "','");
	al_append_str(sql, DbUtility::convChar(msgVersion));
	al_append_str(sql, "','");
	al_append_str(sql, DbUtility::convChar(_dtd_filename));
	al_append_str(sql, "','");
	al_append_str(sql, obj.parentId);
	al_append_str(sql, "','");
	al_append_str(sql, obj.tagId);
	al_append_str(sql, "','");
	al_append_str(sql, (string)obj.field_seq);
	al_append_str(sql, "','");
	al_append_str(sql, (string)obj.child_seq);
	al_append_str(sql, "')");
	conn.executeUpdate(sql);
	return obj;
}
end_body
member
public: XmlDbObject getMetaInfo();
body
{
	createFieldList();
	if (map && map2) {
	} else {
		createTagPathMap();
	}
	var XmlDbObject obj;
	obj = new XmlDbObject;
	obj.msgType = msgType;
	obj.msgVersion = msgVersion;
	obj.conn = conn;
	obj.db_type = db_type;
	obj.acc = this;
	obj.xpath_list = xpath_list;
	obj.dtd_itr = dtd_itr;
	return obj;
}
end_body
member
public: XmlDbObject get(string msgId);
body
{
	createFieldList();
	if (map && map2) {
	} else {
		createTagPathMap();
	}
	var string sql;
	var list rs, itr, rec;
	sql = al_copy("");
	al_append_str(sql, "select dataId, fieldSeq, childSeq from ParentRelation where msgId='");
	al_append_str(sql, msgId);
	al_append_str(sql, "' and parentId='0' and tagId='");
	al_append_str(sql, msgType + "-" + msgVersion);
	al_append_str(sql, "'");
	rs = conn.executeQuery(3, sql);
	itr = al_dst_itr(rs);
	if (rec = al_next(itr)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "xml: XmlDbAccessor::get: record not found: msgId=" + (string)msgId;
		throw ex;
	}
	var XmlDbObject obj;
	obj = new XmlDbObject;
	obj.msgType = msgType;
	obj.msgVersion = msgVersion;
	obj.conn = conn;
	obj.db_type = db_type;
	obj.acc = this;
	obj.dataId = al_dst_node(rec, 1);
	obj.field_seq = (integer)al_dst_node(rec, 2);
	obj.child_seq = (integer)al_dst_node(rec, 3);
	obj.msgId = msgId;
	obj.parentId = obj.tagId = "0";
	obj.xpath_list = xpath_list;
	obj.dtd_itr = dtd_itr;
	return obj;
}
end_body
member
public: XmlDbObject getWithMsgTypeAndMsgVersion(string msgId);
body
{
	var string sql;
	var list rs, itr, rec;
	sql = al_copy("");
	al_append_str(sql, "select msgType, msgVersion, dtdFile, dataId, fieldSeq, childSeq from ParentRelation where msgId='");
	al_append_str(sql, msgId);
	al_append_str(sql, "' and parentId='0'");
	rs = conn.executeQuery(3, sql);
	itr = al_dst_itr(rs);
	loop {
		if (rec = al_next(itr)) {
		} else {
			var AlException ex;
			ex = new AlException;
			ex.msg = "data not found: msgId = " + (string)msgId;
			throw ex;
		}
		msgType = al_dst_node(rec, 1);
		if (msgType == "Preamble" || msgType == "DeliveryHeader" || msgType == "ServiceHeader") {
			continue;
		} else {
		}
		msgVersion = al_dst_node(rec, 2);
		_dtd_filename = al_dst_node(rec, 3);
		var XmlDbAccessor acc;
		acc = new XmlDbAccessor;
		acc.create(msgType, msgVersion, conn);
		acc.setDTDfilename(_dtd_filename);
		acc.createFieldList();
		acc.createTagPathMap();
		var XmlDbObject obj;
		obj = new XmlDbObject;
		obj.msgType = msgType;
		obj.msgVersion = msgVersion;
		obj.conn = conn;
		obj.db_type = conn.db_type;
		obj.acc = acc;
		obj.dataId = al_dst_node(rec, 4);
		obj.field_seq = (integer)al_dst_node(rec, 5);
		obj.child_seq = (integer)al_dst_node(rec, 6);
		obj.msgId = msgId;
		obj.parentId = obj.tagId = "0";
		obj.xpath_list = acc.xpath_list;
		obj.dtd_itr = acc.dtd_itr;
		return obj;
	}
}
end_body
member
public: list getAll();
body
{
	return get((list)al_cons(null, null));
}
end_body
member
public: list get(string path, string value);
body
{
	var list cond;
	cond = al_cons(null, null);
	al_create_arc(cond, value, path);
	return get(cond);
}
end_body
member
public: list get(string path1, string value1, string path2, string value2);
body
{
	var list cond;
	cond = al_cons(null, null);
	al_create_arc(cond, value1, path1);
	al_create_arc(cond, value2, path2);
	return get(cond);
}
end_body
member
public: list get(string path1, string value1, string path2, string value2, string path3, string value3);
body
{
	var list cond;
	cond = al_cons(null, null);
	al_create_arc(cond, value1, path1);
	al_create_arc(cond, value2, path2);
	al_create_arc(cond, value3, path3);
	return get(cond);
}
end_body
member
public: list get(list cond);
body
{
	createFieldList();
	if (map && map2) {
	} else {
		createTagPathMap();
	}
	var string sql, path, value, tagId2;
	var list rs, itr, rec, ret;
	sql = al_copy("");
	al_append_str(sql, "select dataId, fieldSeq, childSeq, msgId from ParentRelation");
	al_append_str(sql, " where parentId='0' and tagId='");
	al_append_str(sql, msgType + "-" + msgVersion);
	al_append_str(sql, "'");
	itr = al_dst_itr(cond);
	loop {
		if (value = al_next(itr)) {
		} else {
			break;
		}
		path = al_arc_a(itr);
		if (tagId2 = XPath2TagId(path)) {
		} else {
			var AlException ex;
			ex = new AlException;
			ex.msg = "db accessor: can't find path '" + path + "' in (" + msgType + "," + msgVersion + ")";
			throw ex;
		}
		al_append_str(sql, " and dataId in (select parentId from MsgData where tagId='");
		al_append_str(sql, tagId2);
		if (isLike(value)) {
			al_append_str(sql, "' and value like '");
			al_append_str(sql, DbUtility::convChar(value));
			al_append_str(sql, "')");
		} else {
			al_append_str(sql, "' and value='");
			al_append_str(sql, DbUtility::convChar(value));
			al_append_str(sql, "')");
		}
	}
	al_append_str(sql, " order by dataId");
	if (count_max) {
		conn.setMaxResultSet(count_max);
	} else {
	}
	rs = conn.executeQuery(4, sql);
	conn.clearMaxResultSet();
	itr = al_dst_itr(rs);
	ret = al_cons(null, null);
	loop {
		if (rec = al_next(itr)) {
		} else {
			break;
		}
		var XmlDbObject obj;
		obj = new XmlDbObject;
		obj.msgType = msgType;
		obj.msgVersion = msgVersion;
		obj.conn = conn;
		obj.db_type = db_type;
		obj.acc = this;
		obj.dataId = al_dst_node(rec, 1);
		obj.field_seq = (integer)al_dst_node(rec, 2);
		obj.child_seq = (integer)al_dst_node(rec, 3);
		obj.msgId = al_dst_node(rec, 4);
		obj.parentId = obj.tagId = "0";
		obj.xpath_list = xpath_list;
		obj.dtd_itr = dtd_itr;
		al_create_arc(ret, obj, obj.dataId);
	}
	return ret;
}
end_body
member
public: list get(list cond, string range_path, string range_type, string from, string to, string orderby_path, string orderby_type, list desc);
body
{
	createFieldList();
	if (map && map2) {
	} else {
		createTagPathMap();
	}
	var string range_tagId, orderby_tagId;
	if (range_tagId = XPath2TagId(range_path)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "db accessor: can't find path '" + (string)range_path + "' in (" + msgType + "," + msgVersion + ")";
		throw ex;
	}
	if (orderby_path == null || orderby_tagId = XPath2TagId(orderby_path)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "db accessor: can't find path '" + (string)orderby_path + "' in (" + msgType + "," + msgVersion + ")";
		throw ex;
	}
	var string sql, path, value, tagId2;
	var list rs, itr, rec, ret;
	sql = al_copy("");
	if (orderby_tagId) {
		al_append_str(sql, "select p.dataId, p.fieldSeq, p.childSeq, p.msgId from ParentRelation p, MsgData r1, MsgData r2");
	} else {
		al_append_str(sql, "select p.dataId, p.fieldSeq, p.childSeq, p.msgId from ParentRelation p, MsgData r1");
	}
	al_append_str(sql, " where p.parentId='0' and p.tagId='");
	al_append_str(sql, msgType + "-" + msgVersion);
	al_append_str(sql, "' and p.dataId=r1.parentId and r1.tagId='");
	al_append_str(sql, range_tagId);
	al_append_str(sql, "'");
	if (range_type == "string") {
		al_append_str(sql, " and r1.value>='");
		al_append_str(sql, DbUtility::convChar(from));
		al_append_str(sql, "' and r1.value<='");
		al_append_str(sql, DbUtility::convChar(to));
		al_append_str(sql, "'");
	} else {
	}
	if (range_type == "integer") {
		al_append_str(sql, " and lpad(r1.value, 20, '0')>=lpad('");
		al_append_str(sql, DbUtility::convChar(from));
		al_append_str(sql, "', 20, '0') and lpad(r1.value, 20, '0')<=lpad('");
		al_append_str(sql, DbUtility::convChar(to));
		al_append_str(sql, "', 20, '0')");
	} else {
	}
	if (orderby_tagId) {
		al_append_str(sql, " and p.dataId=r2.parentId and r2.tagId='");
		al_append_str(sql, orderby_tagId);
		al_append_str(sql, "'");
	} else {
	}
	itr = al_dst_itr(cond);
	loop {
		if (value = al_next(itr)) {
		} else {
			break;
		}
		path = al_arc_a(itr);
		if (tagId2 = XPath2TagId(path)) {
		} else {
			var AlException ex;
			ex = new AlException;
			ex.msg = "db accessor: can't find path '" + path + "' in (" + msgType + "," + msgVersion + ")";
			throw ex;
		}
		al_append_str(sql, " and p.dataId in (select parentId from MsgData where tagId='");
		al_append_str(sql, tagId2);
		if (isLike(value)) {
			al_append_str(sql, "' and value like '");
			al_append_str(sql, DbUtility::convChar(value));
			al_append_str(sql, "')");
		} else {
			al_append_str(sql, "' and value='");
			al_append_str(sql, DbUtility::convChar(value));
			al_append_str(sql, "')");
		}
	}
	if (orderby_tagId) {
		if (orderby_type == "string") {
			if (desc == null) {
				al_append_str(sql, " order by r2.value");
			} else {
				al_append_str(sql, " order by r2.value desc");
			}
		} else {
		}
		if (orderby_type == "integer") {
			if (desc == null) {
				al_append_str(sql, " order by lpad(r2.value, 20, '0')");
			} else {
				al_append_str(sql, " order by lpad(r2.value, 20, '0') desc");
			}
		} else {
		}
	} else {
		if (desc == null) {
			al_append_str(sql, " order by p.dataId");
		} else {
			al_append_str(sql, " order by p.dataId desc");
		}
	}
	if (count_max) {
		conn.setMaxResultSet(count_max);
	} else {
	}
	rs = conn.executeQuery(4, sql);
	conn.clearMaxResultSet();
	itr = al_dst_itr(rs);
	ret = al_cons(null, null);
	loop {
		if (rec = al_next(itr)) {
		} else {
			break;
		}
		var XmlDbObject obj;
		obj = new XmlDbObject;
		obj.msgType = msgType;
		obj.msgVersion = msgVersion;
		obj.conn = conn;
		obj.db_type = db_type;
		obj.acc = this;
		obj.dataId = al_dst_node(rec, 1);
		obj.field_seq = (integer)al_dst_node(rec, 2);
		obj.child_seq = (integer)al_dst_node(rec, 3);
		obj.msgId = al_dst_node(rec, 4);
		obj.parentId = obj.tagId = "0";
		obj.xpath_list = xpath_list;
		obj.dtd_itr = dtd_itr;
		al_create_arc(ret, obj, obj.dataId);
	}
	return ret;
}
end_body
member
public: string msgType;
member
public: string msgVersion;
member
public: DbConnection conn;
member
public: string db_type;
member
public: list _dtd;
member
public: string _dtd_base;
member
public: string _content_validation_base;
member
public: string _dtd_filename;
member
public: string _doc_type;
member
public: void createTagPathMap();
body
{
	var string sql, tagId2, path2;
	var list rs, itr, rec;
	sql = al_copy("");
	al_append_str(sql, "select tagId, path from TagPathName where msgType='");
	al_append_str(sql, msgType);
	al_append_str(sql, "' and msgVersion='");
	al_append_str(sql, msgVersion);
	al_append_str(sql, "'");
	rs = conn.executeQuery(2, sql);
	itr = al_dst_itr(rs);
	map = al_cons(null, null);
	map2 = al_cons(null, null);
	loop {
		if (rec = al_next(itr)) {
		} else {
			break;
		}
		tagId2 = al_dst_node(rec, 1);
		if (path2 = al_dst_node(rec, 2)) {
		} else {
			path2 = al_copy("");
		}
		al_create_arc(map, tagId2, path2);
		al_create_arc(map2, path2, tagId2);
	}
}
end_body
member
public: string getTagId();
body
{
	return conn.getNextSeq("tagId_seq");
}
end_body
member
public: string XPath2TagId(string xpath);
body
{
	var string sql, tagId2;
	if (map) {
	} else {
		createTagPathMap();
	}
	if (tagId2 = al_dst_node(map, xpath)) {
		return tagId2;
	} else {
	}
	tagId2 = getTagId();
	sql = al_copy("");
	al_append_str(sql, "insert into TagPathName (tagId,path,msgType,msgVersion) values ('");
	al_append_str(sql, tagId2);
	al_append_str(sql, "','");
	al_append_str(sql, xpath);
	al_append_str(sql, "','");
	al_append_str(sql, msgType);
	al_append_str(sql, "','");
	al_append_str(sql, msgVersion);
	al_append_str(sql, "')");
	conn.executeUpdate(sql);
	al_create_arc(map, tagId2, xpath);
	return tagId2;
}
end_body
member
public: list map;
member
public: list map2;
member
public: string getMsgId();
body
{
	return conn.getNextSeq("msgId_seq");
}
end_body
member
public: static string digit5(integer val);
body
{
	if (val < 10) {
		return "0000" + (string)val;
	} else {
	}
	if (val < 100) {
		return "000" + (string)val;
	} else {
	}
	if (val < 1000) {
		return "00" + (string)val;
	} else {
	}
	if (val < 10000) {
		return "0" + (string)val;
	} else {
	}
	return (string)val;
}
end_body
member
public: void createFieldList();
body
{
	if (xpath_list) {
		return;
	} else {
	}
	if (_dtd) {
	} else {
		if (_dtd_base) {
		} else {
			_dtd_base = dtd_base;
		}
		if (_dtd_filename) {
			_dtd = loadDTD(_dtd_base + "/" + _dtd_filename);
		} else {
		}
	}
	if (_dtd) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "xml: dtd is null.";
		throw ex;
	}
	dtd_itr = new DtdItr;
	dtd_itr.Reset(_dtd);
	xpath_list = dtd_itr.getFieldList();
}
end_body
member
public: list xpath_list;
member
public: DtdItr dtd_itr;
member
public: integer count_max;
class XmlDbTableAccessor
member
public: string putXML(list parse_tree, string msgId);
body
{
	var AlException ex;
	ex = new AlException;
	ex.msg = "XmlDbTableAccessor::putXML not implemented.";
	throw ex;
}
end_body
member
public: string getXML(string msgId);
body
{
	var AlException ex;
	ex = new AlException;
	ex.msg = "XmlDbTableAccessor::getXML not implemented.";
	throw ex;
}
end_body
member
public: XmlDbObject create();
body
{
	var AlException ex;
	ex = new AlException;
	ex.msg = "XmlDbTableAccessor::create not implemented.";
	throw ex;
}
end_body
member
public: XmlDbObject create(string msgId);
body
{
	var AlException ex;
	ex = new AlException;
	ex.msg = "XmlDbTableAccessor::create not implemented.";
	throw ex;
}
end_body
member
public: XmlDbObject get(string msgId);
body
{
	createFieldList2();
	var list itr, rs, rec, pkey_values;
	var string name, sql;
	itr = al_dst_itr(pkey_names);
	name = al_next(itr);
	sql = al_copy("select ");
	al_append_str(sql, name);
	al_append_str(sql, " from ");
	al_append_str(sql, table_name);
	al_append_str(sql, " where ");
	al_append_str(sql, name);
	al_append_str(sql, "='");
	al_append_str(sql, DbUtility::convChar(msgId));
	al_append_str(sql, "'");
	rs = conn.executeQuery(1, sql);
	itr = al_dst_itr(rs);
	if (rec = al_next(itr)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "xml: XmlDbAccessor::get: record not found: msgId=" + (string)msgId;
		throw ex;
	}
	var XmlDbTableObject obj;
	obj = new XmlDbTableObject;
	obj.msgType = msgType;
	obj.msgVersion = msgVersion;
	obj.conn = conn;
	obj.db_type = db_type;
	obj.acc = this;
	obj.pkey_values = pkey_values = al_cons(null, null);
	al_create_arc(pkey_values, msgId, name);
	obj.xpath_list = xpath_list;
	obj.rev_xpath_list = rev_xpath_list;
	obj.table_name = table_name;
	obj.dtd_itr = dtd_itr;
	obj.dataId = msgId;
	return obj;
}
end_body
member
public: list get(list cond);
body
{
	createFieldList2();
	var string sql, name, path, value, dataId;
	var list first, itr, rs, rec, ret;
	var list itr2, pkey_values;
	var integer num_cols;
	sql = al_copy("");
	al_append_str(sql, "select ");
	itr = al_dst_itr(pkey_names);
	first = 1;
	num_cols = 0;
	loop {
		if (name = al_next(itr)) {
		} else {
			break;
		}
		if (first) {
			first = null;
		} else {
			al_append_str(sql, ",");
		}
		al_append_str(sql, name);
		num_cols = num_cols + 1;
	}
	al_append_str(sql, " from ");
	al_append_str(sql, table_name);
	itr = al_dst_itr(cond);
	first = 1;
	loop {
		if (value = al_next(itr)) {
		} else {
			break;
		}
		path = al_arc_a(itr);
		if (name = al_dst_node(xpath_list, path)) {
		} else {
			var AlException ex;
			ex = new AlException;
			ex.msg = "db accessor: can't find path '" + path + "' in (" + msgType + "," + msgVersion + ")";
			throw ex;
		}
		if (first) {
			first = null;
			al_append_str(sql, " where ");
		} else {
			al_append_str(sql, " and ");
		}
		al_append_str(sql, name);
		if (isLike(value)) {
			al_append_str(sql, " like '");
			al_append_str(sql, DbUtility::convChar(value));
			al_append_str(sql, "'");
		} else {
			al_append_str(sql, "='");
			al_append_str(sql, DbUtility::convChar(value));
			al_append_str(sql, "'");
		}
	}
	if (count_max) {
		conn.setMaxResultSet(count_max);
	} else {
	}
	rs = conn.executeQuery(num_cols, sql);
	conn.clearMaxResultSet();
	itr = al_dst_itr(rs);
	ret = al_cons(null, null);
	loop {
		if (rec = al_next(itr)) {
		} else {
			break;
		}
		var XmlDbTableObject obj;
		obj = new XmlDbTableObject;
		obj.msgType = msgType;
		obj.msgVersion = msgVersion;
		obj.conn = conn;
		obj.db_type = db_type;
		obj.acc = this;
		obj.pkey_values = pkey_values = al_cons(null, null);
		itr2 = al_dst_itr(pkey_names);
		num_cols = 0;
		dataId = "";
		loop {
			if (name = al_next(itr2)) {
			} else {
				break;
			}
			if (value = al_dst_node(rec, num_cols = num_cols + 1)) {
			} else {
				value = "";
			}
			if (dataId == "") {
				dataId = value;
			} else {
				dataId = dataId + ": " + value;
			}
			al_create_arc(pkey_values, value, name);
		}
		obj.xpath_list = xpath_list;
		obj.rev_xpath_list = rev_xpath_list;
		obj.table_name = table_name;
		obj.dtd_itr = dtd_itr;
		obj.dataId = dataId;
		al_create_arc(ret, obj, null);
	}
	return ret;
}
end_body
member
public: list get(list cond, string range_path, string range_type, string from, string to, string orderby_path, string orderby_type, list desc);
body
{
	createFieldList2();
	var string sql, name, path, value, dataId;
	var list first, itr, rs, rec, ret;
	var list itr2, pkey_values;
	var integer num_cols, i;
	sql = al_copy("");
	al_append_str(sql, "select ");
	itr = al_dst_itr(pkey_names);
	first = 1;
	num_cols = 0;
	loop {
		if (name = al_next(itr)) {
		} else {
			break;
		}
		if (first) {
			first = null;
		} else {
			al_append_str(sql, ",");
		}
		al_append_str(sql, name);
		num_cols = num_cols + 1;
	}
	al_append_str(sql, " from ");
	al_append_str(sql, table_name);
	al_append_str(sql, " where ");
	if (name = al_dst_node(xpath_list, range_path)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "db accessor: can't find path '" + path + "' in (" + msgType + "," + msgVersion + ")";
		throw ex;
	}
	if (range_type == "string") {
		al_append_str(sql, name);
		al_append_str(sql, ">='");
		al_append_str(sql, DbUtility::convChar(from));
		al_append_str(sql, "' and ");
		al_append_str(sql, name);
		al_append_str(sql, "<='");
		al_append_str(sql, DbUtility::convChar(to));
		al_append_str(sql, "'");
	} else {
	}
	if (range_type == "integer") {
		al_append_str(sql, "lpad(");
		al_append_str(sql, name);
		al_append_str(sql, ", 20, '0')>=lpad('");
		al_append_str(sql, DbUtility::convChar(from));
		al_append_str(sql, "', 20, '0') and lpad(");
		al_append_str(sql, name);
		al_append_str(sql, ", 20, '0')<=lpad('");
		al_append_str(sql, DbUtility::convChar(to));
		al_append_str(sql, "', 20, '0')");
	} else {
	}
	itr = al_dst_itr(cond);
	loop {
		if (value = al_next(itr)) {
		} else {
			break;
		}
		path = al_arc_a(itr);
		if (name = al_dst_node(xpath_list, path)) {
		} else {
			var AlException ex;
			ex = new AlException;
			ex.msg = "db accessor: can't find path '" + path + "' in (" + msgType + "," + msgVersion + ")";
			throw ex;
		}
		al_append_str(sql, " and ");
		al_append_str(sql, name);
		if (isLike(value)) {
			al_append_str(sql, " like '");
			al_append_str(sql, DbUtility::convChar(value));
			al_append_str(sql, "'");
		} else {
			al_append_str(sql, "='");
			al_append_str(sql, DbUtility::convChar(value));
			al_append_str(sql, "'");
		}
	}
	if (name = al_dst_node(xpath_list, orderby_path)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "db accessor: can't find path '" + path + "' in (" + msgType + "," + msgVersion + ")";
		throw ex;
	}
	if (orderby_type == "string") {
		al_append_str(sql, " order by ");
		al_append_str(sql, name);
		if (desc) {
			al_append_str(sql, " desc");
		} else {
		}
		itr = al_dst_itr(pkey_names);
		loop {
			if (name = al_next(itr)) {
			} else {
				break;
			}
			al_append_str(sql, ", lpad(");
			al_append_str(sql, name);
			al_append_str(sql, ", 20, '0')");
			if (desc) {
				al_append_str(sql, " desc");
			} else {
			}
		}
	} else {
	}
	if (orderby_type == "integer") {
		al_append_str(sql, " order by lpad(");
		al_append_str(sql, name);
		al_append_str(sql, ", 20, '0')");
		if (desc) {
			al_append_str(sql, " desc");
		} else {
		}
		itr = al_dst_itr(pkey_names);
		loop {
			if (name = al_next(itr)) {
			} else {
				break;
			}
			al_append_str(sql, ", lpad(");
			al_append_str(sql, name);
			al_append_str(sql, ", 20, '0')");
			if (desc) {
				al_append_str(sql, " desc");
			} else {
			}
		}
	} else {
	}
	if (count_max) {
		conn.setMaxResultSet(count_max);
	} else {
	}
	rs = conn.executeQuery(num_cols, sql);
	conn.clearMaxResultSet();
	itr = al_dst_itr(rs);
	ret = al_cons(null, null);
	loop {
		if (rec = al_next(itr)) {
		} else {
			break;
		}
		var XmlDbTableObject obj;
		obj = new XmlDbTableObject;
		obj.msgType = msgType;
		obj.msgVersion = msgVersion;
		obj.conn = conn;
		obj.db_type = db_type;
		obj.acc = this;
		obj.pkey_values = pkey_values = al_cons(null, null);
		itr2 = al_dst_itr(pkey_names);
		num_cols = 0;
		dataId = "";
		loop {
			if (name = al_next(itr2)) {
			} else {
				break;
			}
			if (value = al_dst_node(rec, num_cols = num_cols + 1)) {
			} else {
				value = "";
			}
			if (dataId == "") {
				dataId = value;
			} else {
				dataId = dataId + ": " + value;
			}
			al_create_arc(pkey_values, value, name);
		}
		obj.xpath_list = xpath_list;
		obj.rev_xpath_list = rev_xpath_list;
		obj.table_name = table_name;
		obj.dtd_itr = dtd_itr;
		obj.dataId = dataId;
		al_create_arc(ret, obj, null);
	}
	return ret;
}
end_body
member
public: void createFieldList2();
body
{
	if (xpath_list) {
		return;
	} else {
	}
	if (_dtd) {
	} else {
		if (_dtd_base) {
		} else {
			_dtd_base = dtd_base;
		}
		if (_dtd_filename) {
			_dtd = loadDTD(_dtd_base + "/" + _dtd_filename);
		} else {
		}
	}
	if (_dtd) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "xml: dtd is null.";
		throw ex;
	}
	dtd_itr = new DtdItr;
	dtd_itr.Reset(_dtd);
	var list ls;
	ls = dtd_itr.getFieldList2();
	xpath_list = ls.head;
	table_name = ls.tail.head;
	pkey_names = ls.tail.tail.head;
	rev_xpath_list = ls.tail.tail.tail.tail.head;
}
end_body
member
public: string table_name;
member
public: string pkey_names;
member
public: list rev_xpath_list;
end_class
end_class
class XmlDbObject
member
public: static integer MAX_VALUE_SIZE;
member
public: string msgType;
member
public: string msgVersion;
member
public: DbConnection conn;
member
public: string db_type;
member
public: XmlDbAccessor acc;
member
public: string dataId;
member
public: string msgId;
member
public: string parentId;
member
public: string tagId;
member
public: integer field_seq;
member
public: integer child_seq;
member
public: void putField(string path, string value);
body
{
	if (xpath_list) {
		if (al_dst_node(xpath_list, path)) {
		} else {
			var AlException ex;
			ex = new AlException;
			ex.msg = "db object: path not found: msgId=" + msgId + ", path = " + path;
			throw ex;
		}
	} else {
	}
	if (value == null || value == "") {
		removeField(path);
		return;
	} else {
	}
	fetch();
	if (al_strlen(value) > MAX_VALUE_SIZE) {
		value = al_substr(value, 0, MAX_VALUE_SIZE);
	} else {
	}
	var string dataId2, tagId2, sql;
	tagId2 = acc.XPath2TagId(path);
	sql = al_copy("");
	if (al_dst_node(values, path)) {
		al_append_str(sql, "update MsgData set value='");
		al_append_str(sql, DbUtility::convChar(value));
		al_append_str(sql, "' where msgId='");
		al_append_str(sql, msgId);
		al_append_str(sql, "' and parentId='");
		al_append_str(sql, dataId);
		al_append_str(sql, "' and tagId='");
		al_append_str(sql, tagId2);
		al_append_str(sql, "'");
		conn.executeUpdate(sql);
	} else {
		dataId2 = dataId + "f" + XmlDbAccessor::digit5(field_seq = field_seq + 1);
		al_append_str(sql, "insert into MsgData (dataId,msgId,parentId,tagId,value) values ('");
		al_append_str(sql, dataId2);
		al_append_str(sql, "','");
		al_append_str(sql, msgId);
		al_append_str(sql, "','");
		al_append_str(sql, dataId);
		al_append_str(sql, "','");
		al_append_str(sql, tagId2);
		al_append_str(sql, "','");
		al_append_str(sql, DbUtility::convChar(value));
		al_append_str(sql, "')");
		conn.executeUpdate(sql);
		sql = al_copy("");
		al_append_str(sql, "update ParentRelation set fieldSeq='");
		al_append_str(sql, (string)field_seq);
		al_append_str(sql, "' where dataId='");
		al_append_str(sql, dataId);
		al_append_str(sql, "'");
		conn.executeUpdate(sql);
	}
	al_set_dst_node(values, path, value);
}
end_body
member
public: void removeField(string path);
body
{
	fetch();
	var string tagId2, sql;
	tagId2 = acc.XPath2TagId(path);
	if (al_dst_node(values, path)) {
		sql = al_copy("");
		al_append_str(sql, "delete from MsgData");
		al_append_str(sql, " where msgId='");
		al_append_str(sql, msgId);
		al_append_str(sql, "' and parentId='");
		al_append_str(sql, dataId);
		al_append_str(sql, "' and tagId='");
		al_append_str(sql, tagId2);
		al_append_str(sql, "'");
		conn.executeUpdate(sql);
	} else {
	}
	al_set_dst_node(values, path, null);
}
end_body
member
public: XmlDbObject createChild(string path);
body
{
	var DtdItr child_dtd_itr;
	var list child_xpath_list;
	if (dtd_itr) {
		if (child_dtd_itr = dtd_itr.getChild(path)) {
			child_xpath_list = child_dtd_itr.getFieldList();
		} else {
			var AlException ex;
			ex = new AlException;
			ex.msg = "db object: path not found: msgId=" + msgId + ", path = " + path;
			throw ex;
		}
	} else {
	}
	var string tagId2;
	tagId2 = acc.XPath2TagId(path);
	var XmlDbObject obj;
	obj = new XmlDbObject;
	obj.msgType = msgType;
	obj.msgVersion = msgVersion;
	obj.conn = conn;
	obj.db_type = db_type;
	obj.acc = acc;
	obj.dataId = dataId + "c" + XmlDbAccessor::digit5(child_seq = child_seq + 1);
	obj.msgId = msgId;
	obj.parentId = dataId;
	obj.tagId = tagId2;
	obj.field_seq = obj.child_seq = 0;
	obj.values = al_cons(null, null);
	obj.fetched = 1;
	if (child_dtd_itr) {
		obj.dtd_itr = child_dtd_itr.Copy();
		obj.xpath_list = child_xpath_list;
	} else {
	}
	var string sql;
	sql = al_copy("");
	al_append_str(sql, "insert into ParentRelation (dataId,msgId,parentId,tagId,fieldSeq,childSeq) values('");
	al_append_str(sql, obj.dataId);
	al_append_str(sql, "','");
	al_append_str(sql, obj.msgId);
	al_append_str(sql, "','");
	al_append_str(sql, obj.parentId);
	al_append_str(sql, "','");
	al_append_str(sql, obj.tagId);
	al_append_str(sql, "','");
	al_append_str(sql, (string)obj.field_seq);
	al_append_str(sql, "','");
	al_append_str(sql, (string)obj.child_seq);
	al_append_str(sql, "')");
	conn.executeUpdate(sql);
	sql = al_copy("");
	al_append_str(sql, "update ParentRelation set childSeq='");
	al_append_str(sql, (string)child_seq);
	al_append_str(sql, "' where dataId='");
	al_append_str(sql, dataId);
	al_append_str(sql, "'");
	conn.executeUpdate(sql);
	return obj;
}
end_body
member
public: XmlDbObject getMetaInfo(string path);
body
{
	var DtdItr child_dtd_itr;
	var list child_xpath_list;
	if (dtd_itr) {
		if (child_dtd_itr = dtd_itr.getChild(path)) {
			child_xpath_list = child_dtd_itr.getFieldList();
		} else {
			var AlException ex;
			ex = new AlException;
			ex.msg = "db object: path not found: path = " + path;
			throw ex;
		}
	} else {
	}
	var XmlDbObject obj;
	obj = new XmlDbObject;
	obj.msgType = msgType;
	obj.msgVersion = msgVersion;
	obj.conn = conn;
	obj.db_type = db_type;
	obj.acc = acc;
	if (child_dtd_itr) {
		obj.dtd_itr = child_dtd_itr.Copy();
		obj.xpath_list = child_xpath_list;
	} else {
	}
	return obj;
}
end_body
member
public: string getField(string path);
body
{
	if (xpath_list) {
		if (al_dst_node(xpath_list, path)) {
		} else {
			var AlException ex;
			ex = new AlException;
			ex.msg = "db object: path not found: msgId=" + msgId + ", path = " + path;
			throw ex;
		}
	} else {
	}
	fetch();
	var string val;
	val = al_dst_node(values, path);
	if (val == ctrl_a) {
		return "";
	} else {
	}
	return val;
}
end_body
member
public: list getChildren(string path);
body
{
	return getChildren(path, (list)al_cons(null, null));
}
end_body
member
public: list getChildren(string path, string path1, string value1);
body
{
	var list cond;
	cond = al_cons(null, null);
	al_create_arc(cond, value1, path1);
	return getChildren(path, cond);
}
end_body
member
public: list getChildren(string path, string path1, string value1, string path2, string value2);
body
{
	var list cond;
	cond = al_cons(null, null);
	al_create_arc(cond, value1, path1);
	al_create_arc(cond, value2, path2);
	return getChildren(path, cond);
}
end_body
member
public: list getChildren(string path, list cond);
body
{
	var DtdItr child_dtd_itr;
	var list child_xpath_list;
	if (dtd_itr) {
		if (child_dtd_itr = dtd_itr.getChild(path)) {
			child_xpath_list = child_dtd_itr.getFieldList();
		} else {
			var AlException ex;
			ex = new AlException;
			ex.msg = "db object: path not found: msgId=" + msgId + ", path = " + path;
			throw ex;
		}
	} else {
	}
	var string sql, path2, value2, tagId2;
	var list children, rs, itr, rec;
	if (tagId2 = al_dst_node(acc.map, path)) {
	} else {
		return al_cons(null, null);
	}
	sql = al_copy("");
	al_append_str(sql, "select dataId, childSeq, fieldSeq from ParentRelation where msgId='");
	al_append_str(sql, msgId);
	al_append_str(sql, "' and parentId='");
	al_append_str(sql, dataId);
	al_append_str(sql, "' and tagId='");
	al_append_str(sql, tagId2);
	al_append_str(sql, "'");
	itr = al_dst_itr(cond);
	loop {
		if (value2 = al_next(itr)) {
		} else {
			break;
		}
		path2 = al_arc_a(itr);
		if (tagId2 = acc.XPath2TagId(path2)) {
		} else {
			var AlException ex;
			ex = new AlException;
			ex.msg = "db object: can't find path '" + path2 + "' in (" + msgType + "," + msgVersion + ")";
			throw ex;
		}
		al_append_str(sql, " and dataId in (select parentId from MsgData where msgId='");
		al_append_str(sql, msgId);
		al_append_str(sql, "' and tagId='");
		al_append_str(sql, tagId2);
		if (isLike(value2)) {
			al_append_str(sql, "' and value like '");
			al_append_str(sql, DbUtility::convChar(value2));
			al_append_str(sql, "')");
		} else {
			al_append_str(sql, "' and value='");
			al_append_str(sql, DbUtility::convChar(value2));
			al_append_str(sql, "')");
		}
	}
	al_append_str(sql, " order by dataId");
	if (count_max) {
		conn.setMaxResultSet(count_max);
	} else {
	}
	rs = conn.executeQuery(3, sql);
	conn.clearMaxResultSet();
	itr = al_dst_itr(rs);
	children = al_cons(null, null);
	var integer i;
	i = 0;
	loop {
		if (rec = al_next(itr)) {
		} else {
			break;
		}
		var XmlDbObject obj;
		obj = new XmlDbObject;
		obj.msgType = msgType;
		obj.msgVersion = msgVersion;
		obj.conn = conn;
		obj.db_type = db_type;
		obj.acc = acc;
		obj.dataId = al_dst_node(rec, 1);
		obj.msgId = msgId;
		obj.parentId = dataId;
		obj.tagId = tagId2;
		obj.child_seq = (integer)al_dst_node(rec, 2);
		obj.field_seq = (integer)al_dst_node(rec, 3);
		if (child_dtd_itr) {
			obj.dtd_itr = child_dtd_itr.Copy();
			obj.xpath_list = child_xpath_list;
		} else {
		}
		al_create_arc(children, obj, obj.dataId);
	}
	return children;
}
end_body
member
public: list getChildren(string path, list cond, string range_path, string range_type, string from, string to, string orderby_path, string orderby_type, list desc);
body
{
	var DtdItr child_dtd_itr;
	var list child_xpath_list;
	if (dtd_itr) {
		if (child_dtd_itr = dtd_itr.getChild(path)) {
			child_xpath_list = child_dtd_itr.getFieldList();
		} else {
			var AlException ex;
			ex = new AlException;
			ex.msg = "db object: path not found: msgId=" + msgId + ", path = " + path;
			throw ex;
		}
	} else {
	}
	var string range_tagId, orderby_tagId;
	if (range_tagId = acc.XPath2TagId(range_path)) {
	} else {
		return al_cons(null, null);
	}
	if (orderby_path == null || orderby_tagId = acc.XPath2TagId(orderby_path)) {
	} else {
		return al_cons(null, null);
	}
	var string sql, path2, value2, tagId2;
	var list children, rs, itr, rec;
	if (tagId2 = al_dst_node(acc.map, path)) {
	} else {
		return al_cons(null, null);
	}
	sql = al_copy("");
	if (orderby_tagId) {
		al_append_str(sql, "select p.dataId, p.childSeq, p.fieldSeq from ParentRelation p, MsgData r1, MsgData r2");
	} else {
		al_append_str(sql, "select p.dataId, p.childSeq, p.fieldSeq from ParentRelation p, MsgData r1");
	}
	al_append_str(sql, " where p.msgId='");
	al_append_str(sql, msgId);
	al_append_str(sql, "' and p.parentId='");
	al_append_str(sql, dataId);
	al_append_str(sql, "' and p.tagId='");
	al_append_str(sql, tagId2);
	al_append_str(sql, "' and p.dataId=r1.parentId and r1.tagId='");
	al_append_str(sql, range_tagId);
	al_append_str(sql, "'");
	if (range_type == "string") {
		al_append_str(sql, " and r1.value>='");
		al_append_str(sql, DbUtility::convChar(from));
		al_append_str(sql, "' and r1.value<='");
		al_append_str(sql, DbUtility::convChar(to));
		al_append_str(sql, "'");
	} else {
	}
	if (range_type == "integer") {
		al_append_str(sql, " and lpad(r1.value, 20, '0')>=lpad('");
		al_append_str(sql, DbUtility::convChar(from));
		al_append_str(sql, "', 20, '0') and lpad(r1.value, 20, '0')<=lpad('");
		al_append_str(sql, DbUtility::convChar(to));
		al_append_str(sql, "', 20, '0')");
	} else {
	}
	if (orderby_tagId) {
		al_append_str(sql, " and p.dataId=r2.parentId and r2.tagId='");
		al_append_str(sql, orderby_tagId);
		al_append_str(sql, "'");
	} else {
	}
	itr = al_dst_itr(cond);
	loop {
		if (value2 = al_next(itr)) {
		} else {
			break;
		}
		path2 = al_arc_a(itr);
		if (tagId2 = acc.XPath2TagId(path2)) {
		} else {
			return al_cons(null, null);
		}
		al_append_str(sql, " and p.dataId in (select parentId from MsgData where msgId='");
		al_append_str(sql, msgId);
		al_append_str(sql, "' and tagId='");
		al_append_str(sql, tagId2);
		if (isLike(value2)) {
			al_append_str(sql, "' and value like '");
			al_append_str(sql, DbUtility::convChar(value2));
			al_append_str(sql, "')");
		} else {
			al_append_str(sql, "' and value='");
			al_append_str(sql, DbUtility::convChar(value2));
			al_append_str(sql, "')");
		}
	}
	if (orderby_tagId) {
		if (orderby_type == "string") {
			if (desc == null) {
				al_append_str(sql, " order by r2.value");
			} else {
				al_append_str(sql, " order by r2.value desc");
			}
		} else {
		}
		if (orderby_type == "integer") {
			if (desc == null) {
				al_append_str(sql, " order by lpad(r2.value, 20, '0')");
			} else {
				al_append_str(sql, " order by lpad(r2.value, 20, '0') desc");
			}
		} else {
		}
	} else {
		if (desc == null) {
			al_append_str(sql, " order by p.dataId");
		} else {
			al_append_str(sql, " order by p.dataId desc");
		}
	}
	if (count_max) {
		conn.setMaxResultSet(count_max);
	} else {
	}
	rs = conn.executeQuery(3, sql);
	conn.clearMaxResultSet();
	itr = al_dst_itr(rs);
	children = al_cons(null, null);
	var integer i;
	i = 0;
	loop {
		if (rec = al_next(itr)) {
		} else {
			break;
		}
		var XmlDbObject obj;
		obj = new XmlDbObject;
		obj.msgType = msgType;
		obj.msgVersion = msgVersion;
		obj.conn = conn;
		obj.db_type = db_type;
		obj.acc = acc;
		obj.dataId = al_dst_node(rec, 1);
		obj.msgId = msgId;
		obj.parentId = dataId;
		obj.tagId = tagId2;
		obj.child_seq = (integer)al_dst_node(rec, 2);
		obj.field_seq = (integer)al_dst_node(rec, 3);
		if (child_dtd_itr) {
			obj.dtd_itr = child_dtd_itr.Copy();
			obj.xpath_list = child_xpath_list;
		} else {
		}
		al_create_arc(children, obj, obj.dataId);
	}
	return children;
}
end_body
member
public: void fetch();
body
{
	if (fetched) {
		return;
	} else {
	}
	var string sql, path2, tagId2, value2;
	var list rs, itr, rec;
	sql = al_copy("");
	al_append_str(sql, "select tagId, value from MsgData ");
	al_append_str(sql, "where msgId ='");
	al_append_str(sql, msgId);
	al_append_str(sql, "' and parentId='");
	al_append_str(sql, dataId);
	al_append_str(sql, "' order by dataId");
	rs = conn.executeQuery(2, sql);
	itr = al_dst_itr(rs);
	values = al_cons(null, null);
	loop {
		if (rec = al_next(itr)) {
		} else {
			break;
		}
		tagId2 = al_dst_node(rec, 1);
		value2 = al_dst_node(rec, 2);
		if (tagId2 && value2) {
		} else {
			break;
		}
		if (path2 = al_dst_node(acc.map2, tagId2)) {
		} else {
			var AlException ex;
			ex.msg = "db object: path of tagId not found: msgId=" + msgId + ", tagId = " + tagId2;
			ex = new AlException;
			throw ex;
		}
		al_create_arc(values, value2, path2);
	}
	fetched = 1;
}
end_body
member
public: list values;
member
public: void delete();
body
{
	var string sql, path;
	var list child_list, itr, ls, itr2;
	var XmlDbObject obj;
	child_list = dtd_itr.getChildList();
	itr = al_dst_itr(child_list);
	loop {
		if (path = al_next(itr)) {
		} else {
			break;
		}
		ls = getChildren(path);
		itr2 = al_dst_itr(ls);
		loop {
			if (obj = al_next(itr2)) {
			} else {
				break;
			}
			obj.delete();
		}
	}
	sql = al_copy("");
	al_append_str(sql, "delete from MsgData where parentId='");
	al_append_str(sql, dataId);
	al_append_str(sql, "'");
	conn.executeUpdate(sql);
	sql = al_copy("");
	al_append_str(sql, "delete from ParentRelation where dataId='");
	al_append_str(sql, dataId);
	al_append_str(sql, "'");
	conn.executeUpdate(sql);
}
end_body
member
public: list fetched;
member
public: DtdItr dtd_itr;
member
public: list xpath_list;
member
public: integer count_max;
class XmlDbTableObject
member
public: void putField(string path, string value);
body
{
	var AlException ex;
	ex = new AlException;
	ex.msg = "XmlDbTableObject::putField not implemented.";
	throw ex;
}
end_body
member
public: void removeField(string path);
body
{
	var AlException ex;
	ex = new AlException;
	ex.msg = "XmlDbTableObject::removeField not implemented.";
	throw ex;
}
end_body
member
public: XmlDbObject createChild(string path);
body
{
	var AlException ex;
	ex = new AlException;
	ex.msg = "XmlDbTableObject::createChild not implemented.";
	throw ex;
}
end_body
member
public: void delete();
body
{
	var AlException ex;
	ex = new AlException;
	ex.msg = "XmlDbTableObject::delete not implemented.";
	throw ex;
}
end_body
member
public: string getField(string path);
body
{
	if (xpath_list) {
		if (al_dst_node(xpath_list, path)) {
		} else {
			var AlException ex;
			ex = new AlException;
			ex.msg = "db table object: path not found: path = " + path;
			throw ex;
		}
	} else {
	}
	fetch();
	var string val;
	val = al_dst_node(values, path);
	if (val == ctrl_a) {
		return "";
	} else {
	}
	return val;
}
end_body
member
public: list getChildren(string path, list cond);
body
{
	var DtdItr child_dtd_itr;
	var list ls, ls, child_xpath_list, child_rev_xpath_list;
	var list child_pkey_names, child_fkey_names;
	var string child_table_name, pkey_path, fkey_name, value;
	var string orderby, orderby_type;
	if (dtd_itr) {
		if (ls = dtd_itr.getChild2(path)) {
			child_dtd_itr = ls.head;
			child_table_name = ls.tail.head;
			ls = child_dtd_itr.getFieldList2();
			child_xpath_list = ls.head;
			child_pkey_names = ls.tail.tail.head;
			child_fkey_names = ls.tail.tail.tail.head;
			child_rev_xpath_list = ls.tail.tail.tail.tail.head;
		} else {
			var AlException ex;
			ex = new AlException;
			ex.msg = "db table object: path not found:  path = " + path;
			throw ex;
		}
	} else {
	}
	var string sql, name, path2, value2, dataId;
	var list first, itr, rs, rec, ret;
	var list itr2, pkey_values;
	var integer num_cols;
	sql = al_copy("");
	al_append_str(sql, "select ");
	itr = al_dst_itr(child_pkey_names);
	first = 1;
	num_cols = 0;
	loop {
		if (name = al_next(itr)) {
		} else {
			break;
		}
		if (orderby || al_dst_node(child_fkey_names, name)) {
		} else {
			orderby = name;
			orderby_type = "string";
			var integer len;
			var string id_str;
			len = al_strlen(orderby);
			if (len >= 2) {
				id_str = al_substr(orderby, len - 2, len);
				id_str = al_str_misc("to_lower", id_str, null);
				if (id_str == "id") {
					orderby_type = "integer";
				} else {
				}
			} else {
			}
		}
		if (first) {
			first = null;
		} else {
			al_append_str(sql, ",");
		}
		al_append_str(sql, name);
		num_cols = num_cols + 1;
	}
	al_append_str(sql, " from ");
	al_append_str(sql, child_table_name);
	itr = al_dst_itr(child_fkey_names);
	first = 1;
	loop {
		if (pkey_path = al_next(itr)) {
		} else {
			break;
		}
		fkey_name = al_arc_a(itr);
		pkey_path = al_dst_node(rev_xpath_list, pkey_path);
		value = getField(pkey_path);
		if (first) {
			first = null;
			al_append_str(sql, " where ");
		} else {
			al_append_str(sql, " and ");
		}
		al_append_str(sql, fkey_name);
		al_append_str(sql, "='");
		al_append_str(sql, DbUtility::convChar(value));
		al_append_str(sql, "'");
	}
	itr = al_dst_itr(cond);
	loop {
		if (value2 = al_next(itr)) {
		} else {
			break;
		}
		path2 = al_arc_a(itr);
		if (name = al_dst_node(xpath_list, path)) {
		} else {
			var AlException ex;
			ex = new AlException;
			ex.msg = "db accessor: can't find path '" + path2 + "' in (" + msgType + "," + msgVersion + ")";
			throw ex;
		}
		al_append_str(sql, " and ");
		al_append_str(sql, name);
		if (isLike(value2)) {
			al_append_str(sql, " like '");
			al_append_str(sql, DbUtility::convChar(value2));
			al_append_str(sql, "'");
		} else {
			al_append_str(sql, "='");
			al_append_str(sql, DbUtility::convChar(value2));
			al_append_str(sql, "'");
		}
	}
	if (orderby && orderby_type == "string") {
		al_append_str(sql, " order by ");
		al_append_str(sql, orderby);
	} else {
	}
	if (orderby && orderby_type == "integer") {
		al_append_str(sql, " order by lpad(");
		al_append_str(sql, orderby);
		al_append_str(sql, ", 20, '0')");
	} else {
	}
	var string pkey_names;
	if (count_max) {
		conn.setMaxResultSet(count_max);
	} else {
	}
	rs = conn.executeQuery(num_cols, sql);
	conn.clearMaxResultSet();
	itr = al_dst_itr(rs);
	ret = al_cons(null, null);
	loop {
		if (rec = al_next(itr)) {
		} else {
			break;
		}
		var XmlDbTableObject obj;
		obj = new XmlDbTableObject;
		obj.msgType = msgType;
		obj.msgVersion = msgVersion;
		obj.conn = conn;
		obj.db_type = db_type;
		obj.acc = this;
		obj.pkey_values = pkey_values = al_cons(null, null);
		itr2 = al_dst_itr(child_pkey_names);
		num_cols = 0;
		dataId = "";
		loop {
			if (name = al_next(itr2)) {
			} else {
				break;
			}
			if (value2 = al_dst_node(rec, num_cols = num_cols + 1)) {
			} else {
				value2 = "";
			}
			if (dataId == "") {
				dataId = value2;
			} else {
				dataId = dataId + ": " + value2;
			}
			al_create_arc(pkey_values, value2, name);
		}
		if (child_dtd_itr) {
			obj.dtd_itr = child_dtd_itr.Copy();
			obj.xpath_list = child_xpath_list;
			obj.rev_xpath_list = child_rev_xpath_list;
			obj.table_name = child_table_name;
		} else {
		}
		obj.dataId = dataId;
		al_create_arc(ret, obj, null);
	}
	return ret;
}
end_body
member
public: list getChildren(string path, list cond, string range_path, string range_type, string from, string to, string orderby_path, string orderby_type, list desc);
body
{
	var AlException ex;
	ex = new AlException;
	ex.msg = "XmlDbTableObject::get(list cond, string range_path, string range_type, string from, string to, string orderby_path, string orderby_type, list desc) not implemented.";
	throw ex;
}
end_body
member
public: void fetch();
body
{
	if (fetched) {
		return;
	} else {
	}
	var string sql, name, value, path;
	var list first, itr, rs, rec, itr2;
	var integer num_cols, i;
	sql = al_copy("");
	itr = al_dst_itr(xpath_list);
	num_cols = 0;
	first = 1;
	loop {
		if (name = al_next(itr)) {
		} else {
			break;
		}
		if (first) {
			first = null;
			al_append_str(sql, "select ");
		} else {
			al_append_str(sql, ", ");
		}
		al_append_str(sql, name);
		num_cols = num_cols + 1;
	}
	al_append_str(sql, " from ");
	al_append_str(sql, table_name);
	itr = al_dst_itr(pkey_values);
	first = 1;
	loop {
		if (value = al_next(itr)) {
		} else {
			break;
		}
		name = al_arc_a(itr);
		if (first) {
			first = null;
			al_append_str(sql, " where ");
		} else {
			al_append_str(sql, " and ");
		}
		al_append_str(sql, name);
		al_append_str(sql, "='");
		al_append_str(sql, DbUtility::convChar(value));
		al_append_str(sql, "'");
		name = al_arc_a(itr);
	}
	rs = conn.executeQuery(num_cols, sql);
	itr = al_dst_itr(rs);
	values = al_cons(null, null);
	loop {
		if (rec = al_next(itr)) {
		} else {
			break;
		}
		itr2 = al_dst_itr(xpath_list);
		i = 0;
		loop {
			if (name = al_next(itr2)) {
			} else {
				break;
			}
			value = al_dst_node(rec, i = i + 1);
			path = al_dst_node(rev_xpath_list, name);
			al_create_arc(values, value, path);
		}
	}
	fetched = 1;
}
end_body
member
public: list table_name;
member
public: list pkey_values;
member
public: list rev_xpath_list;
end_class
end_class
class Csv1Data
member
public: void loadCSV(string filename);
body
{
	var file in;
	if (in = al_file_open(filename, "r")) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "can't open csv file '" + (string)filename + "'";
		throw ex;
	}
	root_csv_data = al_cons(null, null);
	var list data, data2, parents, parent, children, child, child_csv_data;
	parents = al_cons(null, null);
	children = al_cons(null, null);
	loop {
		if (data = al_file_read(in, "csv")) {
		} else {
			var AlException ex;
			ex = new AlException;
			ex.msg = "fail to read csv file '" + (string)filename + "'";
			throw ex;
		}
		if (data == 1) {
			break;
		} else {
		}
		parent = al_dst_node(data, 2);
		if (parent != "") {
			al_create_arc(parents, data, parent);
		} else {
		}
		child = al_dst_node(data, 3);
		if (child != "") {
			al_create_arc(children, data, child);
		} else {
			al_create_arc(root_csv_data, data, null);
		}
	}
	var list itr, itr2;
	itr = al_dst_itr(parents);
	loop {
		if (data = al_next(itr)) {
		} else {
			break;
		}
		parent = al_arc_a(itr);
		al_create_arc(data, child_csv_data = al_cons(null, null), "$child");
		itr2 = al_dst_itr(children);
		loop {
			if (data2 = al_next_a(itr2, parent)) {
			} else {
				break;
			}
			al_create_arc(child_csv_data, data2, null);
			al_remove(itr2);
		}
	}
}
end_body
member
public: list root_csv_data;
class Csv1DataItr
member
public: void Reset(list csv_data);
body
{
	base_csv_data = csv_data;
	Reset();
}
end_body
member
public: void Reset();
body
{
	if (base_csv_data) {
	} else {
		base_csv_data = root_csv_data;
	}
	if (base_csv_data) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "no csv data.";
		throw ex;
	}
	csv_data_itr = al_dst_itr(base_csv_data);
}
end_body
member
public: list base_csv_data;
member
public: list csv_data_itr;
member
public: list nextRow();
body
{
	var list data;
	loop {
		if (data = al_next(csv_data_itr)) {
		} else {
			return null;
		}
		if (al_dst_node(data, "$child")) {
			continue;
		} else {
		}
		if (al_dst_node(data, 1) != "") {
			continue;
		} else {
		}
		break;
	}
	parent_id = al_dst_node(data, 2);
	child_id = al_dst_node(data, 3);
	dst_path = al_dst_node(data, 4);
	src_path = al_dst_node(data, 5);
	value = al_dst_node(data, 6);
	return 1;
}
end_body
member
public: string parent_id;
member
public: string child_id;
member
public: string dst_path;
member
public: string src_path;
member
public: string value;
member
public: Csv1Data nextChild();
body
{
	var list data, itr, child_csv_data, child;
	loop {
		if (data = al_next(csv_data_itr)) {
		} else {
			return null;
		}
		if (child_csv_data = al_dst_node(data, "$child")) {
		} else {
			continue;
		}
		var Csv1DataItr csv_itr;
		csv_itr = new Csv1DataItr;
		csv_itr.Reset(child_csv_data);
		csv_itr.base_parent_name = al_dst_node(data, 1);
		csv_itr.base_parent_id = al_dst_node(data, 2);
		csv_itr.base_child_id = al_dst_node(data, 3);
		csv_itr.base_dst_path = al_dst_node(data, 4);
		csv_itr.base_src_path = al_dst_node(data, 5);
		csv_itr.base_value = al_dst_node(data, 6);
		return csv_itr;
	}
}
end_body
member
public: Csv1Data nextChild(string name);
body
{
	var list data, itr, child_csv_data, child;
	loop {
		if (data = al_next(csv_data_itr)) {
		} else {
			return null;
		}
		itr = al_dst_itr(data);
		loop {
			if (child_csv_data = al_next(itr)) {
			} else {
				break;
			}
			child = al_arc_a(itr);
			if (child != "$child") {
				continue;
			} else {
			}
			if (al_dst_node(data, 1) != name) {
				continue;
			} else {
			}
			var Csv1DataItr csv_itr;
			csv_itr = new Csv1DataItr;
			csv_itr.Reset(child_csv_data);
			csv_itr.base_parent_name = al_dst_node(data, 1);
			csv_itr.base_parent_id = al_dst_node(data, 2);
			csv_itr.base_child_id = al_dst_node(data, 3);
			csv_itr.base_dst_path = al_dst_node(data, 4);
			csv_itr.base_src_path = al_dst_node(data, 5);
			csv_itr.base_value = al_dst_node(data, 6);
			return csv_itr;
		}
	}
}
end_body
member
public: string base_parent_name;
member
public: string base_parent_id;
member
public: string base_child_id;
member
public: string base_dst_path;
member
public: string base_src_path;
member
public: string base_value;
end_class
end_class
end_class
class DbUtility
member
public: string convChar(string str);
body
{
	if (str) {
	} else {
		return "";
	}
	str = al_str_misc("to_single_quote_string", str, null);
	if (al_strlen(str) > XmlDbObject::MAX_VALUE_SIZE) {
		str = al_substr(str, 0, XmlDbObject::MAX_VALUE_SIZE);
	} else {
	}
	return str;
}
end_body
class DbConnection
member
public: void prepare(string sql);
body
{
	if (pool) {
		pool.sql_trace_log("prepare: sql = " + sql);
	} else {
	}
	var list err;
	statement = al_sql("statement", connection, null, null, null);
	if (al_is_type(statement, "string")) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "sql: create statement error: " + statement;
		throw ex;
	} else {
	}
	if (err = al_sql("prepare", statement, sql, null, null)) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "sql: prepare error: sql = " + sql + ": " + err;
		throw ex;
	} else {
	}
}
end_body
member
public: list executeQuery(integer num_cols, list values);
body
{
	if (pool) {
		pool.sql_trace_log("executeQuery:");
	} else {
	}
	var list err, result_set;
	var integer i;
	if (err = al_sql("execute", statement, null, values, null)) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "sql: execute error: " + err;
		throw ex;
	} else {
	}
	types = al_cons(null, null);
	i = 0;
	loop {
		if (i < num_cols) {
		} else {
			break;
		}
		al_create_arc(types, "string", null);
		i = i + 1;
	}
	result_set = al_sql("result", statement, types, max_result_set, null);
	if (al_is_type(result_set, "string")) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "sql: result error: " + result_set;
		throw ex;
	} else {
	}
	return result_set;
}
end_body
member
public: void executeUpdate(list values);
body
{
	in_transaction = 1;
	if (pool) {
		pool.sql_trace_log("executeUpdate:");
	} else {
	}
	var list err;
	var integer i;
	if (err = al_sql("execute", statement, null, values, null)) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "sql: execute error: " + err;
		throw ex;
	} else {
	}
}
end_body
member
public: list executeQuery(integer num_cols, string sql);
body
{
	if (pool) {
		pool.sql_trace_log("executeQuery: sql = " + sql);
	} else {
	}
	var list err, result_set;
	var integer i;
	statement = al_sql("statement", connection, null, null, null);
	if (al_is_type(statement, "string")) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "sql: create statement error: " + statement;
		throw ex;
	} else {
	}
	if (err = al_sql("execute", statement, sql, null, null)) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "sql: execute error: " + err;
		throw ex;
	} else {
	}
	types = al_cons(null, null);
	i = 0;
	loop {
		if (i < num_cols) {
		} else {
			break;
		}
		al_create_arc(types, "string", null);
		i = i + 1;
	}
	result_set = al_sql("result", statement, types, max_result_set, null);
	if (al_is_type(result_set, "string")) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "sql: result error: " + result_set;
		throw ex;
	} else {
	}
	return result_set;
}
end_body
member
public: void executeUpdate(string sql);
body
{
	in_transaction = 1;
	if (pool) {
		pool.sql_trace_log("executeUpdate: sql = " + sql);
	} else {
	}
	var list err;
	statement = al_sql("statement", connection, null, null, null);
	if (al_is_type(statement, "string")) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "sql: create statement error: " + statement;
		throw ex;
	} else {
	}
	if (err = al_sql("execute", statement, sql, null, null)) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "sql: execute error: " + err;
		throw ex;
	} else {
	}
}
end_body
member
public: list nextResultSet();
body
{
	var list result_set;
	result_set = al_sql("result", statement, types, max_result_set, null);
	if (al_is_type(result_set, "string")) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "sql: result error: " + result_set;
		throw ex;
	} else {
	}
	if (al_dst_node(result_set, null)) {
	} else {
		result_set = null;
	}
	return result_set;
}
end_body
member
public: void setMaxResultSet(integer count);
body
{
	max_result_set = count;
}
end_body
member
public: void clearMaxResultSet();
body
{
	if (max_result_set) {
		max_result_set = null;
	} else {
	}
}
end_body
member
public: string getNextSeq(string sequenceName);
body
{
	var list value;
	value = al_misc("get_time", null, null);
	value = al_misc("get_localtime", value, null);
	value = al_misc("format_time", value, "yyyyMMddHHmmss");
	value = value + "-" + (string)al_misc("random", null, null);
	return value;
	// var string sql;
	// var list rs, rec, ok;
	// if (db_type == "oracle") {
	// sql = "select " + sequenceName + ".nextval from dual";
	// ok = 1;
	// } else {
	// }
	// if (db_type == "postgresql") {
	// sql = "select nextval(\'" + sequenceName + "\')";
	// ok = 1;
	// } else {
	// }
	// if (db_type == "mysql") {
	// sql = "update " + sequenceName + " set id=LAST_INSERT_ID(id+1)";
	// executeUpdate(sql);
	// sql = "select id from " + sequenceName;
	// ok = 1;
	// } else {
	// }
	// if (ok) {
	// rs = executeQuery(1, sql);
	// rec = al_dst_node(rs, null);
	// return al_dst_node(rec, 1);
	// } else {
	// }
	// var AlException ex;
	// ex = new AlException;
	// ex.msg = "sql: unsuported db type: " + (string)db_type;
	// throw ex;
}
end_body
member
public: void commit();
body
{
	if (in_transaction) {
	} else {
		return;
	}
	in_transaction = null;
	var list err;
	if (err = al_sql("commit", connection, null, null, null)) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "sql: commit error: " + (string)err;
		throw ex;
	} else {
	}
}
end_body
member
public: void rollback();
body
{
	if (in_transaction) {
	} else {
		return;
	}
	var list err;
	if (err = al_sql("rollback", connection, null, null, null)) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "sql: rollback error: " + (string)err;
		throw ex;
	} else {
	}
	in_transaction = null;
}
end_body
member
public: void close();
body
{
	statement = null;
	connection = null;
}
end_body
member
public: list connection;
member
public: list statement;
member
public: list types;
member
public: integer max_result_set;
member
public: string db_type;
member
public: DbConnectionPool pool;
member
public: list in_transaction;
class DbPoolConnection
member
public: void close();
body
{
	try {
		if (in_transaction) {
			rollback();
		} else {
		}
	} catch (AlException e) {
	}
	if (pool) {
		pool.sql_trace_log("close");
		statement = null;
		al_misc("para_lock", 1, null);
		al_remove_from(pool.used_connections, this, null);
		al_create_arc(pool.free_connections, this, null);
		al_misc("para_lock", null, null);
		pool = null;
	} else {
	}
	max_result_set = null;
}
end_body
end_class
end_class
class DbConnectionPool
member
public: AltairServer ap_server;
member
public: void start();
body
{
	var DbPoolConnection conn;
	var list ls, itr;
	ls = al_cons(null, null);
	free_connections = al_cons(null, null);
	used_connections = al_cons(null, null);
	num_connections = 0;
	loop {
		if (num_connections < initial_connections) {
		} else {
			break;
		}
		conn = getConnection();
		al_create_arc(ls, conn, null);
		num_connections = num_connections + 1;
	}
	itr = al_dst_itr(ls);
	loop {
		if (conn = al_next(itr)) {
		} else {
			break;
		}
		conn.close();
	}
}
end_body
member
public: void stop();
body
{
	max_connections = 0;
	var DbPoolConnection conn;
	var list itr;
	loop {
		if (conn = al_dst_node(used_connections, null)) {
		} else {
			break;
		}
		conn.close();
	}
	itr = al_dst_itr(free_connections);
	loop {
		if (conn = al_next(itr)) {
		} else {
			break;
		}
		conn.statement = null;
		conn.connection = null;
		al_remove(itr);
	}
	used_connections = null;
	free_connections = null;
}
end_body
member
public: string pool_name;
member
public: DbConnection getConnection();
body
{
	if (max_connections == 0) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "sql: no more connection: shutdown now";
		throw ex;
	} else {
	}
	al_misc("para_lock", 1, null);
	var list itr, connection;
	var DbPoolConnection conn;
	itr = al_dst_itr(free_connections);
	if (conn = al_next(itr)) {
		al_remove(itr);
	} else {
		if (num_connections >= max_connections) {
			al_misc("para_lock", null, null);
			var AlException ex;
			ex = new AlException;
			ex.msg = "sql: no more connection: max_connections = " + (string)max_connections;
			throw ex;
		} else {
		}
		conn = DbManager::getConnection(db_type, host, port, db_name, user, pass);
		connection = conn.connection;
		conn = new DbPoolConnection;
		conn.connection = connection;
		num_connections = num_connections + 1;
	}
	al_create_arc(used_connections, conn, null);
	conn.pool = this;
	conn.db_type = db_type;
	sql_trace_log("getConnection");
	al_misc("para_lock", null, null);
	return conn;
}
end_body
member
public: string db_type;
member
public: string host;
member
public: string port;
member
public: string db_name;
member
public: string user;
member
public: string pass;
member
public: list free_connections;
member
public: list used_connections;
member
public: integer initial_connections;
member
public: integer max_connections;
member
public: integer num_connections;
member
public: void sql_trace_log(string str);
body
{
	if (sql_trace_log_filepath) {
		ap_server.log(sql_trace_log_filepath, str);
	} else {
	}
}
end_body
member
public: string sql_trace_log_filepath;
end_class
class DbManager
member
public: static list createPool(DbConnectionPool pool, string pool_name);
body
{
	if (pools) {
	} else {
		pools = al_cons(null, null);
	}
	if (pool_name == null) {
		return "pool_name is null.";
	} else {
	}
	if (al_dst_node(pools, pool_name)) {
		return "pool_name(" + pool_name + ") already used.";
	} else {
	}
	try {
		pool.start();
	} catch (AlException e) {
		pool.stop();
		return e.msg;
	}
	al_create_arc(pools, pool, pool_name);
	return null;
}
end_body
member
public: static void closeAllPools();
body
{
	if (pools) {
	} else {
		return;
	}
	var DbConnectionPool pool;
	var list itr;
	itr = al_dst_itr(pools);
	loop {
		if (pool = al_next(itr)) {
		} else {
			break;
		}
		pool.stop();
		al_remove(itr);
	}
	pool = null;
	al_sql("finalize", null, null, null, null);
}
end_body
member
public: static string getDbType(string pool_name);
body
{
	var DbConnectionPool pool;
	if (pools) {
		if (pool = al_dst_node(pools, pool_name)) {
			return pool.db_type;
		} else {
		}
	} else {
	}
	var AlException ex;
	ex = new AlException;
	ex.msg = "sql: pool not found: pool_name = " + (string)pool_name;
	throw ex;
}
end_body
member
public: static DbConnection getConnection(string pool_name);
body
{
	var DbConnectionPool pool;
	if (pools) {
		if (pool = al_dst_node(pools, pool_name)) {
			return pool.getConnection();
		} else {
		}
	} else {
	}
	var AlException ex;
	ex = new AlException;
	ex.msg = "sql: pool not found: pool_name = " + (string)pool_name;
	throw ex;
}
end_body
member
public: static list pools;
member
public: static DbConnection getConnection(string db_type, string host, string port, string db_name, string user, string pass);
body
{
	var list connection, conn_info;
	conn_info = al_list5(host, port, db_name, user, pass);
	connection = al_sql("connect", conn_info, db_type, null, null);
	if (al_is_type(connection, "string")) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "sql: connect error: " + connection;
		throw ex;
	} else {
	}
	var DbConnection conn;
	conn = new DbConnection;
	conn.connection = connection;
	conn.db_type = db_type;
	return conn;
}
end_body
end_class
end_class
class FileUtility
member
public: static string tempFile();
body
{
	var string platform, dir;
	platform = al_misc("platform", null, null);
	if (platform == "linux" || platform == "mac") {
		dir = "/tmp";
	} else {
	}
	if (platform == "windows") {
		dir = al_misc("get_env", "TEMP", null);
	} else {
	}
	return al_file_manip("tmp_file", dir, "al");
}
end_body
member
public: static list readBinary(string filename);
body
{
	var integer size;
	var file in;
	var list buffer;
	if (al_file_manip("does_exist", filename, null)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "file: '" + (string)filename + "' not found";
		throw ex;
	}
	if (filename && size = al_file_manip("get_size", filename, null)) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "file: can't get file size of '" + (string)filename + "'";
		throw ex;
	}
	if (in = al_file_open(filename, "rb")) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "file: can't open read file '" + (string)filename + "'";
		throw ex;
	}
	buffer = al_misc("binary", size, null);
	if (al_file_read(in, al_list3(buffer, 0, size))) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "file: fail to read '" + (string)filename + "'";
		throw ex;
	} else {
	}
	return buffer;
}
end_body
member
public: static string readString(string filename);
body
{
	var list buffer;
	var integer size;
	var string str;
	buffer = readBinary(filename);
	size = al_misc("binary_size", buffer, null);
	str = al_misc("binary_to_string", al_list3(buffer, 0, size), null);
	return str;
}
end_body
member
public: static void writeBinary(string filename, list bin);
body
{
	var integer size;
	size = al_misc("binary_size", bin, null);
	writeBinary(filename, bin, 0, size);
}
end_body
member
public: static void writeBinary(string filename, list bin, integer from, integer size);
body
{
	var file out;
	if (out = al_file_open(filename, "wb")) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "file: can't open write file '" + (string)filename + "'";
		throw ex;
	}
	if (al_file_write(out, al_list3(bin, from, size), null)) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "file: fail to write '" + (string)filename + "'";
		throw ex;
	} else {
	}
}
end_body
member
public: static void writeBinary(string filename, string str);
body
{
	var integer size;
	var list bin;
	size = al_strlen(str);
	bin = al_misc("binary", size, null);
	al_misc("binary_copy", al_list2(bin, 0), str);
	writeBinary(filename, bin, 0, size);
}
end_body
member
public: static void appendBinary(string filename, list bin);
body
{
	var integer size;
	size = al_misc("binary_size", bin, null);
	appendBinary(filename, bin, 0, size);
}
end_body
member
public: static void appendBinary(string filename, list bin, integer from, integer size);
body
{
	var file out;
	if (out = al_file_open(filename, "ab")) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "file: can't open write file '" + (string)filename + "'";
		throw ex;
	}
	if (al_file_write(out, al_list3(bin, from, size), null)) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "file: fail to write '" + (string)filename + "'";
		throw ex;
	} else {
	}
}
end_body
member
public: static void appendBinary(string filename, string str);
body
{
	var integer size;
	var list bin;
	size = al_strlen(str);
	bin = al_misc("binary", size, null);
	al_misc("binary_copy", al_list2(bin, 0), str);
	appendBinary(filename, bin, 0, size);
}
end_body
member
public: static void writeString(string filename, string str);
body
{
	var file out;
	if (out = al_file_open(filename, "w")) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "file: can't open write file '" + (string)filename + "'";
		throw ex;
	}
	if (al_file_write(out, "string", str)) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "file: fail to write '" + (string)filename + "'";
		throw ex;
	} else {
	}
}
end_body
member
public: static void appendString(string filename, string str);
body
{
	var file out;
	if (out = al_file_open(filename, "a")) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "file: can't open write file '" + (string)filename + "'";
		throw ex;
	}
	if (al_file_write(out, "string", str)) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "file: fail to write '" + (string)filename + "'";
		throw ex;
	} else {
	}
}
end_body
member
public: static list readGraphData(string filename);
body
{
	if (al_file_manip("does_exist", filename, null)) {
	} else {
		return null;
	}
	var list data;
	var file in;
	if (in = al_file_open(filename, "r")) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "file: can't open read file '" + (string)filename + "'";
		throw ex;
	}
	if (data = al_file_read(in, "graph")) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "file: fail to read graph data from '" + (string)filename + "'";
		throw ex;
	}
	return data;
}
end_body
member
public: static void writeGraphData(string filename, list data);
body
{
	var file out;
	if (out = al_file_open(filename, "w")) {
	} else {
		var AlException ex;
		ex = new AlException;
		ex.msg = "file: can't open write file '" + (string)filename + "'";
		throw ex;
	}
	if (al_file_write(out, "graph", data)) {
		var AlException ex;
		ex = new AlException;
		ex.msg = "file: fail to write graph data '" + (string)filename + "'";
		throw ex;
	} else {
	}
}
end_body
member
public: static void remove(string dir);
body
{
	var RevFileItr itr;
	itr = new RevFileItr;
	itr.Reset(dir);
	loop {
		if (itr.Next()) {
		} else {
			break;
		}
		al_file_manip("remove", itr.abs_path, null);
	}
}
end_body
member
public: static void makeReadOnly(string dir);
body
{
	var FileItr itr;
	itr = new FileItr;
	itr.Reset(dir);
	loop {
		if (itr.Next()) {
		} else {
			break;
		}
		al_file_manip("set_readonly", itr.abs_path, null);
	}
}
end_body
member
public: static void makeWritable(string dir);
body
{
	var FileItr itr;
	itr = new FileItr;
	itr.Reset(dir);
	loop {
		if (itr.Next()) {
		} else {
			break;
		}
		al_file_manip("set_readonly", itr.abs_path, 1);
	}
}
end_body
member
public: static void makeWritable();
body
{
	var list dir_name;
	var string dir;
	if (dir_name = al_get_read_filename("All Files (*.*)|*.*||", null)) {
	} else {
		return;
	}
	dir = dir_name.head;
	makeWritable(dir);
	al_print("end\n");
}
end_body
class FileItr
member
public: void Reset(string root);
body
{
	if (al_file_manip("does_exist", root, null) && al_file_manip("is_dir", root, null)) {
	} else {
		return;
	}
	var list node, itr;
	node = al_file_manip("find_file", root, null);
	itr = al_dst_itr(node);
	stack = al_cons(al_list2("", itr), stack);
	this.root = root;
	abs_path = null;
}
end_body
member
public: list Next();
body
{
	if (stack) {
	} else {
		return null;
	}
	var list itr, node;
	if (abs_path) {
	} else {
		path = "";
		name = "";
		abs_path = root;
		is_dir = al_file_manip("is_dir", abs_path, null);
		return abs_path;
	}
	path = stack.head.head;
	itr = stack.head.tail.head;
	if (is_dir && name != "") {
		node = al_file_manip("find_file", abs_path, null);
		itr = al_dst_itr(node);
		if (path == "") {
			path = name;
		} else {
			path = path + "/" + name;
		}
		stack = al_cons(al_list2(path, itr), stack);
	} else {
	}
	loop {
		if (name = al_next(itr)) {
		} else {
			stack = stack.tail;
			if (stack) {
			} else {
				return null;
			}
			path = stack.head.head;
			itr = stack.head.tail.head;
			continue;
		}
		if (name == "." || name == "..") {
			continue;
		} else {
		}
		if (path == "") {
			abs_path = root + "/" + name;
		} else {
			abs_path = root + "/" + path + "/" + name;
		}
		is_dir = al_file_manip("is_dir", abs_path, null);
		return abs_path;
	}
}
end_body
member
public: list stack;
member
public: string root;
member
public: string path;
member
public: string name;
member
public: string abs_path;
member
public: list is_dir;
end_class
class RevFileItr
member
public: void Reset(string root);
body
{
	if (al_file_manip("does_exist", root, null) && al_file_manip("is_dir", root, null)) {
	} else {
		return;
	}
	var list node, itr;
	node = al_file_manip("find_file", root, null);
	itr = al_dst_itr(node);
	stack = al_cons(al_list2("", itr), stack);
	this.root = root;
	abs_path = null;
}
end_body
member
public: list Next();
body
{
	if (is_dir) {
		stack = stack.tail;
	} else {
	}
	if (stack) {
	} else {
		return null;
	}
	var list itr, node;
	path = stack.head.head;
	itr = stack.head.tail.head;
	loop {
		if (name = al_next(itr)) {
		} else {
			path = stack.head.head;
			if (path == "") {
				abs_path = root;
			} else {
				abs_path = root + "/" + path;
			}
			is_dir = 1;
			return abs_path;
		}
		if (name == "." || name == "..") {
			continue;
		} else {
		}
		if (path == "") {
			abs_path = root + "/" + name;
		} else {
			abs_path = root + "/" + path + "/" + name;
		}
		is_dir = al_file_manip("is_dir", abs_path, null);
		if (is_dir) {
			node = al_file_manip("find_file", abs_path, null);
			itr = al_dst_itr(node);
			if (path == "") {
				path = name;
			} else {
				path = path + "/" + name;
			}
			stack = al_cons(al_list2(path, itr), stack);
		} else {
			return abs_path;
		}
	}
}
end_body
member
public: list stack;
member
public: string root;
member
public: string path;
member
public: string name;
member
public: string abs_path;
member
public: list is_dir;
end_class
end_class
class Context
member
public: static string genTimeStamp();
body
{
	return genTimeStamp(0);
}
end_body
member
public: static string genTimeStamp(integer diff);
body
{
	var list time;
	time = al_misc("get_time", null, null);
	time = time + diff;
	time = al_misc("get_localtime", time, null);
	time = al_misc("format_time", time, "yyyyMMdd'-'HHmmss");
	return time;
}
end_body
member
public: static string genTimeStamp2();
body
{
	var list time;
	time = al_misc("get_time", null, null);
	time = al_misc("get_localtime", time, null);
	time = al_misc("format_time", time, "yyyy'/'MM'/'dd'-'HH':'mm':'ss");
	return time;
}
end_body
member
public: static string genMsgId();
body
{
	var list time;
	time = genTimeStamp();
	al_misc("para_lock", 1, null);
	if (msg_seq) {
		msg_seq = msg_seq + 1;
	} else {
		msg_seq = 1;
	}
	al_misc("para_lock", null, null);
	return time + "-" + (string)msg_seq;
}
end_body
member
public: static integer msg_seq;
end_class
class InitDB
member
public: static void init_all();
body
{
	al_print("start = " + (string)al_file_manip("current_datetime", null, null) + "\n");
	var InitDB inst;
	inst = new InitDB;
	inst.init();
	al_print("end = " + (string)al_file_manip("current_datetime", null, null) + "\n");
}
end_body
member
public: void init();
body
{
	var XmlDbAccessor acc;
	var XmlDbObject obj;
	var list ls, itr;
	var string xml;
	try {
		conn = DbManager::getConnection(WebUIServlet::pool_name);
		init_system();
		conn.commit();
		conn.close();
	} catch (AlException e) {
		al_print("Exception: " + (string)e.msg + "\n");
		al_misc("stack_trace", e.stack_frame, null);
		al_misc("error_source", al_list2(e.stack_frame, e.pos), null);
		if (conn) {
			try {
				conn.rollback();
			} catch (AlException e) {
			}
		} else {
		}
		if (conn) {
			try {
				conn.close();
			} catch (AlException e) {
			}
		} else {
		}
	}
}
end_body
member
public: void init_system();
body
{
	init_system_user();
	init_system_webuidata();
}
end_body
member
public: void init_system_user();
body
{
	var XmlDbAccessor acc;
	var XmlDbObject obj;
	var list ls, itr;
	var string xml;
	// ---- register system user admin, webuiadmin
	acc = new XmlDbAccessor;
	acc.create("User", "", conn);
	acc.setDTDfilename("User.dtd");
	xml = FileUtility::readString("data/system/init_user_admin.xml");
	acc.putXML(xml);
	xml = FileUtility::readString("data/system/init_user_webuiadmin.xml");
	acc.putXML(xml);
	al_print("system user registered.\n");
}
end_body
member
public: void init_system_webuidata();
body
{
	var XmlDbAccessor acc;
	var XmlDbObject obj;
	var list ls, itr;
	var string xml;
	// ---- register system WebUiData
	acc = new XmlDbAccessor;
	acc.create("WebUiData", "", conn);
	acc.setDTDfilename("WebUiData.dtd");
	xml = FileUtility::readString("data/system/init_webuidata.xml");
	acc.putXML(xml);
	al_print("system webuidata registered.\n");
}
end_body
member
public: DbConnection conn;
member
public: static void upate();
body
{
	al_print("start = " + (string)al_file_manip("current_datetime", null, null) + "\n");
	var InitDB inst;
	inst = new InitDB;
	inst._update();
	al_print("end = " + (string)al_file_manip("current_datetime", null, null) + "\n");
}
end_body
member
public: void _update();
body
{
	try {
		conn = DbManager::getConnection(WebUIServlet::pool_name);
		// init_system_user();
		// init_system_webuidata();
		conn.commit();
		conn.close();
	} catch (AlException e) {
		al_print("Exception: " + (string)e.msg + "\n");
		al_misc("stack_trace", e.stack_frame, null);
		al_misc("error_source", al_list2(e.stack_frame, e.pos), null);
		if (conn) {
			try {
				conn.rollback();
			} catch (AlException e) {
			}
		} else {
		}
		if (conn) {
			try {
				conn.close();
			} catch (AlException e) {
			}
		} else {
		}
	}
}
end_body
end_class
end_class
$END_BODY
