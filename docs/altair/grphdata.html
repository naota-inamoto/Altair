<HTML>
<HEAD>
<META http-equiv="Content-Type" content="text/html; charset=Shift_JIS">
<TITLE>Graph Data Structure</TITLE>
</HEAD>

<BODY>
<H1>双方向グラフデータ構造</H1>

第0.43版 2016年10月23日<BR>
第0.00版 1996年 2月11日<BR>

<HR>
ここでは、Altairのベースになっているデータ構造の特徴について述べます。<BR>

<HR>
<H3><A NAME="representation">データの表現</A></H3>
効率はともかくとして、世の中のほとんどすべてのデータというものは<BR>
グラフ構造で表現することができます。たとえば、ツリー構造はグラフですし、<BR>
表もメッシュのグラフと考えることができます。依存関係は<BR>
DAG（ループしない有効グラフ）ですし、オブジェクト指向プログラムは<BR>
クラス階層のツリー構造のノードの間に、関数/変数の参照によるアークが存在する<BR>
グラフと考えることができます。集合にしても、ツリー構造でこれを表現することが<BR>
できます。さまざまなデータ構造をそのつど定義するよりも汎用的なグラフ構造で<BR>
扱った方が覚えなければならない操作関数が減り、データを統一的に扱うことが<BR>
できるようになります。Altairでは、汎用的なグラフ構造データを根底に置き、<BR>
Altairで使われているすべてのデータをそれで表現しています。<BR>


<HR>
<H3><A NAME="dual">双方向性</A></H3>
データ構造中の要素から別の要素をたどる場合、ポインタでは単方向です。<BR>
多くのデータ構造は要素間の間を双方向にたどることができると便利な場合が<BR>
多いです。たとえば、ツリー構造で親ノードから子ノードへのみのポインタを<BR>
持たせた場合、親から子へはたどれますが子から親へたどることはできません。<BR>
アークを双方向にたどれる双方向グラフ構造データをツリー表現に用いていれば<BR>
子から親へたどることが自然にできます。また、関係のあるデータの検索を<BR>
行う場合、要素間で双方向にたどれることは必須条件です。<BR>
Altairで用いているグラフ構造データはアークを双方向にたどれる双方向<BR>
グラフ構造データです。<BR>

<HR>
<H3><A NAME="struct">構造体の表現</A></H3>
プログラムを書く場合、多くの場合ば構造体を使う必要があります。<BR>
通常この構造体は新しい構造体が加わる度に新しく定義し、<BR>
それを操作するための関数も新しく定義して書かなければなりません。<BR>
この手間はばかになりません。構造体もグラフで表現できます。<BR>
構造体をノードとし、メンバーの値もノードとし、これらのノード間に<BR>
メンバー名を属性値とするアークを張ることで構造体をグラフで表わすことが<BR>
できます。Altairでは、オブジェクト指向プログラムのクラスのインスタンスに<BR>
この手法を使っています。また、構造体を定義しなくてもこの手法で構造体が<BR>
使えるようになっています。<BR>

<HR>
<H3><A NAME="typeless">タイプレス</A></H3>
上記「構造体の表現」から推測されるように、Altairは内部的にはタイプレスです。<BR>
タイプレスの利点は、型によって異なる処理をする場合分けが少なくて済むこと、<BR>
プログラムのコンポーネント間でのデータのやりとりが簡単になることです。<BR>

<HR>
<H3><A NAME="pointer">ポインタのお化けを抽象化</A></H3>
CでもC++でも多くの場合はデータ構造はポインタのお化けになってしまいます。<BR>
その場合、ポインタの参照がらみでバグが発生した場合、そのデバッグはかなり<BR>
大変なものになると予想されます。双方向グラフ構造データは、このポインタの<BR>
お化けをある程度抽象化したものと見ることができます。たとえば、双方向に<BR>
たどれる次のようなツリー構造を作ろうとした場合を考えてみてください。<BR>
<PRE>
        a0
       /  |
      a10 a11
         /  |
        a20 a21
</PRE>
C/C++では、構造体を定義し、操作関数を定義しなければなりませんが、<BR>
それにはおそらくたくさんのポインタを使うことでしょう。Altairでは、<BR>
定義不要、ポインタなしで以下のようなコードを書くだけで済みます。<BR>
<PRE>
        a0 = al_cons(null, null);
        a10 = al_cons(null, null);
        a11 = al_cons(null, null);
        al_create_arc(a0, a10, null);
        al_create_arc(a0, a11, null);
        a20 = al_cons(null, null);
        a21 = al_cons(null, null);
        al_create_arc(a11, a20, null);
        al_create_arc(a11, a21, null);
</PRE>

<HR>
<H3><A NAME="reduce">汎用的データ構造によりプログラムサイズを縮小化</A></H3>
Altairでは、データ構造は双方向グラフ構造データのみなので、<BR>
これを操作する操作関数が基本で、別のデータ構造とその操作が入ることは<BR>
まずありません。別のデータ構造を入れるときはそれを双方向グラフ構造に<BR>
直してしまいます。このため新たなデータ構造に関係する操作関数というものが<BR>
入ってきてプログラムサイズがどんどん膨れあがっていくという心配がありません。<BR>
<BR>
もちろんユーザ定義クラスをたくさん作成する場合は別です。<BR>

<HR>
<H3><A NAME="collection">コレクションとイテレータ</A></H3>
プログラミングを行うさい、コレクションとイテレータはつきものです。<BR>
データ構造毎にコレクションとイテレータを定義するのはめんどうです。<BR>
Altairでは、入力アークと出力アークについて繰り返し処理をするための便宜を<BR>
はからっています。これをコレクションとイテレータの実現に用いることが<BR>
できます。コレクションを１階層のツリーで表わして、以下のようなコードで<BR>
繰り返し処理を実現できます。<BR>
<PRE>
var list collect;
    ...
var list itr, elem;
itr = al_dst_itr(collect);
loop {
    if (elem = al_next(itr)) {
    } else {
        break;
    }
    // 処理
}
</PRE>

<HR>
<H3><A NAME="relation1">オブジェクト間の関係付け（１）</A></H3>
特定のクラスのインスタンス間に関係を持たせ相互にたどれるようにすることは<BR>
よくあることです。これをインスタンスからポインタでダイレクトに行いたい場合、<BR>
C++では、クラスを派生させてそのためのポインタフィールドを持たせなければ<BR>
なりません。この手間はばかになりません。Altairではこれをクラスを<BR>
派生することなく、インスタンスを表わすノード間にアークをはるだけで<BR>
実現することができます。<BR>

<HR>
<H3><A NAME="relation2">オブジェクト間の関係付け（２）</A></H3>
２つの集合があって、その要素の間に多対多の関係があって、その関係に<BR>
従って要素をだどり双方向に検索するという場面を考えてください。<BR>
これをC/C++で実現しようとするとポインタのお化けのお化けになることは<BR>
ほぼ明らかです。Altairでは、２つの集合をコレクションで表わし、<BR>
コレクション中の要素間にアークを張るだけでこれを実現することができます。<BR>

<HR>
<H3><A NAME="definition">双方向グラフデータ構造</A></H3>

Altairの根底で用いている双方向グラフデータ構造について<BR>
述べます。これはAltairの内部実装の話です。<BR>
<BR>
次の４つの構造体を基本としています。それぞれの大きさは20バイトで、<BR>
Alairではこの20バイトのセルを基本単位としています。<BR>
注： Linuxのg++では20バイトですが、WindowsのVC++では24バイトになるようです。<BR>
注： 64bit版では、セルサイズは、この約2倍になります。<BR>
<PRE>
// ノード
typedef struct _AGmNode {
        unsigned char    type, flag;
        long             count;        // 参照カウント
        struct _NodeBody *body;
        union { ... } a;
} AGmNode;

// ノードボディ
typedef struct _AGmNodeBody {
        unsigned char   type, flag;
        long            extention;     // 未使用
        long            nid;
        struct  AGmLink *in, *out;
} AGmNodeBody;

// リンク
typedef struct _AGmLink {
        unsigned char   type, flag;
        long            count;
        struct _AGmArc  *arc;
        struct _AGmLink *next, *prev;
} AGmLink;

// アーク
typedef struct _AGmArc {
        unsigned char   type, flag;
        long            incl_assoc;
        struct _AGmNode *src, *dst, *attr;
} AGmArc;
</PRE>
ノードは通常の数値やリストのデータです。<BR>
アークが張っていないとノードはノードボディを持ちませんが、<BR>
アークを張るとノードボディができます。<BR>
リンクはアークを張るときにソースノードとデスティネーションノードに<BR>
ついてそれぞれ作られます。リンクは循環する双方向リンクリストになって<BR>
いて挿入/削除が簡単に行えるようになっています。<BR>
ノードボディがリンクの双方向リンクリストのルートを持っています。<BR>
リンクはアークへのポインタをもっていて、アークは<BR>
ソースノードとデスティネーションノードへのポインタを持っています。<BR>
アークはノードをその属性値として持つことができます。<BR>
この場合、ノードはグラフのノードではなくアークの属性データとみなしていることが<BR>
多いです。<BR>
<BR>
次に双方向性について述べます。<BR>
このデータ構造ではlistを除いて<BR>
どこからどこへもだどることができます。<BR>
ソースノードから出力アークとデスティネーションノードを順にたどることができますし、<BR>
デスティネーションから入力アークとソースノードを順にたどることができます。<BR>
<BR>
Altairはメモリ管理に参照カウンタを使用していますが、参照カウンタは、<BR>
listのhead or tailから参照されている場合、及び、<BR>
アークのデスティネーションになっている場合、カウントアップされます。<BR>
<BR>
Altairで用いている双方向グラフデータ構造のノードと<BR>
なり得る型を以下に示します。<BR>
<UL>
<LI>32bit整数または可変長整数
<LI>64bit浮動小数点数
<LI>リスト（headとtailからなる。LISPの２進木に相当する。）
<LI>配列
<LI>クラスのインスタンス
<LI>出力アークのイテレータ
<LI>入力アークのイテレータ
<LI>浮動小数点数の２次元の配列
<LI>ファイル
<LI>ウィンドウ
<LI>ビットマップ
<LI>任意ポインタ
<LI>OCXのインスタンス
<LI>OLEのVARIANT型のオブジェクト
</UL>

<HR>
<H3><A NAME="kiho">記法</A></H3>
"(a, b, c, d)"と書けば、<BR>
headとtailのlistからなるLISPの2進木のリストとします。<BR>
<BR>
"A-/B/->C" と書けば、ソースノードAとデスティネーションノードCの間に<BR>
属性値Bを持つアークがあることあるいはその可能性があることとします。<BR>
<BR>
"A-/B/=>C" と書けば、ソースとデスティネーションとの間の関係が１対多で<BR>
あることとします。

<HR>
<H3><A NAME="reference">参考文献</A></H3>
Altairが基にしているグラフデータ構造は、以下のふたつの参考文献の中で<BR>
使われているグラフデータ構造を、機能を落としてインタプリタ作成用に<BR>
改良を加えたものです。<BR>
<BR>
Inamoto,N., Kunii,T.L.(1989) A Graph-Based Tool for Workstations.<BR>
Workstations for Experiments(IFIP WG 5.10 International<BR>
Working Conference, Lowell, MA, USA, July 1989), ed J.L.Encarnacao<BR>
and G.G.Grinstein, Springer-Verlarg 1991.<BR>
<BR>
Inamoto,N.(1990) A Graph-Based Visual Tool for Wrokstations and<BR>
its Application to 4D Geometric Modeling. PhD.thesis at the<BR>
University of Tokyo, March 29, 1990.<BR>
<BR>
これらふたつの論文の中で、グラフベースのツールとそのアプリケーションがでて<BR>
きますが、Altairはツールのところにインタプリタを含め、アプリケーションの<BR>
ところにAltairのAPが入る形となっています。<BR>

<HR>
</BODY>
</HTML>
