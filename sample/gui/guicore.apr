$END_LIB
TEXT
AlObject
class GUI
class Window
end_class
class Hit
end_class
class Event
end_class
class TargetInfo
end_class
class Status
end_class
class Message
end_class
class Glyph
class MonoGlyph
class RootGlyph
end_class
class TMGlyph
class RightMenuGlyph
class ScrollGlyph
class FrameScrollGlyph
end_class
end_class
end_class
end_class
end_class
class PolyGlyph
class SpIdxGlyph
end_class
class FormGlyph
end_class
class HBoxGlyph
class HBoxGlyph2
end_class
end_class
class VBoxGlyph
class VBoxGlyph2
end_class
end_class
class PatchGlyph
end_class
class PictureGlyph
end_class
end_class
class PrimitiveGlyph
class LineGlyph
class ArrowLine
end_class
end_class
class RectangleGlyph
end_class
class EllipseGlyph
end_class
class PieGlyph
end_class
class LabelGlyph
class StaticLabel
end_class
class FrameLabel
end_class
class MLabel
end_class
end_class
class PathGlyph
class ArrowPath
end_class
end_class
class HierIcon
end_class
end_class
class ImageGlyph
end_class
class Editor
class GlyphEditor
class GraphEditor
end_class
end_class
class TableEditor
end_class
class HierEditor
class HierEditorNodeItr
end_class
end_class
class TextEditor
end_class
end_class
class AlControl
class AlButton
end_class
class AlScrollBar
class AlVScrollBar
end_class
class AlHScrollBar
end_class
end_class
class AlListBox
end_class
class AlComboBox
end_class
end_class
end_class
class AlDialog
class AlDialogCtrl
end_class
end_class
class AlMenu
end_class
end_class
$END_CLASS
TEXT
AlObject
class GUI
member
public: static void Initialize();
member
funcType: void GUIfunc();
member
funcType: void GUIfunc1(list arg1);
member
public: list GbCode(list pif, string str);
member
public: list GbCode(list pif);
class Window
member
public: void Create(Glyph g, list opt);
member
public: void Destroy();
member
public: void SetTitle(string s);
member
public: void Show();
member
public: void Hide();
member
public: void SetRect(integer x, integer y, integer w, integer h);
member
public: list GetRect();
member
public: void SetRect(list rect);
member
public: void Size(integer w, integer h);
member
public: void Move(integer l, integer t);
member
public: static void MoveCtrlProc(RootGlyph root, window w);
member
public: static void DrawProc(RootGlyph root, window w);
member
public: static void EventProc(RootGlyph root, window w, list event);
member
public: static void DestroyProc(RootGlyph root);
member
public: RootGlyph root;
member
public: window wnd;
member
public: void public_func();
member
public: void public_var();
end_class
class Hit
member
public: void Create(RootGlyph rt, window w, list e);
member
public: RootGlyph root;
member
public: window wnd;
member
public: list event;
member
public: void Target(Glyph g, list info);
member
public: void BeginTarget(Glyph g, list info);
member
public: void EndTarget();
member
public: list target;
member
public: void NextTarget();
member
public: Glyph TargetParent();
member
public: list parent_stack;
member
public: list target_stack;
member
public: Glyph g;
member
public: integer info;
member
public: matrix tm;
member
public: Glyph parent;
end_class
class Event
member
public: static void Initialize();
member
public: static integer LeftPress;
member
public: static integer LeftRelease;
member
public: static integer LeftDoubleClick;
member
public: static integer RightPress;
member
public: static integer RightRelease;
member
public: static integer RightDoubleClick;
member
public: static integer MouseMove;
member
public: static integer KeyPress;
member
public: static integer KeyRelease;
member
public: static integer KeyChar;
member
public: static integer Size;
member
public: static integer Enter;
member
public: static integer Leave;
member
public: static integer IsMouseEvent(integer type);
member
public: static integer IsKeyEvent(integer type);
member
public: static integer ModifShift;
member
public: static integer ModifControl;
member
public: static integer ModifAlt;
member
public: static integer UpArrow;
member
public: static integer DownArrow;
member
public: static integer LeftArrow;
member
public: static integer RightArrow;
end_class
class TargetInfo
member
public: static void Initialize();
member
public: static list LTKnob;
member
public: static list RTKnob;
member
public: static list LBKnob;
member
public: static list RBKnob;
member
public: static list FromKnob;
member
public: static list ToKnob;
member
public: static list CtrlPt;
member
public: static list MidPt;
member
public: static list LowButton;
member
public: static list LowArea;
member
public: static list SlideButton;
member
public: static list HighArea;
member
public: static list HighButton;
member
public: static list DropDown;
member
public: static list HLine;
member
public: static list VLine;
member
public: static list ParentEditor;
member
public: static list RBMenu;
end_class
class Status
member
public: static void Initialize();
member
public: static integer Execute;
member
public: static integer Click;
member
public: static integer Layout;
member
public: static integer LTKnob;
member
public: static integer RTKnob;
member
public: static integer LBKnob;
member
public: static integer RBKnob;
member
public: static integer FromKnob;
member
public: static integer ToKnob;
member
public: static integer CtrlPt;
member
public: static integer Edit;
member
public: static integer Drag;
member
public: static integer Range;
member
public: static integer InsertObject;
member
public: static integer InputNode;
member
public: static integer InputArc;
member
public: static integer InputArcDrag;
member
public: static integer InputLabel;
member
public: static integer SelectArc;
member
public: static integer ReconnectArc;
member
public: static integer Paste;
member
public: static integer LowButton;
member
public: static integer LowArea;
member
public: static integer SlideButton;
member
public: static integer HighArea;
member
public: static integer HighButton;
member
public: static integer DropDown;
member
public: static integer HLineDrag;
member
public: static integer VLineDrag;
member
public: static integer SecondChar;
end_class
class Message
member
public: static void Initialize();
member
public: static integer Select;
member
public: static integer XorSelect;
member
public: static integer SelectItem;
member
public: static integer Release;
member
public: static integer DoubleClick;
end_class
class Glyph
member
public: void Create();
member
public: void Resize(integer l, integer t, integer r, integer b);
member
public: void Resize(list rect);
member
public: void Resize(Glyph g);
member
public: void Move(integer dx, integer dy);
member
public: integer Width();
member
public: integer Height();
member
public: void MoveControl(window w);
member
public: void Draw(window w);
member
public: void Pick(Hit h);
member
public: list HitTest(Hit h);
member
public: void Destroy();
member
public: void Damage();
member
public: void Damage(integer l, integer t, integer r, integer b);
member
public: void Damage(Glyph g, list poly);
member
public: void AbsDamage(Glyph g, list poly, matrix tm1);
member
public: void AllocationChanged(Glyph g);
member
public: void MakeSpaceIndex();
member
public: void MakeSpaceIndex(TMGlyph info);
member
public: void ClearSpaceIndex();
member
public: integer left;
member
public: integer top;
member
public: integer right;
member
public: integer bottom;
member
public: list Execute(Hit h);
member
public: list ExecuteParent(integer msg, Glyph g, Hit h);
member
public: integer status;
member
public: void KnobDraw(window w);
member
public: void KnobPick(Hit h);
member
public: void KnobDamage();
member
public: void BringWindowToTop(list flag);
member
public: matrix child_tm(window w);
member
public: list _Pressed(Hit h);
member
public: list _Leave(Hit h);
member
public: list _Clicked(Hit h);
member
public: list _Select(Hit h);
member
public: list _XorSelect(Hit h);
member
public: list _Release(Hit h);
member
public: list _BeginLTKnob(Hit h);
member
public: list _BeginRTKnob(Hit h);
member
public: list _BeginLBKnob(Hit h);
member
public: list _BeginRBKnob(Hit h);
member
public: list _Knob(Hit h);
member
public: list _EndKnob(Hit h);
member
public: matrix _tm;
member
public: integer _x0;
member
public: integer _y0;
member
public: integer _l;
member
public: integer _t;
member
public: integer _r;
member
public: integer _b;
member
public: void CalcLTRB(Hit h);
member
public: void DrawRBand(window w, matrix tm, integer l, integer t, integer r, integer b);
member
public: string GbGeom();
member
public: void public_func();
member
public: void public_var();
class MonoGlyph
member
public: void MoveControl(window w);
member
public: void Draw(window w);
member
public: void Pick(Hit h);
member
public: void Destroy();
member
public: list HitTest(Hit h);
member
public: void AllocationChanged(Glyph g);
member
public: void MakeSpaceIndex();
member
public: void ClearSpaceIndex();
member
public: void Body(Glyph g);
member
public: Glyph child;
class RootGlyph
member
public: void Pick(Hit h);
member
public: void Damage(Glyph g, list poly);
member
public: void AbsDamage(Glyph g, list poly, matrix tm1);
member
public: void AllocationChanged(Glyph g);
member
public: Glyph last_hit_glyph;
member
public: matrix last_hit_tm;
member
public: Glyph last_hit_parent;
member
public: window wnd;
member
public: Glyph grab;
member
public: Glyph focus;
end_class
class TMGlyph
member
public: void Resize(integer l, integer t, integer r, integer b);
member
public: void Move(integer dx, integer dy);
member
public: void MoveControl(window w);
member
public: void Draw(window w);
member
public: void Pick(Hit h);
member
public: list HitTest(Hit h);
member
public: void Damage(Glyph g, list poly);
member
public: void AbsDamage(Glyph g, list poly, matrix tm1);
member
public: void AllocationChanged(Glyph g);
member
public: matrix tm;
member
public: void KnobDraw(window w);
member
public: void KnobPick(Hit h);
member
public: matrix child_tm(window w);
member
public: void Body(Glyph g);
member
public: void SetTM(matrix tm1);
class RightMenuGlyph
member
public: void Pick(Hit h);
member
public: list Execute(Hit h);
member
public: list _Menu(Hit h);
member
public: AlMenu menu;
class ScrollGlyph
member
public: void Resize(integer l, integer t, integer r, integer b);
member
public: void Draw(window w);
member
public: void Pick(Hit h);
member
public: list HitTest(Hit h);
member
public: void KnobDraw(window w);
member
public: void KnobPick(Hit h);
member
public: void Damage(Glyph g, list poly);
member
public: void Body(Glyph g);
member
public: void AllocationChanged(Glyph g);
member
public: void VScroll(integer pos, integer max);
member
public: void HScroll(integer pos, integer max);
member
public: integer range_left;
member
public: integer range_top;
member
public: integer range_right;
member
public: integer range_bottom;
member
public: void public_var();
member
public: void SetVScrollBarPos(AlVScrollBar vbar, integer pos);
member
public: void SetHScrollBarPos(AlHScrollBar hbar, integer pos);
class FrameScrollGlyph
member
public: void Draw(window w);
member
public: list GbCode(list pif);
end_class
end_class
end_class
end_class
end_class
class PolyGlyph
member
public: void Resize(integer l, integer t, integer r, integer b);
member
public: void MoveControl(window w);
member
public: void Draw(window w);
member
public: void Pick(Hit h);
member
public: void Destroy();
member
public: list HitTest(Hit h);
member
public: void AllocatiionChanged(Glyph g);
member
public: void MakeSpaceIndex();
member
public: void ClearSpaceIndex();
member
public: TMGlyph Prepend(Glyph g, integer x, integer y);
member
public: TMGlyph Append(Glyph g, integer x, integer y);
member
public: list Remove(TMGlyph info);
member
public: void IndexPos(list itr, integer index);
member
public: integer GlyphIndex(Glyph g);
member
public: integer GlyphIndex(list itr, Glyph g);
member
public: integer Count();
member
public: Glyph Component(integer index);
class SpIdxGlyph
member
public: static void Initialize();
member
public: void Resize(integer l, integer t, integer r, integer b);
member
public: void Pick(Hit h);
member
public: void MakeSpaceIndex();
member
public: void MakeSpaceIndex(TMGlyph info);
member
public: void ClearSpaceIndex();
member
public: list SubSpace(Hit h);
member
public: integer CoordToIndex(integer x);
member
public: static integer section_length;
member
public: list space_index;
member
public: void AllocationChanged(Glyph g);
member
public: Glyph allo_chg_glyph;
end_class
class FormGlyph
member
public: static void Initialize();
member
public: void Resize(integer l, integer t, integer r, integer b);
member
public: void Pick(Hit h);
member
public: void Attach(TMGlyph info, integer what, integer opposite, integer offset);
member
public: list attachment;
member
public: FrameScrollGlyph scroll;
member
public: AlVScrollBar vbar;
member
public: AlHScrollBar hbar;
member
public: static integer Left;
member
public: static integer Top;
member
public: static integer Right;
member
public: static integer Bottom;
member
public: static integer ConnectScroll;
member
public: static FormGlyph FormWithScroll(AlMenu menu, Glyph glyph);
member
public: void public_vfunc();
end_class
class HBoxGlyph
member
public: void Create(integer l, integer t, integer r, integer b);
member
public: void Resize(integer l, integer t, integer r, integer b);
member
public: void Draw(window w);
member
public: void Pick(Hit h);
member
public: void Damage(Glyph g, list poly);
member
public: list ExecuteParent(integer msg, Glyph g, Hit h);
member
public: list selection;
member
public: void Insert(integer index, Glyph g);
member
public: list _Insert(integer index, Glyph g);
member
public: void Remove(integer index);
member
public: void AppendItem(string s);
member
public: void Clear();
member
public: void _AllocationChanged(Glyph g);
member
public: void AllocationChanged(Glyph g);
member
public: void AllocationChanged();
class HBoxGlyph2
member
public: void Draw(window w);
member
public: void Pick(Hit h);
end_class
end_class
class VBoxGlyph
member
public: void Create(integer l, integer t, integer r, integer b);
member
public: void Resize(integer l, integer t, integer r, integer b);
member
public: void Draw(window w);
member
public: void Pick(Hit h);
member
public: void Damage(Glyph g, list poly);
member
public: list ExecuteParent(integer msg, Glyph g, Hit h);
member
public: list selection;
member
public: void Insert(integer index, Glyph g);
member
public: list _Insert(integer index, Glyph g);
member
public: void Remove(integer index);
member
public: void AppendItem(string s);
member
public: void Clear();
member
public: void _AllocationChanged(Glyph g);
member
public: void AllocationChanged(Glyph g);
member
public: void AllocationChanged();
class VBoxGlyph2
member
public: void Draw(window w);
member
public: void Pick(Hit h);
end_class
end_class
class PatchGlyph
member
public: void Resize(integer l, integer t, integer r, integer b);
member
public: void Draw(window w);
member
public: void Pick(Hit h);
member
public: integer CurrentIndex();
member
public: void CurrentIndex(integer index);
member
public: integer curr_index;
end_class
class PictureGlyph
member
public: void Create();
member
public: void Pick(Hit h);
member
public: TMGlyph Prepend(Glyph g, integer x, integer y);
member
public: TMGlyph Append(Glyph g, integer x, integer y);
member
public: void Remove(TMGlyph info);
end_class
end_class
class PrimitiveGlyph
member
public: string line_style;
member
public: integer line_width;
member
public: integer line_color;
member
public: string fill_style;
member
public: integer fill_color;
member
public: string fill_pattern;
member
public: string font_name;
member
public: integer font_height;
member
public: integer font_width;
member
public: integer font_color;
member
public: list GbAttr(list pif);
member
public: void public_var();
member
public: void Damage();
member
public: list HitTest(Hit h);
class LineGlyph
member
public: void Create(integer x1, integer y1, integer x2, integer y2);
member
public: void Draw(window w);
member
public: list HitTest(Hit h);
member
public: static list HitTest(integer x1, integer y1, integer x2, integer y2, integer x0, integer y0);
member
public: integer _x1;
member
public: integer _y1;
member
public: integer _x2;
member
public: integer _y2;
member
public: list Execute(Hit h);
member
public: void KnobDraw(window w);
member
public: void KnobPick(Hit h);
member
public: void KnobDamage();
member
public: list _BeginFromKnob(Hit h);
member
public: list _BeginToKnob(Hit h);
member
public: list _FromKnob(Hit h);
member
public: list _ToKnob(Hit h);
member
public: list _EndFromKnob(Hit h);
member
public: list _EndToKnob(Hit h);
member
public: void DrawRBand(window w, matrix tm, integer x1, integer y1, integer x2, integer y2);
member
public: list GbCode(list pif);
class ArrowLine
member
public: void Draw(window w);
member
public: void Damage();
member
public: list GbCode(list pif);
end_class
end_class
class RectangleGlyph
member
public: void Create(integer l, integer t, integer r, integer b);
member
public: void Draw(window w);
member
public: list GbCode(list pif);
end_class
class EllipseGlyph
member
public: void Create(integer l, integer t, integer r, integer b);
member
public: void Draw(window w);
member
public: list HitTest(Hit h);
member
public: list GbCode(list pif);
end_class
class PieGlyph
member
public: void Create(integer l, integer t, integer r, integer b, integer sx, integer sy, integer ex, integer ey);
member
public: void Draw(window w);
member
public: list HitTest(Hit h);
member
public: integer start_x;
member
public: integer start_y;
member
public: integer end_x;
member
public: integer end_y;
end_class
class LabelGlyph
member
public: void Create(integer l, integer t, integer r, integer b, string s);
member
public: void Draw(window w);
member
public: string text;
member
public: integer top_margin;
member
public: integer left_margin;
member
public: list Execute(Hit h);
member
public: list _Edit(Hit h);
member
public: void public_var();
member
public: list GbCode(list pif);
class StaticLabel
member
public: list Execute(Hit h);
member
public: list GbCode(list pif);
end_class
class FrameLabel
member
public: void Draw(window w);
member
public: list GbCode(list pif);
end_class
class MLabel
member
public: void Draw(window w);
member
public: list GbCode(list pif);
end_class
end_class
class PathGlyph
member
public: void Create(integer x0, integer y0, integer x1, integer y1);
member
public: void Draw(window w);
member
public: list HitTest(Hit h);
member
public: void KnobDraw(window w);
member
public: void KnobPick(Hit h);
member
public: void KnobDamage();
member
public: list Execute(Hit h);
member
public: void _CalcBBox();
member
public: list pts;
member
public: list _BeginCtrlPt(Hit h);
member
public: list _BeginMidPt(Hit h);
member
public: list _DragPt(Hit h);
member
public: list _EndDragPt(Hit h);
member
public: list _DeleteCtrlPt(Hit h);
member
public: list _pt;
member
public: void DrawRBand(window w, matrix tm, list pt, integer x, integer y);
member
public: void AddPt(integer x, integer y);
member
public: list GbCode(list pif);
class ArrowPath
member
public: void Draw(window w);
member
public: void Damage();
member
public: list GbCode(list pif);
end_class
end_class
class HierIcon
member
public: void Draw(window w);
member
public: list Execute(Hit h);
member
public: list _ClickCallback(Hit h);
member
public: list _ChangeFold(Hit h);
member
public: integer icon_color;
member
public: list close;
member
public: list close_bmp;
member
public: list open_bmp;
end_class
end_class
class ImageGlyph
member
public: void Create();
member
public: list Load(string dir, string name);
member
public: void Draw(window w);
member
public: list bitmap;
member
public: list Execute(Hit h);
member
public: list _Load(Hit h);
member
public: void public_func();
member
public: void public_var();
member
public: list GbCode(list pif);
member
public: static list loaded_images;
member
public: integer tiling;
member
public: integer stretching;
end_class
class Editor
member
public: void Resize(integer l, integer t, integer r, integer b);
member
public: void MoveControl(window w);
member
public: void Destroy();
member
public: void MakeSpaceIndex();
member
public: void ClearSpaceIndex();
member
public: SpIdxGlyph child;
member
public: list selection;
member
public: void Delete();
member
public: void Save();
member
public: void Load();
member
public: integer Save(file f);
member
public: integer Load(file f);
member
public: integer type;
member
public: string class_name;
member
public: window wnd;
member
public: void public_func();
class GlyphEditor
member
public: void Create(integer l, integer t, integer r, integer b);
member
public: void Draw(window w);
member
public: void Pick(Hit h);
member
public: matrix cache_tm;
member
public: list Execute(Hit h);
member
public: list ExecuteParent(integer msg, Glyph g, Hit h);
member
public: TMGlyph info;
member
public: integer _x0;
member
public: integer _y0;
member
public: integer _x1;
member
public: integer _y1;
member
public: integer _left;
member
public: integer _top;
member
public: integer _right;
member
public: integer _bottom;
member
public: list _BeginDrag(Hit h);
member
public: list _Drag(Hit h);
member
public: list _EndDrag(Hit h);
member
public: list _BeginRange(Hit h);
member
public: list _Range(Hit h);
member
public: list _EndRange(Hit h);
member
public: list _ChildXorSelect(Hit h);
member
public: list _InsertObject(Hit h);
member
public: Glyph insert_object;
member
public: void DrawRBand(window w, matrix tm, integer l, integer t, integer r, integer b, integer x0, integer y0, integer x1, integer y1);
member
public: void DoSelect(TMGlyph info1);
member
public: void DoXorSelect(TMGlyph info1);
member
public: void DoMove(integer dx, integer dy);
member
public: void Raise();
member
public: void Lower();
member
public: void _Raise(TMGlyph info);
member
public: void _Lower(TMGlyph info);
member
public: list GbCode(list pif);
class GraphEditor
member
public: void Create(integer l, integer t, integer r, integer b);
member
public: list CreateNode(Glyph g, integer x, integer y);
member
public: list CreateArc(list src, list dst);
member
public: list CreateLabel(list elem, string s, integer x, integer y);
member
public: void DeleteNode(list node);
member
public: void DeleteArc(list arc);
member
public: void DeleteLabel(list label);
member
public: void Delete();
member
public: void MoveNode(list node, integer dx, integer dy);
member
public: void AdjustNode(list node);
member
public: void AdjustInArc(list arc);
member
public: void AdjustOutArc(list arc);
member
public: void MoveLabel(list label, integer dx, integer dy);
member
public: void AllocationChanged(Glyph g);
member
public: list nodes;
member
public: list arcs;
member
public: list labels;
member
public: list Execute(Hit h);
member
public: list ExecuteParent(integer msg, Glyph g, Hit h);
member
public: list _Node(Hit h);
member
public: list _ExitNode(Hit h);
member
public: list _BeginArc(Hit h, TMGlyph info);
member
public: list _DragArc(Hit h);
member
public: list _EndArc(Hit h, TMGlyph info);
member
public: list _ArcNone(Hit h);
member
public: list _ExitArc(Hit h);
member
public: list _Label(Hit h, TMGlyph info);
member
public: list _ExitLabel(Hit h);
member
public: list _SelectArc(Hit h, TMGlyph info);
member
public: list _ReconnectArc(Hit h, TMGlyph info);
member
public: list _ExitReconnect(Hit h);
member
public: list _Paste(Hit h);
member
public: list src_node;
member
public: list dst_node;
member
public: list _arc;
member
public: void DrawRBand(window w, integer x0, integer y0, integer x1, integer y1);
member
public: void DoMove(integer dx, integer dy);
member
public: integer Save(file f);
member
public: integer Load(file f);
member
public: list GetSelectedNode();
member
public: static list LabelText(list node, string attr);
member
public: void Copy();
member
public: void Paste();
member
public: list GbCode(list pif);
member
public: void public_func();
end_class
end_class
class TableEditor
member
public: void Create(integer n_row, integer n_col, integer width, integer height, string s);
member
public: integer default_width;
member
public: integer default_height;
member
public: void Draw(window w);
member
public: void _DrawingArea(window w);
member
public: void _DrawCells(window w);
member
public: void _DrawLines(window w);
member
public: void _DrawSelection(window w);
member
public: integer s_row;
member
public: integer e_row;
member
public: integer s_col;
member
public: integer e_col;
member
public: void Pick(Hit h);
member
public: void _PickLines(Hit h);
member
public: list Execute(Hit h);
member
public: list ExecuteParent(integer msg, Glyph g, Hit h);
member
public: Glyph glyph;
member
public: TMGlyph info;
member
public: void InsertRow();
member
public: void InsertColumn();
member
public: void AppendRow();
member
public: void AppendColumn();
member
public: void DeleteRow();
member
public: void DeleteColumn();
member
public: void Cell(integer row, integer col, Glyph g);
member
public: Glyph Cell(integer row, integer col);
member
public: void RowHeight(integer row, integer height);
member
public: void ColumnWidth(integer col, integer width);
member
public: integer RowHeight(integer row);
member
public: integer ColumnWidth(integer col);
member
public: void InsertRow(integer row, integer height, string s);
member
public: void InsertColumn(integer col, integer width, string s);
member
public: void DeleteRow(integer row);
member
public: void DeleteColumn(integer col);
member
public: Glyph DefaultCell(integer width, integer height, string s);
member
public: integer VPosition(integer row);
member
public: integer HPosition(integer col);
member
public: void _ShiftLR(integer col, integer dx, integer d_idx);
member
public: void _ShiftTB(integer row, integer dy, integer d_idx);
member
public: integer nrow;
member
public: integer ncol;
member
public: list cells;
member
public: list _BeginVLineDrag(Hit h);
member
public: list _VLineDrag(Hit h);
member
public: list _EndVLineDrag(Hit h);
member
public: list _BeginHLineDrag(Hit h);
member
public: list _HLineDrag(Hit h);
member
public: list _EndHLineDrag(Hit h);
member
public: integer drag_line_index;
member
public: void DrawRBand(window w, matrix tm, integer x1, integer y1, integer x2, integer y2);
member
public: integer Save(file f);
member
public: integer Load(file f);
member
public: list GbCode(list pif);
member
public: void ClearRecords();
member
public: void AddRecord(list rec);
member
public: void public_var();
member
public: void public_func();
end_class
class HierEditor
member
public: void Create();
member
public: integer indent_width;
member
public: integer icon_color;
member
public: void Draw(window w);
member
public: void _DrawingArea(window w);
member
public: void _DrawItems(window w);
member
public: void _DrawLines(window w);
member
public: void _DrawSelection(window w);
member
public: void s_vpos;
member
public: void e_vpos;
member
public: void Pick(Hit h);
member
public: void Destroy();
member
public: list Execute(Hit h);
member
public: list ExecuteParent(integer msg, Glyph g, Hit h);
member
public: Glyph glyph;
member
public: TMGlyph info;
member
public: void CreateChild();
member
public: void CreateBrother();
member
public: void CreateElderBrother();
member
public: void Up();
member
public: void Down();
member
public: void Left();
member
public: void Right();
member
public: void Delete();
member
public: list CreateChild(list node);
member
public: list CreateBrother(list node);
member
public: list CreateEdlerBrother(list node);
member
public: void Adjust();
member
public: list CreateChild(list node, string s);
member
public: list CreateBrother(list node, string s);
member
public: list CreateElderBrother(list node, string s);
member
public: list __CreateOneItem(Glyph icn, string s, integer x, integer y);
member
public: void Up(list node);
member
public: void Down(list node);
member
public: void Left(list node);
member
public: void Right(list node);
member
public: void Delete(list node);
member
public: void DeleteDescendants(list node);
member
public: void _Exchange(list node1, list node2);
member
public: integer _WholeHeight(list node);
member
public: HierIcon DefaultIcon();
member
public: list Root();
member
public: list Parent(list node);
member
public: list Child(list node);
member
public: list Next(list node);
member
public: list Prev(list node);
member
public: list Last(list node);
member
public: list LastLast(list node);
member
public: list tree_root;
member
public: integer Save(file f);
member
public: integer Load(file f);
member
public: list GbCode(list pif);
member
public: list GetSelectedNode();
member
public: void public_func();
member
public: HierIcon GetIcon(list node);
member
public: LabelGlyph GetTitle(list node);
member
public: list FindNext(list node, string str);
member
public: void SetSelection(list node);
member
public: integer GetPos(list node);
member
public: void SetClickCallback(GUI obj, GUIfunc1 func);
member
public: GUI click_obj;
member
public: GUIfunc1 click_func;
class HierEditorNodeItr
member
public: void ItrReset(HierEditor hier, list node);
member
public: list ItrNext();
member
public: HierEditor hier;
member
public: list itr_indent;
member
public: list itr_root;
member
public: list itr_parent;
member
public: list itr_node;
member
public: list all;
end_class
end_class
class TextEditor
member
public: void Create();
member
public: void Resize(integer l, integer t, integer r, integer b);
member
public: void Destroy();
member
public: string text;
member
public: list lines;
member
public: list font;
member
public: integer pitch;
member
public: integer from_pos;
member
public: integer from_line_pos;
member
public: integer from_line_vpos;
member
public: list from_line;
member
public: integer to_pos;
member
public: integer to_line_pos;
member
public: integer to_line_vpos;
member
public: list to_line;
member
public: void SelFromXY(Hit h);
member
public: void PosFromX(Hit h, integer line_pos, list line, integer x);
member
public: integer sel_pos;
member
public: integer sel_line_pos;
member
public: integer sel_line_vpos;
member
public: list sel_line;
member
public: integer up_down_hpos;
member
public: matrix tm;
member
public: void Draw(window w);
member
public: list font_color_checked;
member
public: void _DrawingArea(window w);
member
public: void _DrawText(window w);
member
public: void _DrawSelection(window w);
member
public: integer s_pos;
member
public: integer s_vpos;
member
public: list s_line;
member
public: list e_line;
member
public: list Execute(Hit h);
member
public: list _BeginDrag(Hit h);
member
public: list _Drag(Hit h);
member
public: list _EndDrag(Hit h);
member
public: list _Left(Hit h);
member
public: list _Right(Hit h);
member
public: list _Up(Hit h);
member
public: list _Down(Hit h);
member
public: list _Code(integer code);
member
public: list _Code1(integer code);
member
public: list _Code2(integer code);
member
public: list _Newline();
member
public: list _BackSpace();
member
public: integer first_char;
member
public: void Cut();
member
public: void Copy();
member
public: void Paste();
member
public: void Clear();
member
public: void Replace(string str);
member
public: void _Replace(string str);
member
public: string GetSelText();
member
public: list no_redraw;
member
public: integer Save(file f);
member
public: integer Load(file f);
member
public: list GbCode(list pif);
member
public: void ClearAll();
member
public: void public_var();
member
public: void public_func();
member
public: integer GetLineCount();
member
public: integer GetCursorPos();
member
public: integer GetPosLineNumber(integer pos);
member
public: list GetLineStartEndPos(integer line_no);
member
public: list SetSelection(integer from, integer to);
member
public: integer GetCursorYPos();
member
public: string GetCurrentLine();
member
public: void SetDoubleClickCallback(GUI obj, GUIfunc func);
member
public: GUI _obj;
member
public: GUIfunc _func;
member
public: list _DoubleClick(Hit h);
member
public: string GetText();
member
public: void Find(string str);
member
public: void FindNext(string str);
member
public: integer search_pos;
member
public: list debug;
end_class
end_class
class AlControl
member
public: void Create(integer l, integer t, integer r, integer b);
member
public: integer face_color;
member
public: integer highlight_color;
member
public: integer shadow_color;
member
public: integer frame_color;
member
public: integer text_color;
member
public: integer text_bg_color;
member
public: integer font_name;
member
public: integer font_height;
member
public: integer font_width;
member
public: list GbAttr(list pif);
member
public: void public_var();
class AlButton
member
public: void Create(integer l, integer t, integer r, integer b, string txt);
member
public: void Draw(window w);
member
public: void Destroy();
member
public: static void DrawBase(window w, integer l, integer t, integer r, integer b, integer frame, integer face, integer lt, integer rb);
member
public: string face_text;
member
public: void SetCallback(GUI obj, GUIfunc func);
member
public: GUI _obj;
member
public: GUIfunc _func;
member
public: list _Clicked(Hit h);
member
public: void public_var();
member
public: void public_func();
member
public: list GbCode(list pif);
end_class
class AlScrollBar
member
public: integer direction;
member
public: integer delta1;
member
public: integer delta2;
member
public: integer max;
member
public: integer pos;
member
public: integer prepos;
member
public: integer dmgpos;
member
public: integer timer_id;
member
public: integer delta;
member
public: list Execute(Hit h);
member
public: list _BeginSlide(Hit h);
member
public: list _Slide(Hit h);
member
public: list _EndSlide(Hit h);
member
public: list _BeginLowB(Hit h);
member
public: list _BeginHighB(Hit h);
member
public: list _BeginLowA(Hit h);
member
public: list _BeginHighA(Hit h);
member
public: list _Timer(Hit h);
member
public: list _EndTimer(Hit h);
member
public: list _EndLowB(Hit h);
member
public: list _EndHighB(Hit h);
member
public: void DamageLowButton();
member
public: void DamageSlideButton();
member
public: void DamageHighButton();
member
public: void Connect(ScrollGlyph sg);
member
public: void Adjust(ScrollGlyph sg);
member
public: void Scroll();
member
public: void set_timer(integer period);
member
public: void clear_timer();
member
public: void timer_callback();
class AlVScrollBar
member
public: void Create(integer l, integer t, integer r, integer b);
member
public: void Resize(integer l, integer t, integer r, integer b);
member
public: void Draw(window w);
member
public: void Pick(Hit h);
member
public: void DamageLowButton();
member
public: void DamageSlideButton();
member
public: void DamageHighButton();
member
public: void Connect(ScrollGlyph sg);
member
public: void Adjust(ScrollGlyph sg);
member
public: void Scroll();
member
public: list scrolls;
member
public: list GbCode(list pif);
end_class
class AlHScrollBar
member
public: void Create(integer l, integer t, integer r, integer b);
member
public: void Resize(integer l, integer t, integer r, integer b);
member
public: void Draw(window w);
member
public: void Pick(Hit h);
member
public: void DamageLowButton();
member
public: void DamageSlideButton();
member
public: void DamageHighButton();
member
public: void Connect(ScrollGlyph sg);
member
public: void Adjust(ScrollGlyph sg);
member
public: void Scroll();
member
public: list scrolls;
member
public: list GbCode(list pif);
end_class
end_class
class AlListBox
member
public: void Create(integer l, integer t, integer r, integer b);
member
public: list for_combo_box;
member
public: void Resize(integer l, integer t, integer r, integer b);
member
public: void Draw(window w);
member
public: void Pick(Hit h);
member
public: VBoxGlyph vbox;
member
public: FrameScrollGlyph scroll;
member
public: AlVScrollBar vbar;
member
public: FormGlyph child;
member
public: integer Count();
member
public: void AddItem(integer index, string s);
member
public: void DeleteItem(integer index);
member
public: string GetItemText(integer index);
member
public: integer CurrentIndex();
member
public: void CurrentIndex(integer index);
member
public: void AppendItem(string s);
member
public: void ClearAllItems();
member
public: void public_var();
member
public: list GbCode(list pif);
end_class
class AlComboBox
member
public: void Create(integer l, integer t, integer r, integer b);
member
public: void Resize(integer l, integer t, integer r, integer b);
member
public: integer Height();
member
public: void Draw(window w);
member
public: void Pick(Hit h);
member
public: LabelGlyph label;
member
public: AlListBox child;
member
public: integer dropdown;
member
public: list Execute(Hit h);
member
public: list ExecuteParent(integer msg, Glyph g, Hit h);
member
public: list _DropDown(Hit h);
member
public: list _SelectItem(Hit h);
member
public: integer CurrentIndex();
member
public: void public_var();
member
public: list GbCode(list pif);
end_class
end_class
end_class
class AlDialog
member
public: static list InputName(integer x, integer y, string title, string name);
member
public: static list SelectName(integer x, integer y, string title, list name_list);
member
public: static list ChooseName(integer x, integer y, string title, string text, string str1, string str2, string str3, string str4);
member
public: list ShowInput(integer x, integer y, string title, string name);
member
public: list ShowSelect(integer x, integer y, string title, list name_list);
member
public: list ShowChoose(integer x, integer y, string title, string text, string str1, string str2, string str3, string str4);
member
public: list ShowInput(string title, string name);
member
public: list ShowSelect(string title, list name_list);
member
public: list ShowChoose(string title, string text, string str1, string str2, string str3, string str4);
member
public: list text;
class AlDialogCtrl
member
public: void OkButton();
member
public: void CancelButton();
member
public: list ok;
member
public: window wnd;
member
public: void Button1();
member
public: void Button2();
member
public: void Button3();
member
public: void Button4();
member
public: list str1;
member
public: list str2;
member
public: list str3;
member
public: list str4;
member
public: list choice;
end_class
end_class
class AlMenu
member
public: void Clear();
member
public: void Append(string s, AlMenu sub, GUI obj, GUIfunc func);
member
public: void Append(string s, AlMenu sub);
member
public: void Append(string s, GUI obj, GUIfunc func);
member
public: void Execute(window w, list event);
member
public: list menu;
end_class
end_class
$END_MEMBER
TEXT
AlObject
class GUI
member
public: static void Initialize();
body
{
	Event::Initialize();
	TargetInfo::Initialize();
	Status::Initialize();
	Message::Initialize();
	FormGlyph::Initialize();
	SpIdxGlyph::Initialize();
}
end_body
member
funcType: void GUIfunc();
member
funcType: void GUIfunc1(list arg1);
member
public: list GbCode(list pif, string str);
body
{
	if (al_gp("pif_insert", pif, str, null, null)) {
		al_print("An error occurs at GbCode.\n");
		al_print(str);
		al_print("\n");
		return 1;
	} else {
		return null;
	}
}
end_body
member
public: list GbCode(list pif);
body
{
	return null;
}
end_body
class Window
member
public: void Create(Glyph g, list opt);
body
{
	root = new RootGlyph;
	wnd = al_create_window(opt);
	al_set_window_arg(wnd, "root", root);
	al_set_window_arg(wnd, "w", wnd);
	al_set_move_ctrl_proc(wnd, Window::MoveCtrlProc);
	al_set_draw_proc(wnd, Window::DrawProc);
	al_set_event_proc(wnd, Window::EventProc);
	// al_set_destroy_proc(wnd, Window::DestroyProc);
	root.wnd = wnd;
	root.Body(g);
	al_wnd_message(wnd, "size", null, null);
	al_redraw(wnd);
}
end_body
member
public: void Destroy();
body
{
	al_destroy_window(wnd);
}
end_body
member
public: void SetTitle(string s);
body
{
	al_set_title(wnd, s);
}
end_body
member
public: void Show();
body
{
	al_show_window(wnd);
}
end_body
member
public: void Hide();
body
{
	al_hide_window(wnd);
}
end_body
member
public: void SetRect(integer x, integer y, integer w, integer h);
body
{
	al_set_window_rect(wnd, x, y, w, h);
	al_wnd_message(wnd, "size", null, null);
}
end_body
member
public: list GetRect();
body
{
	return al_get_window_rect(wnd, 0);
}
end_body
member
public: void SetRect(list rect);
body
{
	SetRect((integer)rect.head, (integer)rect.tail.head, (integer)rect.tail.tail.head, (integer)rect.tail.tail.tail.head);
}
end_body
member
public: void Size(integer w, integer h);
body
{
	al_resize_window(wnd, w, h);
	al_wnd_message(wnd, "size", null, null);
}
end_body
member
public: void Move(integer l, integer t);
body
{
	al_move_window(wnd, l, t);
}
end_body
member
public: static void MoveCtrlProc(RootGlyph root, window w);
body
{
	root.MoveControl(w);
}
end_body
member
public: static void DrawProc(RootGlyph root, window w);
body
{
	root.Draw(w);
}
end_body
member
public: static void EventProc(RootGlyph root, window w, list event);
body
{
	var Hit h;
	h = new Hit;
	h.Create(root, w, event);
	root.Pick(h);
	var Glyph enter_glyph, leave_glyph;
	if (h.target) {
		if (al_addr_eq(h.g, root.last_hit_glyph)) {
		} else {
			leave_glyph = root.last_hit_glyph;
			enter_glyph = root.last_hit_glyph = h.g;
		}
	} else {
		if (root.last_hit_glyph) {
			leave_glyph = root.last_hit_glyph;
			root.last_hit_glyph = null;
		} else {
		}
	}
	loop {
		if (h.target) {
		} else {
			break;
		}
		if (h.g.Execute(h)) {
			break;
		} else {
		}
		h.NextTarget();
	}
	h.info = null;
	if (leave_glyph) {
		h.event.head = Event::Leave;
		leave_glyph.Execute(h);
	} else {
	}
	if (enter_glyph) {
		h.event.head = Event::Enter;
		enter_glyph.Execute(h);
	} else {
	}
}
end_body
member
public: static void DestroyProc(RootGlyph root);
body
{
	root.Destroy();
}
end_body
member
public: RootGlyph root;
member
public: window wnd;
member
public: void public_func();
body
{
	Create((Glyph)null, null);
	Destroy();
	SetTitle((string)null);
	Show();
	Hide();
	SetRect(0, 0, 300, 300);
	GetRect();
	Size(100, 100);
	Move(0, 0);
}
end_body
member
public: void public_var();
body
{
	wnd;
}
end_body
end_class
class Hit
member
public: void Create(RootGlyph rt, window w, list e);
body
{
	root = rt;
	wnd = w;
	event = e;
	parent_stack = al_cons(null, null);
	target_stack = al_cons(null, null);
}
end_body
member
public: RootGlyph root;
member
public: window wnd;
member
public: list event;
member
public: void Target(Glyph g, list info);
body
{
	var list target, itr;
	var matrix tm;
	tm = al_window_tm(wnd);
	target = al_list3(g, info, tm);
	al_create_arc(target_stack, target, null);
	var Glyph parent;
	itr = al_dst_itr(parent_stack);
	if (parent = al_prev(itr)) {
		al_create_arc(target, parent, "target");
	} else {
	}
	this.target = target;
	this.g = g;
	this.info = info;
	this.tm = tm;
	this.parent = parent;
}
end_body
member
public: void BeginTarget(Glyph g, list info);
body
{
	Target(g, info);
	al_create_arc(parent_stack, g, null);
}
end_body
member
public: void EndTarget();
body
{
	var list itr;
	itr = al_dst_itr(parent_stack);
	al_prev(itr);
	al_remove(itr);
}
end_body
member
public: list target;
member
public: void NextTarget();
body
{
	if (target = al_prev_dst_node(target_stack, target, null)) {
		g = target.head;
		info = target.tail.head;
		tm = target.tail.tail.head;
		parent = TargetParent();
	} else {
		g = null;
		info = null;
		tm = null;
		parent = null;
	}
	return;
}
end_body
member
public: Glyph TargetParent();
body
{
	return al_dst_node(target, "target");
}
end_body
member
public: list parent_stack;
member
public: list target_stack;
member
public: Glyph g;
member
public: integer info;
member
public: matrix tm;
member
public: Glyph parent;
end_class
class Event
member
public: static void Initialize();
body
{
	LeftPress = 0;
	LeftRelease = 1;
	LeftDoubleClick = 2;
	RightPress = 3;
	RightRelease = 4;
	RightDoubleClick = 5;
	MouseMove = 6;
	KeyPress = 7;
	KeyRelease = 8;
	KeyChar = 9;
	Size = 12;
	Enter = 100;
	Leave = 101;
	ModifShift = 0x1;
	ModifControl = 0x2;
	ModifAlt = 0x4;
	if (al_misc("platform", null, null) == "windows") {
		LeftArrow = 0x25;
		UpArrow = 0x26;
		RightArrow = 0x27;
		DownArrow = 0x28;
	} else {
	}
	if (al_misc("platform", null, null) == "linux" || al_misc("platform", null, null) == "mac") {
		LeftArrow = 0x51;
		UpArrow = 0x52;
		RightArrow = 0x53;
		DownArrow = 0x54;
	} else {
	}
}
end_body
member
public: static integer LeftPress;
member
public: static integer LeftRelease;
member
public: static integer LeftDoubleClick;
member
public: static integer RightPress;
member
public: static integer RightRelease;
member
public: static integer RightDoubleClick;
member
public: static integer MouseMove;
member
public: static integer KeyPress;
member
public: static integer KeyRelease;
member
public: static integer KeyChar;
member
public: static integer Size;
member
public: static integer Enter;
member
public: static integer Leave;
member
public: static integer IsMouseEvent(integer type);
body
{
	return LeftPress <= type && type <= MouseMove;
}
end_body
member
public: static integer IsKeyEvent(integer type);
body
{
	return KeyPress <= type && type <= KeyChar;
}
end_body
member
public: static integer ModifShift;
member
public: static integer ModifControl;
member
public: static integer ModifAlt;
member
public: static integer UpArrow;
member
public: static integer DownArrow;
member
public: static integer LeftArrow;
member
public: static integer RightArrow;
end_class
class TargetInfo
member
public: static void Initialize();
body
{
	LTKnob = 0;
	RTKnob = 1;
	LBKnob = 2;
	RBKnob = 3;
	FromKnob = 4;
	ToKnob = 5;
	CtrlPt = 6;
	MidPt = 7;
	LowButton = 10;
	LowArea = 11;
	SlideButton = 12;
	HighArea = 13;
	HighButton = 14;
	DropDown = 15;
	HLine = 20;
	VLine = 21;
	ParentEditor = 25;
	RBMenu = 30;
}
end_body
member
public: static list LTKnob;
member
public: static list RTKnob;
member
public: static list LBKnob;
member
public: static list RBKnob;
member
public: static list FromKnob;
member
public: static list ToKnob;
member
public: static list CtrlPt;
member
public: static list MidPt;
member
public: static list LowButton;
member
public: static list LowArea;
member
public: static list SlideButton;
member
public: static list HighArea;
member
public: static list HighButton;
member
public: static list DropDown;
member
public: static list HLine;
member
public: static list VLine;
member
public: static list ParentEditor;
member
public: static list RBMenu;
end_class
class Status
member
public: static void Initialize();
body
{
	Execute = 0;
	Click = 1;
	Layout = 10;
	LTKnob = 13;
	RTKnob = 14;
	LBKnob = 15;
	RBKnob = 16;
	FromKnob = 17;
	ToKnob = 18;
	CtrlPt = 19;
	Edit = 30;
	Drag = 31;
	Range = 32;
	InsertObject = 33;
	InputNode = 40;
	InputArc = 41;
	InputArcDrag = 42;
	InputLabel = 43;
	SelectArc = 44;
	ReconnectArc = 45;
	Paste = 46;
	LowButton = 50;
	LowArea = 51;
	SlideButton = 52;
	HighArea = 53;
	HighButton = 54;
	DropDown = 55;
	HLineDrag = 60;
	VLineDrag = 61;
	SecondChar = 70;
}
end_body
member
public: static integer Execute;
member
public: static integer Click;
member
public: static integer Layout;
member
public: static integer LTKnob;
member
public: static integer RTKnob;
member
public: static integer LBKnob;
member
public: static integer RBKnob;
member
public: static integer FromKnob;
member
public: static integer ToKnob;
member
public: static integer CtrlPt;
member
public: static integer Edit;
member
public: static integer Drag;
member
public: static integer Range;
member
public: static integer InsertObject;
member
public: static integer InputNode;
member
public: static integer InputArc;
member
public: static integer InputArcDrag;
member
public: static integer InputLabel;
member
public: static integer SelectArc;
member
public: static integer ReconnectArc;
member
public: static integer Paste;
member
public: static integer LowButton;
member
public: static integer LowArea;
member
public: static integer SlideButton;
member
public: static integer HighArea;
member
public: static integer HighButton;
member
public: static integer DropDown;
member
public: static integer HLineDrag;
member
public: static integer VLineDrag;
member
public: static integer SecondChar;
end_class
class Message
member
public: static void Initialize();
body
{
	Select = 0;
	XorSelect = 1;
	SelectItem = 2;
	Release = 3;
	DoubleClick = 4;
}
end_body
member
public: static integer Select;
member
public: static integer XorSelect;
member
public: static integer SelectItem;
member
public: static integer Release;
member
public: static integer DoubleClick;
end_class
class Glyph
member
public: void Create();
body
{
	status = Status::Layout;
}
end_body
member
public: void Resize(integer l, integer t, integer r, integer b);
body
{
	left = l;
	top = t;
	right = r;
	bottom = b;
}
end_body
member
public: void Resize(list rect);
body
{
	var integer l, t, r, b;
	l = rect.head;
	t = rect.tail.head;
	r = rect.tail.tail.head;
	b = rect.tail.tail.tail.head;
	Resize(l, t, r, b);
}
end_body
member
public: void Resize(Glyph g);
body
{
	Resize(g.left, g.top, g.right, g.bottom);
}
end_body
member
public: void Move(integer dx, integer dy);
body
{
	Resize(left + dx, top + dy, right + dx, bottom + dy);
}
end_body
member
public: integer Width();
body
{
	return right - left;
}
end_body
member
public: integer Height();
body
{
	return bottom - top;
}
end_body
member
public: void MoveControl(window w);
body
{
}
end_body
member
public: void Draw(window w);
body
{
}
end_body
member
public: void Pick(Hit h);
body
{
	if (HitTest(h)) {
		h.Target(this, null);
	} else {
	}
}
end_body
member
public: list HitTest(Hit h);
body
{
	if (Event::IsMouseEvent((integer)h.event.head)) {
	} else {
		return null;
	}
	var list xy;
	var integer x, y;
	xy = al_inverse_xy(al_window_tm(h.wnd), h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	if (left <= x && x <= right && top <= y && y <= bottom) {
		return 1;
	} else {
		return null;
	}
}
end_body
member
public: void Destroy();
member
public: void Damage();
body
{
	var list poly;
	poly = al_create_poly_poly();
	al_add_rect_to_poly(poly, left, top, right + 1, bottom + 1);
	Glyph::Damage(this, poly);
}
end_body
member
public: void Damage(integer l, integer t, integer r, integer b);
body
{
	var list poly;
	poly = al_create_poly_poly();
	al_add_rect_to_poly(poly, l, t, r + 1, b + 1);
	Glyph::Damage(this, poly);
}
end_body
member
public: void Damage(Glyph g, list poly);
body
{
	var list itr;
	itr = al_src_itr(this);
	var Glyph parent;
	loop {
		if (parent = al_next_a(itr, "child")) {
		} else {
			break;
		}
		parent.Damage(this, poly);
	}
}
end_body
member
public: void AbsDamage(Glyph g, list poly, matrix tm1);
body
{
	var list itr;
	itr = al_src_itr(this);
	var Glyph parent;
	loop {
		if (parent = al_next_a(itr, "child")) {
		} else {
			break;
		}
		parent.AbsDamage(this, poly, tm1);
	}
}
end_body
member
public: void AllocationChanged(Glyph g);
body
{
	var list itr;
	itr = al_src_itr(this);
	var Glyph parent;
	loop {
		if (parent = al_next_a(itr, "child")) {
		} else {
			break;
		}
		parent.AllocationChanged(this);
	}
}
end_body
member
public: void MakeSpaceIndex();
body
{
}
end_body
member
public: void MakeSpaceIndex(TMGlyph info);
body
{
}
end_body
member
public: void ClearSpaceIndex();
body
{
}
end_body
member
public: integer left;
member
public: integer top;
member
public: integer right;
member
public: integer bottom;
member
public: list Execute(Hit h);
body
{
	var integer type, modif, info;
	type = h.event.head;
	modif = h.event.tail.tail.tail.tail.head;
	info = h.info;
	if (type == Event::LeftPress && modif != 0x2) {
		if (status == Status::Execute) {
			if (info == null && _Pressed(h)) {
				status = Status::Click;
				Damage();
				return 1;
			} else {
			}
		} else {
		}
		if (status == Status::Click && _Leave(h)) {
			status = Status::Execute;
			Damage();
			return 1;
		} else {
		}
		if (status == Status::Layout) {
			if (info) {
				if (info == TargetInfo::LTKnob && _BeginLTKnob(h)) {
					status = Status::LTKnob;
					return 1;
				} else {
				}
				if (info == TargetInfo::RTKnob && _BeginRTKnob(h)) {
					status = Status::RTKnob;
					return 1;
				} else {
				}
				if (info == TargetInfo::LBKnob && _BeginLBKnob(h)) {
					status = Status::LBKnob;
					return 1;
				} else {
				}
				if (info == TargetInfo::RBKnob && _BeginRBKnob(h)) {
					status = Status::RBKnob;
					return 1;
				} else {
				}
			} else {
				var Glyph g;
				g = h.parent;
				if (g && _Select(h) && g.ExecuteParent(Message::Select, this, h)) {
					return 1;
				} else {
				}
				if (g && _XorSelect(h) && g.ExecuteParent(Message::XorSelect, this, h)) {
					return 1;
				} else {
				}
			}
		} else {
		}
	} else {
	}
	if (type == Event::Leave) {
		if (status == Status::Click && _Leave(h)) {
			status = Status::Execute;
			Damage();
			return 1;
		} else {
		}
	} else {
	}
	if (type == Event::MouseMove) {
		if (status == Status::LTKnob && _Knob(h)) {
			return 1;
		} else {
		}
		if (status == Status::RTKnob && _Knob(h)) {
			return 1;
		} else {
		}
		if (status == Status::LBKnob && _Knob(h)) {
			return 1;
		} else {
		}
		if (status == Status::RBKnob && _Knob(h)) {
			return 1;
		} else {
		}
	} else {
	}
	if (type == Event::LeftRelease) {
		if (status == Status::Click && _Clicked(h)) {
			status = Status::Execute;
			Damage();
			return 1;
		} else {
		}
		if (status == Status::Layout) {
			if (info) {
			} else {
				var Glyph g;
				g = h.parent;
				if (g && _Release(h) && g.ExecuteParent(Message::Release, this, h)) {
					return 1;
				} else {
				}
			}
		} else {
		}
		if (status == Status::LTKnob && _EndKnob(h)) {
			status = Status::Layout;
			return 1;
		} else {
		}
		if (status == Status::RTKnob && _EndKnob(h)) {
			status = Status::Layout;
			return 1;
		} else {
		}
		if (status == Status::LBKnob && _EndKnob(h)) {
			status = Status::Layout;
			return 1;
		} else {
		}
		if (status == Status::RBKnob && _EndKnob(h)) {
			status = Status::Layout;
			return 1;
		} else {
		}
	} else {
	}
	return null;
}
end_body
member
public: list ExecuteParent(integer msg, Glyph g, Hit h);
body
{
	return null;
}
end_body
member
public: integer status;
member
public: void KnobDraw(window w);
body
{
	var matrix tm;
	var integer sx, sy;
	if (tm = al_window_tm(w)) {
		sx = 6 / tm[0][0];
		sy = 6 / tm[1][1];
	} else {
		sx = 6;
		sy = 6;
	}
	al_rectangle(w, left - sx - 1, top - sy - 1, left - 1, top - 1);
	al_rectangle(w, right + 1, top - sy - 1, right + sx + 1, top - 1);
	al_rectangle(w, left - sx - 1, bottom + 1, left - 1, bottom + sy + 1);
	al_rectangle(w, right + 1, bottom + 1, right + sx + 1, bottom + sy + 1);
}
end_body
member
public: void KnobPick(Hit h);
body
{
	if (Event::IsMouseEvent((integer)h.event.head)) {
	} else {
		return;
	}
	var matrix tm1;
	tm1 = al_window_tm(h.wnd);
	var integer x, y;
	var list xy;
	xy = al_inverse_xy(tm1, h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	var integer sx, sy;
	if (tm1) {
		sx = 6 / tm1[0][0];
		sy = 6 / tm1[1][1];
	} else {
		sx = 6;
		sy = 6;
	}
	if (x < left - sx - 1 || right + sx + 1 < x) {
		return;
	} else {
	}
	if (y < top - sy - 1 || bottom + sy + 1 < y) {
		return;
	} else {
	}
	if (x <= left - 1) {
		if (y <= top - 1) {
			h.Target(this, TargetInfo::LTKnob);
			return;
		} else {
		}
		if (bottom + 1 <= y) {
			h.Target(this, TargetInfo::LBKnob);
			return;
		} else {
		}
	} else {
	}
	if (right - 1 <= x) {
		if (y <= top - 1) {
			h.Target(this, TargetInfo::RTKnob);
			return;
		} else {
		}
		if (bottom + 1 <= y) {
			h.Target(this, TargetInfo::RBKnob);
			return;
		} else {
		}
	} else {
	}
}
end_body
member
public: void KnobDamage();
body
{
	var list poly;
	var matrix tm;
	poly = al_create_poly_poly();
	al_add_rect_to_poly(poly, -6, -6, 0, 0);
	tm = al_translate_tm(left - 1, top - 1);
	Glyph::AbsDamage(this, poly, tm);
	poly = al_create_poly_poly();
	al_add_rect_to_poly(poly, 0, -6, 6, 0);
	tm = al_translate_tm(right + 1, top - 1);
	Glyph::AbsDamage(this, poly, tm);
	poly = al_create_poly_poly();
	al_add_rect_to_poly(poly, -6, 0, 0, 6);
	tm = al_translate_tm(left - 1, bottom + 1);
	Glyph::AbsDamage(this, poly, tm);
	poly = al_create_poly_poly();
	al_add_rect_to_poly(poly, 0, 0, 6, 6);
	tm = al_translate_tm(right + 1, bottom + 1);
	Glyph::AbsDamage(this, poly, tm);
}
end_body
member
public: void BringWindowToTop(list flag);
body
{
}
end_body
member
public: matrix child_tm(window w);
body
{
	var matrix tm1, tm2;
	tm2 = al_translate_tm(left, top);
	if (tm1 = al_window_tm(w)) {
		tm2 = tm1 * tm2;
	} else {
	}
	return tm2;
}
end_body
member
public: list _Pressed(Hit h);
body
{
	h.root.focus = this;
	Damage();
	return 1;
}
end_body
member
public: list _Leave(Hit h);
body
{
	Damage();
	return 1;
}
end_body
member
public: list _Clicked(Hit h);
body
{
	Damage();
	return 1;
}
end_body
member
public: list _Select(Hit h);
body
{
	var integer modifier;
	modifier = h.event.tail.tail.tail.tail.head;
	if (modifier == 0) {
		return 1;
	} else {
		return null;
	}
}
end_body
member
public: list _XorSelect(Hit h);
body
{
	var integer modifier;
	modifier = h.event.tail.tail.tail.tail.head;
	if (modifier == Event::ModifShift) {
		return 1;
	} else {
		return null;
	}
}
end_body
member
public: list _Release(Hit h);
body
{
	var integer modifier;
	modifier = h.event.tail.tail.tail.tail.head;
	if (modifier == 0) {
		return 1;
	} else {
		return null;
	}
}
end_body
member
public: list _BeginLTKnob(Hit h);
body
{
	h.root.grab = this;
	_tm = h.tm;
	_x0 = right;
	_y0 = bottom;
	CalcLTRB(h);
	DrawRBand(h.wnd, _tm, _l, _t, _r, _b);
	return 1;
}
end_body
member
public: list _BeginRTKnob(Hit h);
body
{
	h.root.grab = this;
	_tm = h.tm;
	_x0 = left;
	_y0 = bottom;
	CalcLTRB(h);
	DrawRBand(h.wnd, _tm, _l, _t, _r, _b);
	return 1;
}
end_body
member
public: list _BeginLBKnob(Hit h);
body
{
	h.root.grab = this;
	_tm = h.tm;
	_x0 = right;
	_y0 = top;
	CalcLTRB(h);
	DrawRBand(h.wnd, _tm, _l, _t, _r, _b);
	return 1;
}
end_body
member
public: list _BeginRBKnob(Hit h);
body
{
	h.root.grab = this;
	_tm = h.tm;
	_x0 = left;
	_y0 = top;
	CalcLTRB(h);
	DrawRBand(h.wnd, _tm, _l, _t, _r, _b);
	return 1;
}
end_body
member
public: list _Knob(Hit h);
body
{
	DrawRBand(h.wnd, _tm, _l, _t, _r, _b);
	CalcLTRB(h);
	DrawRBand(h.wnd, _tm, _l, _t, _r, _b);
	return 1;
}
end_body
member
public: list _EndKnob(Hit h);
body
{
	DrawRBand(h.wnd, _tm, _l, _t, _r, _b);
	Damage();
	KnobDamage();
	Resize(_l, _t, _r, _b);
	AllocationChanged(this);
	Damage();
	KnobDamage();
	h.root.grab = null;
	_tm = null;
	_x0 = _y0 = _l = _t = _r = _b = null;
	return 1;
}
end_body
member
public: matrix _tm;
member
public: integer _x0;
member
public: integer _y0;
member
public: integer _l;
member
public: integer _t;
member
public: integer _r;
member
public: integer _b;
member
public: void CalcLTRB(Hit h);
body
{
	var list e;
	e = h.event;
	var list xy1;
	var integer _x1, _y1;
	xy1 = al_inverse_xy(_tm, e.tail.head, e.tail.tail.head);
	_x1 = xy1.head;
	_y1 = xy1.tail.head;
	_l = al_min(_x0, _x1);
	_t = al_min(_y0, _y1);
	_r = al_max(_x0, _x1);
	_b = al_max(_y0, _y1);
}
end_body
member
public: void DrawRBand(window w, matrix tm, integer l, integer t, integer r, integer b);
body
{
	al_start_quick_draw(w);
	al_push_color_func(w, 2);
	al_push_pen(w, "Solid", 0, 0xffffff);
	al_push_brush(w, "Null", 0x0, null);
	al_push_tm(w, tm);
	al_line(w, l, t, r, t);
	al_line(w, r, t, r, b);
	al_line(w, r, b, l, b);
	al_line(w, l, b, l, t);
	al_pop_tm(w);
	al_pop_brush(w);
	al_pop_pen(w);
	al_pop_color_func(w);
	al_end_quick_draw(w);
}
end_body
member
public: string GbGeom();
body
{
	return (string)left + ", " + (string)top + ", " + (string)right + ", " + (string)bottom;
}
end_body
member
public: void public_func();
body
{
	Damage();
}
end_body
member
public: void public_var();
body
{
	left;
	top;
	right;
	bottom;
}
end_body
class MonoGlyph
member
public: void MoveControl(window w);
body
{
	if (child) {
		child.MoveControl(w);
	} else {
	}
}
end_body
member
public: void Draw(window w);
body
{
	if (child) {
		child.Draw(w);
	} else {
	}
}
end_body
member
public: void Pick(Hit h);
body
{
	if (child) {
		child.Pick(h);
	} else {
	}
}
end_body
member
public: void Destroy();
body
{
	if (child) {
		child.Destroy();
	} else {
	}
}
end_body
member
public: list HitTest(Hit h);
body
{
	if (child) {
		return child.HitTest(h);
	} else {
	}
}
end_body
member
public: void AllocationChanged(Glyph g);
body
{
	Body(child);
	Glyph::AllocationChanged(this);
}
end_body
member
public: void MakeSpaceIndex();
body
{
	if (child) {
		child.MakeSpaceIndex();
	} else {
	}
}
end_body
member
public: void ClearSpaceIndex();
body
{
	if (child) {
		child.ClearSpaceIndex();
	} else {
	}
}
end_body
member
public: void Body(Glyph g);
body
{
	child = g;
	if (g) {
		left = g.left;
		top = g.top;
		right = g.left + g.Width();
		bottom = g.top + g.Height();
	} else {
		left = top = right = bottom = 0;
	}
}
end_body
member
public: Glyph child;
class RootGlyph
member
public: void Pick(Hit h);
body
{
	if (h.event.head == Event::Size) {
		var integer width, height;
		width = h.event.tail.head;
		height = h.event.tail.tail.head;
		if (child) {
			child.Resize(0, 0, width, height);
		} else {
		}
		return;
	} else {
	}
	if (h.event.head == Event::LeftDoubleClick || h.event.head == Event::RightDoubleClick) {
		grab = null;
	} else {
	}
	if (grab && Event::IsMouseEvent((integer)h.event.head)) {
		h.Target(grab, null);
		return;
	} else {
	}
	if (focus && Event::IsKeyEvent((integer)h.event.head)) {
	} else {
	}
	MonoGlyph::Pick(h);
}
end_body
member
public: void Damage(Glyph g, list poly);
body
{
	al_damage(wnd, poly);
}
end_body
member
public: void AbsDamage(Glyph g, list poly, matrix tm1);
body
{
	var matrix tm2;
	tm2 = al_translate_tm(tm1[0][2], tm1[1][2]);
	poly = al_transform_poly(tm2, poly);
	al_damage(wnd, poly);
}
end_body
member
public: void AllocationChanged(Glyph g);
body
{
}
end_body
member
public: Glyph last_hit_glyph;
member
public: matrix last_hit_tm;
member
public: Glyph last_hit_parent;
member
public: window wnd;
member
public: Glyph grab;
member
public: Glyph focus;
end_class
class TMGlyph
member
public: void Resize(integer l, integer t, integer r, integer b);
body
{
	Glyph::Resize(l, t, r, b);
	if (child) {
	} else {
		return;
	}
	var list xy;
	xy = al_inverse_xy(tm, l, t);
	l = xy.head;
	t = xy.tail.head;
	xy = al_inverse_xy(tm, r, b);
	r = xy.head;
	b = xy.tail.head;
	child.Resize(l, t, r, b);
}
end_body
member
public: void Move(integer dx, integer dy);
body
{
	left = left + dx;
	top = top + dy;
	right = right + dx;
	bottom = bottom + dy;
	if (tm) {
	} else {
		tm = al_unit_tm();
	}
	tm[0][2] = tm[0][2] + dx;
	tm[1][2] = tm[1][2] + dy;
}
end_body
member
public: void MoveControl(window w);
body
{
	al_push_tm(w, child_tm(w));
	MonoGlyph::MoveControl(w);
	al_pop_tm(w);
}
end_body
member
public: void Draw(window w);
body
{
	al_push_tm(w, child_tm(w));
	MonoGlyph::Draw(w);
	al_pop_tm(w);
}
end_body
member
public: void Pick(Hit h);
body
{
	var window w;
	w = h.wnd;
	al_push_tm(w, child_tm(w));
	MonoGlyph::Pick(h);
	al_pop_tm(w);
}
end_body
member
public: list HitTest(Hit h);
body
{
	var window w;
	w = h.wnd;
	var integer result;
	al_push_tm(w, child_tm(w));
	result = MonoGlyph::HitTest(h);
	al_pop_tm(w);
	return result;
}
end_body
member
public: void Damage(Glyph g, list poly);
body
{
	var list poly1;
	poly1 = poly;
	if (tm) {
		poly1 = al_transform_poly(tm, poly1);
	} else {
	}
	Glyph::Damage(this, poly1);
}
end_body
member
public: void AbsDamage(Glyph g, list poly, matrix tm1);
body
{
	var matrix tm2;
	if (tm) {
		tm2 = tm * tm1;
	} else {
		tm2 = tm1;
	}
	Glyph::AbsDamage(this, poly, tm2);
}
end_body
member
public: void AllocationChanged(Glyph g);
body
{
	MonoGlyph::AllocationChanged(g);
	var Glyph parent;
	parent = al_src_node(this, "child");
	parent.MakeSpaceIndex(this);
}
end_body
member
public: matrix tm;
member
public: void KnobDraw(window w);
body
{
	al_push_tm(w, child_tm(w));
	if (child) {
		child.KnobDraw(w);
	} else {
	}
	al_pop_tm(w);
}
end_body
member
public: void KnobPick(Hit h);
body
{
	var window w;
	w = h.wnd;
	al_push_tm(w, child_tm(w));
	if (child) {
		child.KnobPick(h);
	} else {
	}
	al_pop_tm(w);
}
end_body
member
public: matrix child_tm(window w);
body
{
	var matrix tm1, tm2;
	tm2 = tm;
	if (tm1 = al_window_tm(w)) {
		if (tm2) {
			tm2 = tm1 * tm2;
		} else {
			tm2 = tm1;
		}
	} else {
	}
	return tm2;
}
end_body
member
public: void Body(Glyph g);
body
{
	MonoGlyph::Body(g);
	if (g) {
		var list rect;
		rect = al_transform_rect(tm, g.left, g.top, g.left + g.Width(), g.top + g.Height());
		left = rect.head;
		top = rect.tail.head;
		right = rect.tail.tail.head;
		bottom = rect.tail.tail.tail.head;
	} else {
	}
}
end_body
member
public: void SetTM(matrix tm1);
body
{
	tm = tm1;
	if (child) {
		var list rect;
		rect = al_transform_rect(tm, child.left, child.top, child.right, child.bottom);
		left = rect.head;
		top = rect.tail.head;
		right = rect.tail.tail.head;
		bottom = rect.tail.tail.tail.head;
	} else {
		left = top = right = bottom = 0;
	}
}
end_body
class RightMenuGlyph
member
public: void Pick(Hit h);
body
{
	if (Glyph::HitTest(h)) {
		h.Target(this, TargetInfo::RBMenu);
		TMGlyph::Pick(h);
	} else {
	}
}
end_body
member
public: list Execute(Hit h);
body
{
	var integer type, modif, info;
	type = h.event.head;
	modif = h.event.tail.tail.tail.tail.head;
	info = h.info;
	if (type == Event::RightPress || type == Event::LeftPress && modif == 0x2) {
		if (info == TargetInfo::RBMenu && _Menu(h)) {
			return 1;
		} else {
		}
	} else {
	}
	return Glyph::Execute(h);
}
end_body
member
public: list _Menu(Hit h);
body
{
	if (menu) {
		menu.Execute(h.wnd, h.event);
		return 1;
	} else {
		return null;
	}
}
end_body
member
public: AlMenu menu;
class ScrollGlyph
member
public: void Resize(integer l, integer t, integer r, integer b);
body
{
	if (child) {
		child.Move(l - left, t - top);
	} else {
	}
	Glyph::Resize(l, t, r, b);
	Body(child);
}
end_body
member
public: void Draw(window w);
body
{
	var list poly2;
	poly2 = al_create_poly_poly();
	al_add_rect_to_poly(poly2, left, top, right, bottom);
	poly2 = al_transform_poly(al_window_tm(w), poly2);
	poly2 = al_intersection(al_clipping(w), poly2);
	al_push_clipping(w, poly2);
	TMGlyph::Draw(w);
	al_pop_clipping(w);
}
end_body
member
public: void Pick(Hit h);
body
{
	if (Glyph::HitTest(h)) {
	} else {
		return;
	}
	if (status == Status::Layout) {
		Glyph::Pick(h);
		return;
	} else {
	}
	if (status == Status::Execute) {
		RightMenuGlyph::Pick(h);
		return;
	} else {
	}
}
end_body
member
public: list HitTest(Hit h);
body
{
	if (status == Status::Layout) {
		return Glyph::HitTest(h);
	} else {
	}
	if (status == Status::Execute) {
		return MonoGlyph::HitTest(h);
	} else {
	}
	return null;
}
end_body
member
public: void KnobDraw(window w);
body
{
	if (status == Status::Layout) {
		Glyph::KnobDraw(w);
		return;
	} else {
	}
	if (status == Status::Execute) {
		TMGlyph::KnobDraw(w);
		return;
	} else {
	}
}
end_body
member
public: void KnobPick(Hit h);
body
{
	if (status == Status::Layout) {
		Glyph::KnobPick(h);
		return;
	} else {
	}
	if (status == Status::Execute) {
		TMGlyph::KnobPick(h);
		return;
	} else {
	}
}
end_body
member
public: void Damage(Glyph g, list poly);
body
{
	var list poly1, poly2;
	poly1 = al_transform_poly(tm, poly);
	poly2 = al_create_poly_poly();
	al_add_rect_to_poly(poly2, left, top, right, bottom);
	poly2 = al_intersection(poly1, poly2);
	Glyph::Damage(this, poly2);
}
end_body
member
public: void Body(Glyph g);
body
{
	child = g;
	if (g) {
		range_left = g.left;
		range_top = g.top;
		range_right = g.right;
		range_bottom = g.bottom;
		var list itr;
		itr = al_src_itr(this);
		var list scrolls;
		var AlScrollBar sbar;
		loop {
			if (scrolls = al_next_a(itr, "$scroll")) {
			} else {
				break;
			}
			if (sbar = al_src_node(scrolls, "scrolls")) {
				sbar.Adjust(this);
			} else {
			}
		}
	} else {
	}
}
end_body
member
public: void AllocationChanged(Glyph g);
body
{
	TMGlyph::AllocationChanged(this);
}
end_body
member
public: void VScroll(integer pos, integer max);
body
{
	if (tm) {
	} else {
		tm = al_unit_tm();
	}
	var real dy1, dy2;
	dy1 = top - tm[1][1] * range_top;
	dy2 = bottom - tm[1][1] * range_bottom;
	if (dy2 >= dy1) {
		return;
	} else {
	}
	tm[1][2] = (dy2 - dy1) * pos / max;
	Damage();
}
end_body
member
public: void HScroll(integer pos, integer max);
body
{
	if (tm) {
	} else {
		tm = al_unit_tm();
	}
	var real dx1, dx2;
	dx1 = left - tm[0][0] * range_left;
	dx2 = right - tm[0][0] * range_right;
	if (dx2 >= dx1) {
		return;
	} else {
	}
	tm[0][2] = (dx2 - dx1) * pos / max;
	Damage();
}
end_body
member
public: integer range_left;
member
public: integer range_top;
member
public: integer range_right;
member
public: integer range_bottom;
member
public: void public_var();
body
{
	child;
}
end_body
member
public: void SetVScrollBarPos(AlVScrollBar vbar, integer pos);
body
{
	if (tm) {
	} else {
		tm = al_unit_tm();
	}
	var real dy1, dy2;
	dy1 = top - tm[1][1] * range_top;
	dy2 = bottom - tm[1][1] * range_bottom;
	if (dy2 >= dy1) {
		return;
	} else {
	}
	tm[1][2] = pos;
	vbar.pos = pos * vbar.max / (dy2 - dy1);
}
end_body
member
public: void SetHScrollBarPos(AlHScrollBar hbar, integer pos);
body
{
	if (tm) {
	} else {
		tm = al_unit_tm();
	}
	var real dx1, dx2;
	dx1 = left - tm[0][0] * range_left;
	dx2 = right - tm[0][0] * range_right;
	if (dx2 >= dx1) {
		return;
	} else {
	}
	tm[0][2] = pos;
	hbar.pos = pos * hbar.max / (dx2 - dx1);
}
end_body
class FrameScrollGlyph
member
public: void Draw(window w);
body
{
	al_push_pen(w, "Null", 0, 0x0);
	al_push_brush(w, "Solid", al_get_sys_color(0), null);
	al_rectangle(w, left, top, right, bottom);
	al_pop_brush(w);
	al_pop_pen(w);
	ScrollGlyph::Draw(w);
	var integer width, color;
	if (al_get_sys_color(0) != 0x0) {
		width = 0;
		color = 0x0;
	} else {
		width = 2;
		color = 0xffffff;
	}
	al_push_pen(w, "Solid", width, color);
	al_push_brush(w, "Null", 0x0, null);
	al_rectangle(w, left, top, right, bottom);
	al_pop_brush(w);
	al_pop_pen(w);
}
end_body
member
public: list GbCode(list pif);
body
{
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var ScrollGlyph pp;"));
	err = (err || GbCode(pif, "pp = new FrameScrollGlyph;"));
	err = (err || GbCode(pif, "pp.Resize(" + GbGeom() + ");"));
	if (child) {
		err = (err || child.GbCode(pif));
		err = (err || GbCode(pif, "pp.Body(p);"));
	} else {
	}
	err = (err || GbCode(pif, "pp.status = Status::Execute;"));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
end_class
end_class
end_class
end_class
end_class
class PolyGlyph
member
public: void Resize(integer l, integer t, integer r, integer b);
body
{
	if (left && top) {
		var list itr;
		var Glyph g;
		itr = al_dst_itr(this);
		loop {
			if (g = al_next_a(itr, "child")) {
			} else {
				break;
			}
			g.Move(l - left, t - top);
		}
	} else {
	}
	Glyph::Resize(l, t, r, b);
}
end_body
member
public: void MoveControl(window w);
body
{
	var list itr;
	itr = al_dst_itr(this);
	var TMGlyph info;
	loop {
		if (info = al_next_a(itr, "child")) {
		} else {
			break;
		}
		info.MoveControl(w);
	}
}
end_body
member
public: void Draw(window w);
body
{
	var list itr;
	itr = al_dst_itr(this);
	var TMGlyph info;
	loop {
		if (info = al_next_a(itr, "child")) {
		} else {
			break;
		}
		info.Draw(w);
	}
}
end_body
member
public: void Pick(Hit h);
body
{
	var list itr;
	var TMGlyph info;
	itr = al_dst_itr(this);
	loop {
		if (info = al_next_a(itr, "child")) {
		} else {
			break;
		}
		info.Pick(h);
	}
}
end_body
member
public: void Destroy();
body
{
	var list itr;
	itr = al_dst_itr(this);
	var TMGlyph info;
	loop {
		if (info = al_next_a(itr, "child")) {
		} else {
			break;
		}
		info.Destroy();
	}
}
end_body
member
public: list HitTest(Hit h);
body
{
	var list itr;
	itr = al_dst_itr(this);
	var TMGlyph info;
	var integer result;
	loop {
		if (info = al_next_a(itr, "child")) {
		} else {
			break;
		}
		if (result = info.HitTest(h)) {
			return result;
		} else {
		}
	}
	return null;
}
end_body
member
public: void AllocatiionChanged(Glyph g);
body
{
}
end_body
member
public: void MakeSpaceIndex();
body
{
	return;
	// * var list itr;
	// * itr = al_dst_itr(this);
	// * var TMGlyph info;
	// * loop {
	// *     if (info = al_next_a(itr, "child")) {
	// *     } else {
	// *         break;
	// *     }
	// *     info.MakeSpaceIndex();
	// * }
}
end_body
member
public: void ClearSpaceIndex();
body
{
	var list itr;
	itr = al_dst_itr(this);
	var TMGlyph info;
	loop {
		if (info = al_next_a(itr, "child")) {
		} else {
			break;
		}
		info.ClearSpaceIndex();
	}
}
end_body
member
public: TMGlyph Prepend(Glyph g, integer x, integer y);
body
{
	var TMGlyph info;
	info = new TMGlyph;
	info.tm = al_translate_tm(x, y);
	info.Body(g);
	var list itr;
	itr = al_dst_itr(this);
	al_append(itr, info, "child");
	return info;
}
end_body
member
public: TMGlyph Append(Glyph g, integer x, integer y);
body
{
	var TMGlyph info;
	info = new TMGlyph;
	info.tm = al_translate_tm(x, y);
	info.Body(g);
	var list itr;
	itr = al_dst_itr(this);
	al_insert(itr, info, "child");
	return info;
}
end_body
member
public: list Remove(TMGlyph info);
body
{
	var list itr;
	var TMGlyph info2;
	itr = al_dst_itr(this);
	loop {
		if (info2 = al_next_a(itr, "child")) {
		} else {
			return null;
		}
		if (al_addr_eq(info2, info)) {
			al_remove(itr);
			return 1;
		} else {
		}
	}
}
end_body
member
public: void IndexPos(list itr, integer index);
body
{
	al_index_pos(itr, index, "child");
}
end_body
member
public: integer GlyphIndex(Glyph g);
body
{
	var list itr;
	itr = al_dst_itr(this);
	return GlyphIndex(itr, g);
}
end_body
member
public: integer GlyphIndex(list itr, Glyph g);
body
{
	return al_search(itr, g, "child");
}
end_body
member
public: integer Count();
body
{
	var list itr;
	var integer count;
	itr = al_dst_itr(this);
	count = 0;
	loop {
		if (al_next_a(itr, "child")) {
		} else {
			break;
		}
		count = count + 1;
	}
	return count;
}
end_body
member
public: Glyph Component(integer index);
body
{
	var list itr;
	itr = al_dst_itr(this);
	IndexPos(itr, index);
	return al_component(itr);
}
end_body
class SpIdxGlyph
member
public: static void Initialize();
body
{
	section_length = 100;
}
end_body
member
public: void Resize(integer l, integer t, integer r, integer b);
body
{
	PolyGlyph::Resize(l, t, r, b);
	MakeSpaceIndex();
}
end_body
member
public: void Pick(Hit h);
body
{
	PolyGlyph::Pick(h);
	return;
	// * if (Event::IsMouseEvent((integer)h.event.head)) {
	// *     var list area, itr;
	// *     var TMGlyph info;
	// *     if (area = SubSpace(h)) {
	// *         itr = al_src_itr(area);
	// *         loop {
	// *             if (info = al_next_a(itr, "$sp_idx")) {
	// *             } else {
	// *                 break;
	// *             }
	// *             info.Pick(h);
	// *         }
	// *     } else {
	// *     }
	// * } else {
	// *     PolyGlyph::Pick(h);
	// * }
}
end_body
member
public: void MakeSpaceIndex();
body
{
	return;
	// * var list itr;
	// * itr = al_dst_itr(this);
	// * var TMGlyph info;
	// * loop {
	// *     if (info = al_next_a(itr, "child")) {
	// *     } else {
	// *         break;
	// *     }
	// *     MakeSpaceIndex(info);
	// *     info.MakeSpaceIndex();
	// * }
}
end_body
member
public: void MakeSpaceIndex(TMGlyph info);
body
{
	return;
	// * var list itr, area, sp_idx2;
	// * if (space_index) {
	// * } else {
	// *     space_index = al_cons(null, null);
	// * }
	// * itr = al_dst_itr(info);
	// * loop {
	// *     if (area = al_next_a(itr, "$sp_idx")) {
	// *     } else {
	// *         break;
	// *     }
	// *     al_remove(itr);
	// * }
	// * var integer i, j, x1, y1, x2, y2;
	// * x1 = CoordToIndex(info.left - 10);
	// * y1 = CoordToIndex(info.top - 10);
	// * x2 = CoordToIndex(info.right + 10);
	// * y2 = CoordToIndex(info.bottom + 10);
	// * i = y1;
	// * loop {
	// *     if (i <= y2) {
	// *     } else {
	// *         break;
	// *     }
	// *     if (sp_idx2 = al_dst_node(space_index, i)) {
	// *     } else {
	// *         sp_idx2 = al_cons(null, null);
	// *         al_create_arc(space_index, sp_idx2, i);
	// *     }
	// *     j = x1;
	// *     loop {
	// *         if (j <= x2) {
	// *         } else {
	// *             break;
	// *         }
	// *         if (area = al_dst_node(sp_idx2, j)) {
	// *         } else {
	// *             area = al_cons(null, null);
	// *             al_create_arc(sp_idx2, area, j);
	// *         }
	// *         al_create_ordered_arc(info, area, "$sp_idx", this);
	// *         j = j + 1;
	// *     }
	// *     i = i + 1;
	// * }
}
end_body
member
public: void ClearSpaceIndex();
body
{
	var list itr, itr2, area;
	var TMGlyph info;
	itr = al_dst_itr(this);
	loop {
		if (info = al_next_a(itr, "child")) {
		} else {
			break;
		}
		itr2 = al_dst_itr(info);
		loop {
			if (area = al_next_a(itr2, "$sp_idx")) {
			} else {
				break;
			}
			al_remove(itr2);
		}
	}
	space_index = null;
	itr = al_dst_itr(this);
	var TMGlyph info;
	loop {
		if (info = al_next_a(itr, "child")) {
		} else {
			break;
		}
		info.ClearSpaceIndex();
	}
}
end_body
member
public: list SubSpace(Hit h);
body
{
	var list xy;
	var integer x, y;
	xy = al_inverse_xy(al_window_tm(h.wnd), h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	var integer x_idx, y_idx;
	x_idx = CoordToIndex(x);
	y_idx = CoordToIndex(y);
	return al_dst_node(al_dst_node(space_index, y_idx), x_idx);
}
end_body
member
public: integer CoordToIndex(integer x);
body
{
	return (integer)(x / section_length);
}
end_body
member
public: static integer section_length;
member
public: list space_index;
member
public: void AllocationChanged(Glyph g);
body
{
	allo_chg_glyph = g;
	Glyph::AllocationChanged(this);
}
end_body
member
public: Glyph allo_chg_glyph;
end_class
class FormGlyph
member
public: static void Initialize();
body
{
	Left = 0;
	Top = 1;
	Right = 2;
	Bottom = 3;
	ConnectScroll = 10;
}
end_body
member
public: void Resize(integer l, integer t, integer r, integer b);
body
{
	Glyph::Resize(l, t, r, b);
	var list itr, attach;
	var TMGlyph info;
	var integer what, opposite, offset;
	itr = al_dst_itr(attachment);
	loop {
		if (attach = al_next(itr)) {
		} else {
			break;
		}
		info = attach.head;
		what = attach.tail.head;
		opposite = attach.tail.tail.head;
		offset = attach.tail.tail.tail.head;
		if (what == Left) {
			if (opposite == 0) {
				info.left = l + offset;
			} else {
				info.left = r - offset;
			}
		} else {
		}
		if (what == Top) {
			if (opposite == 0) {
				info.top = t + offset;
			} else {
				info.top = b - offset;
			}
		} else {
		}
		if (what == Right) {
			if (opposite == 0) {
				info.right = r - offset;
			} else {
				info.right = l + offset;
			}
		} else {
		}
		if (what == Bottom) {
			if (opposite == 0) {
				info.bottom = b - offset;
			} else {
				info.bottom = t + offset;
			}
		} else {
		}
	}
	itr = al_dst_itr(this);
	loop {
		if (info = al_next_a(itr, "child")) {
		} else {
			break;
		}
		info.Resize(info.left, info.top, info.right, info.bottom);
	}
}
end_body
member
public: void Pick(Hit h);
body
{
	if (status == Status::Layout) {
		if (Glyph::HitTest(h)) {
			h.Target(this, null);
		} else {
		}
		return;
	} else {
	}
	PolyGlyph::Pick(h);
}
end_body
member
public: void Attach(TMGlyph info, integer what, integer opposite, integer offset);
body
{
	if (attachment) {
	} else {
		attachment = al_cons(null, null);
	}
	var list itr, attach;
	itr = al_dst_itr(attachment);
	loop {
		if (attach = al_next_a(itr, null)) {
		} else {
			break;
		}
		if (al_addr_eq(attach.head, info) && attach.tail.head == what) {
			al_remove(itr);
			break;
		} else {
		}
	}
	if (opposite == -1) {
		return;
	} else {
	}
	attach = al_list4(info, what, opposite, offset);
	al_create_arc(attachment, attach, null);
}
end_body
member
public: list attachment;
member
public: FrameScrollGlyph scroll;
member
public: AlVScrollBar vbar;
member
public: AlHScrollBar hbar;
member
public: static integer Left;
member
public: static integer Top;
member
public: static integer Right;
member
public: static integer Bottom;
member
public: static integer ConnectScroll;
member
public: static FormGlyph FormWithScroll(AlMenu menu, Glyph glyph);
body
{
	var FrameScrollGlyph scroll;
	scroll = new FrameScrollGlyph;
	scroll.Resize(0, 0, 200, 200);
	scroll.Body(glyph);
	scroll.menu = menu;
	scroll.status = Status::Execute;
	var AlVScrollBar vbar;
	vbar = new AlVScrollBar;
	vbar.Create(0, 0, 20, 200);
	vbar.status = Status::Execute;
	vbar.Connect(scroll);
	var AlHScrollBar hbar;
	hbar = new AlHScrollBar;
	hbar.Create(0, 0, 200, 20);
	hbar.status = Status::Execute;
	hbar.Connect(scroll);
	var FormGlyph form;
	form = new FormGlyph;
	form.scroll = scroll;
	form.vbar = vbar;
	form.hbar = hbar;
	form.Create();
	form.Resize(0, 0, 400, 400);
	var TMGlyph scroll_info, vbar_info, hbar_info;
	scroll_info = form.Append(scroll, 0, 0);
	vbar_info = form.Append(vbar, 0, 0);
	hbar_info = form.Append(hbar, 0, 0);
	form.Attach(scroll_info, Left, 0, 0);
	form.Attach(scroll_info, Top, 0, 0);
	form.Attach(scroll_info, Right, 0, 20);
	form.Attach(scroll_info, Bottom, 0, 20);
	form.Attach(vbar_info, Left, 1, 20);
	form.Attach(vbar_info, Top, 0, 0);
	form.Attach(vbar_info, Right, 0, 0);
	form.Attach(vbar_info, Bottom, 0, 20);
	form.Attach(hbar_info, Left, 0, 0);
	form.Attach(hbar_info, Top, 1, 20);
	form.Attach(hbar_info, Right, 0, 20);
	form.Attach(hbar_info, Bottom, 0, 0);
	return form;
}
end_body
member
public: void public_vfunc();
body
{
	Count();
	Component(0);
}
end_body
end_class
class HBoxGlyph
member
public: void Create(integer l, integer t, integer r, integer b);
body
{
	Glyph::Create();
	Glyph::Resize(l, t, r, b);
	selection = al_cons(null, null);
}
end_body
member
public: void Resize(integer l, integer t, integer r, integer b);
body
{
	Glyph::Resize(l, t, r, b);
}
end_body
member
public: void Draw(window w);
body
{
	if (al_is_damaged(w, al_window_tm(w), left, top, right + 1, bottom + 1)) {
	} else {
		return;
	}
	if (al_is_clipped(w, al_window_tm(w), left, top, right + 1, bottom + 1)) {
		return;
	} else {
	}
	al_push_tm(w, child_tm(w));
	PolyGlyph::Draw(w);
	var list itr;
	itr = al_dst_itr(selection);
	var TMGlyph info;
	al_push_color_func(w, 2);
	al_push_pen(w, "Null", 0, 0x0);
	al_push_brush(w, "Solid", 0xffffff, null);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		al_rectangle(w, info.left, info.top, info.right, info.bottom);
	}
	al_pop_brush(w);
	al_pop_pen(w);
	al_pop_color_func(w);
	al_pop_tm(w);
}
end_body
member
public: void Pick(Hit h);
body
{
	var window w;
	w = h.wnd;
	al_push_tm(w, child_tm(w));
	h.BeginTarget(this, null);
	PolyGlyph::Pick(h);
	h.EndTarget();
	al_pop_tm(w);
}
end_body
member
public: void Damage(Glyph g, list poly);
body
{
	var list poly1;
	var matrix tm1;
	poly1 = poly;
	tm1 = al_translate_tm(left, top);
	poly1 = al_transform_poly(tm1, poly1);
	Glyph::Damage(this, poly1);
}
end_body
member
public: list ExecuteParent(integer msg, Glyph g, Hit h);
body
{
	var list itr;
	var TMGlyph info, info1;
	var Glyph g1;
	info = al_src_node(g, "child");
	if (msg == Message::Select) {
		itr = al_dst_itr(selection);
		loop {
			if (info1 = al_next_a(itr, "$select")) {
			} else {
				break;
			}
			info1.Damage();
		}
		selection = al_cons(null, null);
		al_create_arc(selection, info, "$select");
		info.Damage();
		itr = al_src_itr(this);
		loop {
			if (g1 = al_next_a(itr, "$selector")) {
			} else {
				break;
			}
			g1.ExecuteParent(Message::SelectItem, this, h);
		}
		return 1;
	} else {
	}
	if (msg == Message::XorSelect) {
		itr = al_dst_itr(selection);
		loop {
			if (info1 = al_next_a(itr, "$select")) {
			} else {
				al_append(itr, info, "$select");
				break;
			}
			if (al_addr_eq(info1, info)) {
				al_remove(itr);
				break;
			} else {
			}
		}
		info.Damage();
		return 1;
	} else {
	}
	return null;
}
end_body
member
public: list selection;
member
public: void Insert(integer index, Glyph g);
body
{
	var list ret;
	var integer x, height;
	ret = _Insert(index, g);
	x = ret.head;
	height = ret.tail.head;
	Glyph::Resize(left, top, left + x, top + height);
}
end_body
member
public: list _Insert(integer index, Glyph g);
body
{
	var list itr;
	itr = al_dst_itr(this);
	IndexPos(itr, index);
	var TMGlyph info, info1;
	var integer x, width, height;
	g.Move( - g.left,  - g.top);
	height = g.Height();
	if (info1 = al_component(itr)) {
		x = info1.left;
	} else {
		x = Width();
	}
	info = new TMGlyph;
	info.Body(g);
	info.Move(x, 0);
	al_insert(itr, info, "child");
	height = al_max(height, Height());
	width = info.Width();
	x = x + width;
	loop {
		if (info1 = al_component(itr)) {
		} else {
			break;
		}
		info1.Move(width, 0);
		x = x + info1.Width();
		al_next_a(itr, "child");
	}
	return al_list2(x, height);
}
end_body
member
public: void Remove(integer index);
body
{
	var list itr;
	itr = al_dst_itr(this);
	IndexPos(itr, index);
	var TMGlyph info, info1;
	var integer x, width;
	if (info1 = al_component(itr)) {
	} else {
		return;
	}
	selection = al_cons(null, null);
	width = info1.Width();
	x = info1.left;
	al_remove(itr);
	loop {
		if (info1 = al_next_a(itr, "child")) {
		} else {
			break;
		}
		info1.Move( - width, 0);
		x = x + info1.Width();
	}
	Glyph::Resize(left, top, left + x, bottom);
}
end_body
member
public: void AppendItem(string s);
body
{
	var StaticLabel label;
	label = new StaticLabel;
	label.Create(0, 0, 500, 18, s);
	var list ret;
	var integer x;
	ret = _Insert(Count(), label);
	x = ret.head;
	Glyph::Resize(left, top, left + x, bottom);
}
end_body
member
public: void Clear();
body
{
	var list itr;
	itr = al_dst_itr(this);
	var TMGlyph info;
	loop {
		if (info = al_next_a(itr, "child")) {
		} else {
			break;
		}
		al_remove(itr);
	}
	Glyph::Resize(left, top, left, bottom);
}
end_body
member
public: void _AllocationChanged(Glyph g);
body
{
	var integer index;
	var list itr;
	itr = al_dst_itr(this);
	index = GlyphIndex(itr, g);
	Remove(index);
	Insert(index, g);
}
end_body
member
public: void AllocationChanged(Glyph g);
body
{
	Damage();
	_AllocationChanged(g);
	Glyph::AllocationChanged(this);
	Damage();
}
end_body
member
public: void AllocationChanged();
body
{
	Glyph::AllocationChanged(this);
}
end_body
class HBoxGlyph2
member
public: void Draw(window w);
body
{
	var list poly;
	poly = al_create_poly_poly();
	al_add_rect_to_poly(poly, left, top, right, bottom);
	poly = al_transform_poly(al_window_tm(w), poly);
	al_push_clipping(w, al_intersection(al_clipping(w), poly));
	al_pop_tm(w);
	HBoxGlyph2::Draw(w);
	al_pop_clipping(w);
}
end_body
member
public: void Pick(Hit h);
body
{
	if (HitTest(h)) {
	} else {
		return;
	}
	HBoxGlyph::Pick(h);
}
end_body
end_class
end_class
class VBoxGlyph
member
public: void Create(integer l, integer t, integer r, integer b);
body
{
	Glyph::Create();
	Glyph::Resize(l, t, r, b);
	selection = al_cons(null, null);
}
end_body
member
public: void Resize(integer l, integer t, integer r, integer b);
body
{
	Glyph::Resize(l, t, r, b);
}
end_body
member
public: void Draw(window w);
body
{
	if (al_is_damaged(w, al_window_tm(w), left, top, right + 1, bottom + 1)) {
	} else {
		return;
	}
	if (al_is_clipped(w, al_window_tm(w), left, top, right + 1, bottom + 1)) {
		return;
	} else {
	}
	al_push_tm(w, child_tm(w));
	PolyGlyph::Draw(w);
	var list itr;
	itr = al_dst_itr(selection);
	var TMGlyph info;
	al_push_color_func(w, 2);
	al_push_pen(w, "Null", 0, 0x0);
	al_push_brush(w, "Solid", 0xffffff, null);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		al_rectangle(w, info.left, info.top, info.right, info.bottom);
	}
	al_pop_brush(w);
	al_pop_pen(w);
	al_pop_color_func(w);
	al_pop_tm(w);
}
end_body
member
public: void Pick(Hit h);
body
{
	var window w;
	w = h.wnd;
	al_push_tm(w, child_tm(w));
	h.BeginTarget(this, null);
	PolyGlyph::Pick(h);
	h.EndTarget();
	al_pop_tm(w);
}
end_body
member
public: void Damage(Glyph g, list poly);
body
{
	var list poly1;
	var matrix tm1;
	poly1 = poly;
	tm1 = al_translate_tm(left, top);
	poly1 = al_transform_poly(tm1, poly1);
	Glyph::Damage(this, poly1);
}
end_body
member
public: list ExecuteParent(integer msg, Glyph g, Hit h);
body
{
	var list itr;
	var TMGlyph info, info1;
	var Glyph g1;
	info = al_src_node(g, "child");
	if (msg == Message::Select) {
		itr = al_dst_itr(selection);
		loop {
			if (info1 = al_next_a(itr, "$select")) {
			} else {
				break;
			}
			info1.Damage();
		}
		selection = al_cons(null, null);
		al_create_arc(selection, info, "$select");
		info.Damage();
		itr = al_src_itr(this);
		loop {
			if (g1 = al_next_a(itr, "$selector")) {
			} else {
				break;
			}
			g1.ExecuteParent(Message::SelectItem, this, h);
		}
		return 1;
	} else {
	}
	if (msg == Message::XorSelect) {
		itr = al_dst_itr(selection);
		loop {
			if (info1 = al_next_a(itr, "$select")) {
			} else {
				al_append(itr, info, "$select");
				break;
			}
			if (al_addr_eq(info1, info)) {
				al_remove(itr);
				break;
			} else {
			}
		}
		info.Damage();
		return 1;
	} else {
	}
	return null;
}
end_body
member
public: list selection;
member
public: void Insert(integer index, Glyph g);
body
{
	var list ret;
	var integer y, width;
	ret = _Insert(index, g);
	y = ret.head;
	width = ret.tail.head;
	Glyph::Resize(left, top, left + width, top + y);
}
end_body
member
public: list _Insert(integer index, Glyph g);
body
{
	var list itr;
	itr = al_dst_itr(this);
	IndexPos(itr, index);
	var TMGlyph info, info1;
	var integer y, width, height;
	g.Move( - g.left,  - g.top);
	width = g.Width();
	if (info1 = al_component(itr)) {
		y = info1.top;
	} else {
		y = Height();
	}
	info = new TMGlyph;
	info.Body(g);
	info.Move(0, y);
	al_insert(itr, info, "child");
	width = al_max(width, Width());
	height = info.Height();
	y = y + height;
	loop {
		if (info1 = al_component(itr)) {
		} else {
			break;
		}
		info1.Move(0, height);
		y = y + info1.Height();
		al_next_a(itr, "child");
	}
	return al_list2(y, width);
}
end_body
member
public: void Remove(integer index);
body
{
	var list itr;
	itr = al_dst_itr(this);
	IndexPos(itr, index);
	var TMGlyph info, info1;
	var integer y, height;
	if (info1 = al_component(itr)) {
	} else {
		return;
	}
	selection = al_cons(null, null);
	height = info1.Height();
	y = info1.top;
	al_remove(itr);
	loop {
		if (info1 = al_next_a(itr, "child")) {
		} else {
			break;
		}
		info1.Move(0,  - height);
		y = y + info1.Height();
	}
	Glyph::Resize(left, top, right, top + y);
}
end_body
member
public: void AppendItem(string s);
body
{
	var StaticLabel label;
	label = new StaticLabel;
	label.Create(0, 0, 500, 18, s);
	var list ret;
	var integer y;
	ret = _Insert(Count(), label);
	y = ret.head;
	Glyph::Resize(left, top, right, top + y);
}
end_body
member
public: void Clear();
body
{
	var list itr;
	itr = al_dst_itr(this);
	var TMGlyph info;
	loop {
		if (info = al_next_a(itr, "child")) {
		} else {
			break;
		}
		al_remove(itr);
	}
	Glyph::Resize(left, top, right, top);
}
end_body
member
public: void _AllocationChanged(Glyph g);
body
{
	var integer index;
	var list itr;
	itr = al_dst_itr(this);
	index = GlyphIndex(itr, g);
	Remove(index);
	Insert(index, g);
}
end_body
member
public: void AllocationChanged(Glyph g);
body
{
	Damage();
	_AllocationChanged(g);
	Glyph::AllocationChanged(this);
	Damage();
}
end_body
member
public: void AllocationChanged();
body
{
	Glyph::AllocationChanged(this);
}
end_body
class VBoxGlyph2
member
public: void Draw(window w);
body
{
	var list poly;
	poly = al_create_poly_poly();
	al_add_rect_to_poly(poly, left, top, right, bottom);
	poly = al_transform_poly(al_window_tm(w), poly);
	al_push_clipping(w, al_intersection(al_clipping(w), poly));
	VBoxGlyph::Draw(w);
	al_pop_clipping(w);
}
end_body
member
public: void Pick(Hit h);
body
{
	if (HitTest(h)) {
	} else {
		return;
	}
	VBoxGlyph::Pick(h);
}
end_body
end_class
end_class
class PatchGlyph
member
public: void Resize(integer l, integer t, integer r, integer b);
body
{
	Glyph::Resize(l, t, r, b);
	if (curr_index) {
	} else {
		return;
	}
	CurrentIndex(curr_index);
}
end_body
member
public: void Draw(window w);
body
{
	if (curr_index && curr_index < Count()) {
	} else {
		return;
	}
	var TMGlyph info;
	info = Component(curr_index);
	info.Draw(w);
}
end_body
member
public: void Pick(Hit h);
body
{
	if (curr_index && curr_index < Count()) {
	} else {
		return;
	}
	var TMGlyph info;
	info = Component(curr_index);
	info.Pick(h);
}
end_body
member
public: integer CurrentIndex();
body
{
	return curr_index;
}
end_body
member
public: void CurrentIndex(integer index);
body
{
	if (index >= Count()) {
		return;
	} else {
	}
	curr_index = index;
	var TMGlyph info;
	info = Component(curr_index);
	info.Resize(left, top, right, bottom);
	info.Damage();
}
end_body
member
public: integer curr_index;
end_class
class PictureGlyph
member
public: void Create();
body
{
	Glyph::Create();
	left = 1.e+030;
	top = 1.e+030;
	right = -1.e+030;
	bottom = -1.e+030;
}
end_body
member
public: void Pick(Hit h);
body
{
	Glyph::Pick(h);
}
end_body
member
public: TMGlyph Prepend(Glyph g, integer x, integer y);
body
{
	var TMGlyph info;
	info = PolyGlyph::Prepend(g, x, y);
	left = al_min(left, info.left);
	top = al_min(top, info.top);
	right = al_max(right, info.right);
	bottom = al_max(bottom, info.bottom);
	Glyph::AllocationChanged(this);
	return info;
}
end_body
member
public: TMGlyph Append(Glyph g, integer x, integer y);
body
{
	var TMGlyph info;
	info = PolyGlyph::Append(g, x, y);
	left = al_min(left, info.left);
	top = al_min(top, info.top);
	right = al_max(right, info.right);
	bottom = al_max(bottom, info.bottom);
	Glyph::AllocationChanged(this);
	return info;
}
end_body
member
public: void Remove(TMGlyph info);
body
{
	PolyGlyph::Remove(info);
	left = 1.e+030;
	top = 1.e+030;
	right = -1.e+030;
	bottom = -1.e+030;
	var list itr;
	itr = al_dst_itr(this);
	var TMGlyph info;
	loop {
		if (info = al_next_a(itr, "child")) {
		} else {
			break;
		}
		left = al_min(left, info.left);
		top = al_min(top, info.top);
		right = al_max(right, info.right);
		bottom = al_max(bottom, info.bottom);
	}
	Glyph::AllocationChanged(this);
}
end_body
end_class
end_class
class PrimitiveGlyph
member
public: string line_style;
member
public: integer line_width;
member
public: integer line_color;
member
public: string fill_style;
member
public: integer fill_color;
member
public: string fill_pattern;
member
public: string font_name;
member
public: integer font_height;
member
public: integer font_width;
member
public: integer font_color;
member
public: list GbAttr(list pif);
body
{
	var list err;
	if (line_style) {
		err = (err || GbCode(pif, "pp.line_style = \"" + (string)line_style + "\";"));
		err = (err || GbCode(pif, "pp.line_width = " + (string)line_width + ";"));
		err = (err || GbCode(pif, "pp.line_color = " + (string)line_color + ";"));
	} else {
	}
	if (fill_style) {
		err = (err || GbCode(pif, "pp.fill_style = \"" + (string)fill_style + "\";"));
		err = (err || GbCode(pif, "pp.fill_color = " + (string)fill_color + ";"));
		err = (err || GbCode(pif, "pp.fill_pattern = " + (string)fill_pattern + ";"));
	} else {
	}
	if (font_name) {
		err = (err || GbCode(pif, "pp.font_name = \"" + (string)font_name + "\";"));
		err = (err || GbCode(pif, "pp.font_height =" + (string)font_height + ";"));
		err = (err || GbCode(pif, "pp.font_width = " + (string)font_width + ";"));
		err = (err || GbCode(pif, "pp.font_color = " + (string)font_color + ";"));
	} else {
	}
	return err;
}
end_body
member
public: void public_var();
body
{
	line_style;
	line_width;
	line_color;
	fill_style;
	fill_color;
	fill_pattern;
	font_name;
	font_height;
	font_width;
	font_color;
}
end_body
member
public: void Damage();
body
{
	var list poly;
	poly = al_create_poly_poly();
	var integer w;
	w = (line_width ? line_width / 2 : 0);
	al_add_rect_to_poly(poly, left - w, top - w, right + w + 1, bottom + w + 1);
	Glyph::Damage(this, poly);
}
end_body
member
public: list HitTest(Hit h);
body
{
	if (Event::IsMouseEvent((integer)h.event.head)) {
	} else {
		return null;
	}
	var list xy;
	var integer x, y;
	xy = al_inverse_xy(al_window_tm(h.wnd), h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	var integer w;
	w = (line_width ? line_width / 2 : 0);
	if (left - w <= x && x <= right + w && top - w <= y && y <= bottom + w) {
		return 1;
	} else {
		return null;
	}
}
end_body
class LineGlyph
member
public: void Create(integer x1, integer y1, integer x2, integer y2);
body
{
	Glyph::Create();
	_x1 = x1;
	_y1 = y1;
	_x2 = x2;
	_y2 = y2;
	left = al_min(x1, x2);
	top = al_min(y1, y2);
	right = al_max(x1, x2);
	bottom = al_max(y1, y2);
	line_style = "Solid";
	line_width = 0;
	line_color = 0x0;
}
end_body
member
public: void Draw(window w);
body
{
	if (al_is_damaged(w, al_window_tm(w), left, top, right + 1, bottom + 1)) {
	} else {
		return;
	}
	var integer color;
	if (al_get_sys_color(0) != line_color) {
		color = line_color;
	} else {
		color =  ~ line_color & 0xffffff;
	}
	al_push_pen(w, line_style, line_width, color);
	al_line(w, _x1, _y1, _x2, _y2);
	al_pop_pen(w);
}
end_body
member
public: list HitTest(Hit h);
body
{
	if (Event::IsMouseEvent((integer)h.event.head)) {
	} else {
		return null;
	}
	var list xy;
	var integer x, y;
	xy = al_inverse_xy(al_window_tm(h.wnd), h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	if (left <= x && x <= right && top <= y && y <= bottom) {
	} else {
		return null;
	}
	return HitTest(_x1, _y1, _x2, _y2, x, y);
}
end_body
member
public: static list HitTest(integer x1, integer y1, integer x2, integer y2, integer x0, integer y0);
body
{
	if (x1 == x2 && y1 == y2) {
		return x1 == x0 && y1 == y0;
	} else {
	}
	var real x21, y21, x01, y01, x02, y02;
	x21 = x2 - x1;
	y21 = y2 - y1;
	x01 = x0 - x1;
	y01 = y0 - y1;
	x02 = x0 - x2;
	y02 = y0 - y2;
	if (al_abs(x21) > al_abs(y21)) {
		x1 = x1 - y01 * y21 / x21;
		x2 = x2 - y02 * y21 / x21;
		if ((x0 - x1) * (x0 - x2) > 0) {
			return null;
		} else {
		}
	} else {
		y1 = y1 - x01 * x21 / y21;
		y2 = y2 - x02 * x21 / y21;
		if ((y0 - y1) * (y0 - y2) > 0) {
			return null;
		} else {
		}
	}
	if (al_abs(x21 * y01 - y21 * x01) / al_sqrt(x21 * x21 + y21 * y21) > 4) {
		return null;
	} else {
		return 1;
	}
}
end_body
member
public: integer _x1;
member
public: integer _y1;
member
public: integer _x2;
member
public: integer _y2;
member
public: list Execute(Hit h);
body
{
	var integer type, modif, info;
	type = h.event.head;
	modif = h.event.tail.tail.tail.tail.head;
	info = h.info;
	if (type == Event::LeftPress && modif != 0x2) {
		if (info == TargetInfo::FromKnob && status == Status::Layout && _BeginFromKnob(h)) {
			status = Status::FromKnob;
			return 1;
		} else {
		}
		if (info == TargetInfo::ToKnob && status == Status::Layout && _BeginToKnob(h)) {
			status = Status::ToKnob;
			return 1;
		} else {
		}
	} else {
	}
	if (type == Event::MouseMove) {
		if (status == Status::FromKnob && _FromKnob(h)) {
			return 1;
		} else {
		}
		if (status == Status::ToKnob && _ToKnob(h)) {
			return 1;
		} else {
		}
	} else {
	}
	if (type == Event::LeftRelease) {
		if (status == Status::FromKnob && _EndFromKnob(h)) {
			status = Status::Layout;
			return 1;
		} else {
		}
		if (status == Status::ToKnob && _EndToKnob(h)) {
			status = Status::Layout;
			return 1;
		} else {
		}
	} else {
	}
	return Glyph::Execute(h);
}
end_body
member
public: void KnobDraw(window w);
body
{
	var matrix tm;
	var integer sx, sy;
	if (tm = al_window_tm(w)) {
		sx = 3 / tm[0][0];
		sy = 3 / tm[1][1];
	} else {
		sx = 3;
		sy = 3;
	}
	al_rectangle(w, _x1 - sx, _y1 - sy, _x1 + sx, _y1 + sy);
	al_rectangle(w, _x2 - sx, _y2 - sy, _x2 + sx, _y2 + sy);
}
end_body
member
public: void KnobPick(Hit h);
body
{
	if (Event::IsMouseEvent((integer)h.event.head)) {
	} else {
		return;
	}
	var integer x, y;
	var matrix tm1;
	if (tm1 = al_window_tm(h.wnd)) {
		var list xy;
		xy = al_inverse_xy(tm1, h.event.tail.head, h.event.tail.tail.head);
		x = xy.head;
		y = xy.tail.head;
	} else {
		x = h.event.tail.head;
		y = h.event.tail.tail.head;
	}
	var integer sx, sy;
	if (tm1) {
		sx = 3 / tm1[0][0];
		sy = 3 / tm1[1][1];
	} else {
		sx = 3;
		sy = 3;
	}
	if (al_abs(x - _x1) < sx && al_abs(y - _y1) < sy) {
		h.Target(this, TargetInfo::FromKnob);
		return;
	} else {
	}
	if (al_abs(x - _x2) < sx && al_abs(y - _y2) < sy) {
		h.Target(this, TargetInfo::ToKnob);
		return;
	} else {
	}
}
end_body
member
public: void KnobDamage();
body
{
	var list poly;
	var matrix tm;
	poly = al_create_poly_poly();
	al_add_rect_to_poly(poly, -3, -3, 3, 3);
	tm = al_translate_tm(_x1, _y1);
	Glyph::AbsDamage(this, poly, tm);
	tm = al_translate_tm(_x2, _y2);
	Glyph::AbsDamage(this, poly, tm);
}
end_body
member
public: list _BeginFromKnob(Hit h);
body
{
	h.root.grab = this;
	_tm = h.tm;
	var list xy;
	xy = al_inverse_xy(_tm, h.event.tail.head, h.event.tail.tail.head);
	_x0 = xy.head;
	_y0 = xy.tail.head;
	DrawRBand(h.wnd, _tm, _x0, _y0, _x2, _y2);
	return 1;
}
end_body
member
public: list _BeginToKnob(Hit h);
body
{
	h.root.grab = this;
	_tm = h.tm;
	var list xy;
	xy = al_inverse_xy(_tm, h.event.tail.head, h.event.tail.tail.head);
	_x0 = xy.head;
	_y0 = xy.tail.head;
	DrawRBand(h.wnd, _tm, _x1, _y1, _x0, _y0);
	return 1;
}
end_body
member
public: list _FromKnob(Hit h);
body
{
	var list xy;
	DrawRBand(h.wnd, _tm, _x0, _y0, _x2, _y2);
	xy = al_inverse_xy(_tm, h.event.tail.head, h.event.tail.tail.head);
	_x0 = xy.head;
	_y0 = xy.tail.head;
	DrawRBand(h.wnd, _tm, _x0, _y0, _x2, _y2);
	return 1;
}
end_body
member
public: list _ToKnob(Hit h);
body
{
	var list xy;
	DrawRBand(h.wnd, _tm, _x1, _y1, _x0, _y0);
	xy = al_inverse_xy(_tm, h.event.tail.head, h.event.tail.tail.head);
	_x0 = xy.head;
	_y0 = xy.tail.head;
	DrawRBand(h.wnd, _tm, _x1, _y1, _x0, _y0);
	return 1;
}
end_body
member
public: list _EndFromKnob(Hit h);
body
{
	DrawRBand(h.wnd, _tm, _x0, _y0, _x2, _y2);
	h.root.grab = null;
	Damage();
	KnobDamage();
	_x1 = _x0;
	_y1 = _y0;
	var integer l, t, r, b;
	l = al_min(_x1, _x2);
	t = al_min(_y1, _y2);
	r = al_max(_x1, _x2);
	b = al_max(_y1, _y2);
	Resize(l, t, r, b);
	AllocationChanged(this);
	Damage();
	KnobDamage();
	_tm = null;
	_x0 = null;
	_y0 = null;
	return 1;
}
end_body
member
public: list _EndToKnob(Hit h);
body
{
	DrawRBand(h.wnd, _tm, _x1, _y1, _x0, _y0);
	h.root.grab = null;
	Damage();
	KnobDamage();
	_x2 = _x0;
	_y2 = _y0;
	var integer l, t, r, b;
	l = al_min(_x1, _x2);
	t = al_min(_y1, _y2);
	r = al_max(_x1, _x2);
	b = al_max(_y1, _y2);
	Resize(l, t, r, b);
	AllocationChanged(this);
	Damage();
	KnobDamage();
	_tm = null;
	_x0 = null;
	_y0 = null;
	return 1;
}
end_body
member
public: void DrawRBand(window w, matrix tm, integer x1, integer y1, integer x2, integer y2);
body
{
	al_start_quick_draw(w);
	al_push_pen(w, "Solid", 0, 0xffffff);
	al_push_brush(w, "Null", 0x0, null);
	al_push_color_func(w, 2);
	al_push_tm(w, tm);
	al_line(w, x1, y1, x2, y2);
	al_pop_tm(w);
	al_pop_color_func(w);
	al_pop_brush(w);
	al_pop_pen(w);
	al_end_quick_draw(w);
}
end_body
member
public: list GbCode(list pif);
body
{
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var LineGlyph pp;"));
	err = (err || GbCode(pif, "pp = new LineGlyph;"));
	err = (err || GbCode(pif, "pp.Create(" + (string)_x1 + ", " + (string)_y1 + ", " + (string)_x2 + ", " + (string)_y2 + ");"));
	err = (err || GbAttr(pif));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
class ArrowLine
member
public: void Draw(window w);
body
{
	if (al_is_damaged(w, al_window_tm(w), left, top, right + 1, bottom + 1)) {
	} else {
		return;
	}
	var integer dx, dy, l, xx1, yy1, xx2, yy2;
	dx = _x2 - _x1;
	dy = _y2 - _y1;
	l = al_sqrt(dx * dx + dy * dy);
	dx = dx / l;
	dy = dy / l;
	xx1 = _x2 - 10 * (dx + dy / 2);
	yy1 = _y2 - 10 * (dy - dx / 2);
	xx2 = _x2 - 10 * (dx - dy / 2);
	yy2 = _y2 - 10 * (dy + dx / 2);
	var integer color;
	if (al_get_sys_color(0) != line_color) {
		color = line_color;
	} else {
		color =  ~ line_color & 0xffffff;
	}
	al_push_pen(w, line_style, line_width, color);
	al_line(w, _x1, _y1, _x2, _y2);
	al_line(w, _x2, _y2, xx1, yy1);
	al_line(w, _x2, _y2, xx2, yy2);
	al_pop_pen(w);
}
end_body
member
public: void Damage();
body
{
	Glyph::Damage();
	Glyph::Damage(_x2 - 10, _y2 - 10, _x2 + 10, _y2 + 10);
}
end_body
member
public: list GbCode(list pif);
body
{
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var ArrowLine pp;"));
	err = (err || GbCode(pif, "pp = new ArrowLine;"));
	err = (err || GbCode(pif, "pp.Create(" + (string)_x1 + ", " + (string)_y1 + ", " + (string)_x2 + ", " + (string)_y2 + ");"));
	err = (err || GbAttr(pif));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
end_class
end_class
class RectangleGlyph
member
public: void Create(integer l, integer t, integer r, integer b);
body
{
	Glyph::Create();
	Glyph::Resize(l, t, r, b);
	line_style = "Solid";
	line_width = 0;
	line_color = 0x0;
	fill_style = "Solid";
	fill_color = 0xffffff;
	fill_pattern = null;
}
end_body
member
public: void Draw(window w);
body
{
	if (al_is_damaged(w, al_window_tm(w), left, top, right + 1, bottom + 1)) {
	} else {
		return;
	}
	var integer color;
	if (al_get_sys_color(0) != line_color) {
		color = line_color;
	} else {
		color =  ~ line_color & 0xffffff;
	}
	al_push_pen(w, line_style, line_width, color);
	if (al_get_sys_color(0) != 0x0) {
		color = fill_color;
	} else {
		if (fill_color == 0xffffff) {
			color = 0x0;
		} else {
			color = fill_color;
		}
	}
	al_push_brush(w, fill_style, color, fill_pattern);
	al_rectangle(w, left, top, right, bottom);
	al_pop_brush(w);
	al_pop_pen(w);
}
end_body
member
public: list GbCode(list pif);
body
{
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var RectangleGlyph pp;"));
	err = (err || GbCode(pif, "pp = new  RectangleGlyph;"));
	err = (err || GbCode(pif, "pp.Create(" + GbGeom() + ");"));
	err = (err || GbAttr(pif));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
end_class
class EllipseGlyph
member
public: void Create(integer l, integer t, integer r, integer b);
body
{
	Glyph::Create();
	Glyph::Resize(l, t, r, b);
	line_style = "Solid";
	line_width = 0;
	line_color = 0x0;
	fill_style = "Solid";
	fill_color = 0xffffff;
	fill_pattern = null;
}
end_body
member
public: void Draw(window w);
body
{
	if (al_is_damaged(w, al_window_tm(w), left, top, right + 1, bottom + 1)) {
	} else {
		return;
	}
	var integer color;
	if (al_get_sys_color(0) != line_color) {
		color = line_color;
	} else {
		color =  ~ line_color & 0xffffff;
	}
	al_push_pen(w, line_style, line_width, color);
	if (al_get_sys_color(0) != 0x0) {
		color = fill_color;
	} else {
		if (fill_color == 0xffffff) {
			color = 0x0;
		} else {
			color = fill_color;
		}
	}
	al_push_brush(w, fill_style, color, fill_pattern);
	al_ellipse(w, left, top, right, bottom);
	al_pop_brush(w);
	al_pop_pen(w);
}
end_body
member
public: list HitTest(Hit h);
body
{
	if (Event::IsMouseEvent((integer)h.event.head)) {
	} else {
		return null;
	}
	var list xy;
	var real x, y;
	xy = al_inverse_xy(al_window_tm(h.wnd), h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	var integer w;
	w = (line_width ? line_width / 2 : 0);
	if (left - w <= x && x <= right + w && top - w <= y && y <= bottom + w) {
	} else {
		return null;
	}
	var real rx, ry;
	rx = (right - left) / 2;
	ry = (bottom - top) / 2;
	x = x - rx;
	y = y - ry;
	rx = rx + w;
	ry = ry + w;
	if (x * x * ry * ry + y * y * rx * rx <= rx * rx * ry * ry) {
		return 1;
	} else {
		return null;
	}
}
end_body
member
public: list GbCode(list pif);
body
{
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var EllipseGlyph pp;"));
	err = (err || GbCode(pif, "pp = new  EllipseGlyph;"));
	err = (err || GbCode(pif, "pp.Create(" + GbGeom() + ");"));
	err = (err || GbAttr(pif));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
end_class
class PieGlyph
member
public: void Create(integer l, integer t, integer r, integer b, integer sx, integer sy, integer ex, integer ey);
body
{
	Glyph::Create();
	Glyph::Resize(l, t, r, b);
	line_style = "Solid";
	line_width = 0;
	line_color = 0x0;
	fill_style = "Solid";
	fill_color = 0xffffff;
	fill_pattern = null;
	start_x = sx;
	start_y = sy;
	end_x = ex;
	end_y = ey;
}
end_body
member
public: void Draw(window w);
body
{
	if (al_is_damaged(w, al_window_tm(w), left, top, right + 1, bottom + 1)) {
	} else {
		return;
	}
	var integer color;
	if (al_get_sys_color(0) != line_color) {
		color = line_color;
	} else {
		color =  ~ line_color & 0xffffff;
	}
	al_push_pen(w, line_style, line_width, color);
	if (al_get_sys_color(0) != 0x0) {
		color = fill_color;
	} else {
		if (fill_color == 0xffffff) {
			color = 0x0;
		} else {
			color = fill_color;
		}
	}
	al_push_brush(w, fill_style, color, fill_pattern);
	al_pie(w, left, top, right, bottom, start_x, start_y, end_x, end_y);
	al_pop_brush(w);
	al_pop_pen(w);
}
end_body
member
public: list HitTest(Hit h);
body
{
	return EllipseGlyph::HitTest(h);
}
end_body
member
public: integer start_x;
member
public: integer start_y;
member
public: integer end_x;
member
public: integer end_y;
end_class
class LabelGlyph
member
public: void Create(integer l, integer t, integer r, integer b, string s);
body
{
	Glyph::Create();
	Glyph::Resize(l, t, r, b);
	text = s;
	if (al_misc("platform", null, null) == "windows") {
		font_name = "lr SVbN";
	} else {
	}
	if (al_misc("platform", null, null) == "linux" || al_misc("platform", null, null) == "mac") {
		font_name = "-*-*-medium-r-normal-*-14-*-*-*-*-*-*-*,*";
	} else {
	}
	font_height = 12;
	font_width = 0;
	font_color = 0x0;
	top_margin = 2;
	left_margin = 2;
}
end_body
member
public: void Draw(window w);
body
{
	var matrix tm1;
	tm1 = al_window_tm(w);
	if (al_is_damaged(w, tm1, left, top, right + 1, bottom + 1)) {
	} else {
		return;
	}
	var integer color;
	if (al_get_sys_color(0) != font_color) {
		color = font_color;
	} else {
		color =  ~ font_color & 0xffffff;
	}
	al_push_font(w, font_name, font_height, font_width, color);
	var list poly;
	poly = al_create_poly_poly();
	al_add_rect_to_poly(poly, left, top, right, bottom);
	poly = al_transform_poly(tm1, poly);
	al_push_clipping(w, al_intersection(al_clipping(w), poly));
	al_text(w, left + left_margin, top + top_margin, text);
	al_pop_clipping(w);
	al_pop_font(w);
}
end_body
member
public: string text;
member
public: integer top_margin;
member
public: integer left_margin;
member
public: list Execute(Hit h);
body
{
	var integer type;
	type = h.event.head;
	if (type == Event::LeftDoubleClick) {
		if (status == Status::Execute && _Edit(h)) {
			return 1;
		} else {
		}
		if (status == Status::Layout && _Edit(h)) {
			return 1;
		} else {
		}
	} else {
	}
	return Glyph::Execute(h);
}
end_body
member
public: list _Edit(Hit h);
body
{
	var matrix tm;
	var integer l, t, r, b;
	if (tm = h.tm) {
		var list rect;
		rect = al_transform_rect(tm, left, top, right, bottom);
		l = rect.head;
		t = rect.tail.head;
		r = rect.tail.tail.head;
		b = rect.tail.tail.tail.head;
	} else {
		l = left;
		t = top;
		r = right;
		b = bottom;
	}
	text = al_input_by_cedit(h.wnd, l, t, r, b, text);
	if (h.parent) {
		h.parent.status = Status::Edit;
	} else {
	}
	Damage();
	return 1;
}
end_body
member
public: void public_var();
body
{
	text;
}
end_body
member
public: list GbCode(list pif);
body
{
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var LabelGlyph pp;"));
	err = (err || GbCode(pif, "pp = new LabelGlyph;"));
	err = (err || GbCode(pif, "pp.Create(" + GbGeom() + ", \"" + (string)text + "\");"));
	err = (err || GbAttr(pif));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
class StaticLabel
member
public: list Execute(Hit h);
body
{
	var integer type;
	type = h.event.head;
	if (type == Event::LeftDoubleClick) {
		return null;
	} else {
		return Glyph::Execute(h);
	}
}
end_body
member
public: list GbCode(list pif);
body
{
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var StaticLabel pp;"));
	err = (err || GbCode(pif, "pp = new StaticLabel;"));
	err = (err || GbCode(pif, "pp.Create(" + GbGeom() + ", \"" + (string)text + "\");"));
	err = (err || GbAttr(pif));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
end_class
class FrameLabel
member
public: void Draw(window w);
body
{
	LabelGlyph::Draw(w);
	var integer color;
	if (al_get_sys_color(0) != 0x0) {
		color = 0x0;
	} else {
		color = 0xffffff;
	}
	al_push_pen(w, "Solid", 0, color);
	al_push_brush(w, "Null", 0x0, null);
	al_rectangle(w, left, top, right, bottom);
	al_pop_brush(w);
	al_pop_pen(w);
}
end_body
member
public: list GbCode(list pif);
body
{
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var FrameLabel pp;"));
	err = (err || GbCode(pif, "pp = new FrameLabel;"));
	err = (err || GbCode(pif, "pp.Create(" + GbGeom() + ", \"" + (string)text + "\");"));
	err = (err || GbAttr(pif));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
end_class
class MLabel
member
public: void Draw(window w);
body
{
	if (al_is_damaged(w, al_window_tm(w), left, top, right + 1, bottom + 1)) {
	} else {
		return;
	}
	var integer color;
	if (al_get_sys_color(0) != font_color) {
		color = font_color;
	} else {
		color =  ~ font_color & 0xffffff;
	}
	al_push_font(w, font_name, font_height, font_width, color);
	var list poly;
	poly = al_create_poly_poly();
	al_add_rect_to_poly(poly, left, top, right, bottom);
	if (al_window_tm(w)) {
		poly = al_transform_poly(al_window_tm(w), poly);
	} else {
	}
	al_push_clipping(w, al_intersection(al_clipping(w), poly));
	al_m_text(w, left + left_margin, top + top_margin, right, bottom, text);
	al_pop_clipping(w);
	al_pop_font(w);
}
end_body
member
public: list GbCode(list pif);
body
{
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var MLabel pp;"));
	err = (err || GbCode(pif, "pp = new MLabel;"));
	err = (err || GbCode(pif, "pp.Create(" + GbGeom() + ", \"" + (string)text + "\");"));
	err = (err || GbAttr(pif));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
end_class
end_class
class PathGlyph
member
public: void Create(integer x0, integer y0, integer x1, integer y1);
body
{
	Glyph::Create();
	pts = al_cons(null, null);
	al_create_arc(pts, al_list2(x0, y0), null);
	al_create_arc(pts, al_list2(x1, y1), null);
	_CalcBBox();
	line_style = "Solid";
	line_width = 0;
	line_color = 0x0;
}
end_body
member
public: void Draw(window w);
body
{
	if (al_is_damaged(w, al_window_tm(w), left, top, right + 1, bottom + 1)) {
	} else {
		return;
	}
	var list itr, xy;
	var integer x0, y0, x1, y1;
	var integer color;
	if (al_get_sys_color(0) != line_color) {
		color = line_color;
	} else {
		color =  ~ line_color & 0xffffff;
	}
	al_push_pen(w, line_style, line_width, color);
	itr = al_dst_itr(pts);
	xy = al_next_a(itr, null);
	x0 = xy.head;
	y0 = xy.tail.head;
	loop {
		if (xy = al_next_a(itr, null)) {
		} else {
			break;
		}
		x1 = xy.head;
		y1 = xy.tail.head;
		al_line(w, x0, y0, x1, y1);
		x0 = x1;
		y0 = y1;
	}
	al_pop_pen(w);
}
end_body
member
public: list HitTest(Hit h);
body
{
	if (Event::IsMouseEvent((integer)h.event.head)) {
	} else {
		return null;
	}
	var list itr, xy;
	var integer x0, y0, x1, y1, x, y;
	xy = al_inverse_xy(al_window_tm(h.wnd), h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	itr = al_dst_itr(pts);
	xy = al_next_a(itr, null);
	x0 = xy.head;
	y0 = xy.tail.head;
	loop {
		if (xy = al_next_a(itr, null)) {
		} else {
			return null;
		}
		x1 = xy.head;
		y1 = xy.tail.head;
		if (LineGlyph::HitTest(x0, y0, x1, y1, x, y)) {
			return 1;
		} else {
		}
		x0 = x1;
		y0 = y1;
	}
}
end_body
member
public: void KnobDraw(window w);
body
{
	var matrix tm;
	var integer sx, sy;
	if (tm = al_window_tm(w)) {
		sx = 3 / tm[0][0];
		sy = 3 / tm[1][1];
	} else {
		sx = 3;
		sy = 3;
	}
	var list itr, xy;
	var integer x0, y0, x1, y1, x, y;
	itr = al_dst_itr(pts);
	xy = al_next_a(itr, null);
	x0 = xy.head;
	y0 = xy.tail.head;
	al_rectangle(w, x0 - sx, y0 - sy, x0 + sx, y0 + sy);
	loop {
		if (xy = al_next_a(itr, null)) {
		} else {
			break;
		}
		x1 = xy.head;
		y1 = xy.tail.head;
		x = (x0 + x1) / 2;
		y = (y0 + y1) / 2;
		al_rectangle(w, x - sx, y - sy, x + sx, y + sy);
		al_rectangle(w, x1 - sx, y1 - sy, x1 + sx, y1 + sy);
		x0 = x1;
		y0 = y1;
	}
}
end_body
member
public: void KnobPick(Hit h);
body
{
	if (Event::IsMouseEvent((integer)h.event.head)) {
	} else {
		return;
	}
	var list itr, xy;
	var integer x0, y0, x1, y1, x2, y2, x, y;
	var matrix tm1;
	tm1 = al_window_tm(h.wnd);
	xy = al_inverse_xy(tm1, h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	var integer sx, sy;
	if (tm1) {
		sx = 3 / tm1[0][0];
		sy = 3 / tm1[1][1];
	} else {
		sx = 3;
		sy = 3;
	}
	itr = al_dst_itr(pts);
	xy = al_next_a(itr, null);
	x0 = xy.head;
	y0 = xy.tail.head;
	if (al_abs(x0 - x) <= sx && al_abs(y0 - y) <= sy) {
		h.Target(this, (list)al_list2(TargetInfo::CtrlPt, xy));
		return;
	} else {
	}
	loop {
		if (xy = al_next_a(itr, null)) {
		} else {
			break;
		}
		x1 = xy.head;
		y1 = xy.tail.head;
		if (al_abs(x1 - x) <= sx && al_abs(y1 - y) <= sy) {
			h.Target(this, (list)al_list2(TargetInfo::CtrlPt, xy));
			return;
		} else {
		}
		x2 = (x0 + x1) / 2;
		y2 = (y0 + y1) / 2;
		if (al_abs(x2 - x) <= sx && al_abs(y2 - y) <= sy) {
			h.Target(this, (list)al_list2(TargetInfo::MidPt, xy));
			return;
		} else {
		}
		x0 = x1;
		y0 = y1;
	}
}
end_body
member
public: void KnobDamage();
body
{
	var list itr, xy, poly;
	var integer x0, y0, x1, y1, x2, y2;
	var matrix tm1;
	poly = al_create_poly_poly();
	al_add_rect_to_poly(poly, -3, -3, 3, 3);
	itr = al_dst_itr(pts);
	xy = al_next_a(itr, null);
	x0 = xy.head;
	y0 = xy.tail.head;
	tm1 = al_translate_tm(x0, y0);
	Glyph::AbsDamage(this, poly, tm1);
	loop {
		if (xy = al_next_a(itr, null)) {
		} else {
			break;
		}
		x1 = xy.head;
		y1 = xy.tail.head;
		tm1 = al_translate_tm(x1, y1);
		Glyph::AbsDamage(this, poly, tm1);
		x2 = (x0 + x1) / 2;
		y2 = (y0 + y1) / 2;
		tm1 = al_translate_tm(x2, y2);
		Glyph::AbsDamage(this, poly, tm1);
		x0 = x1;
		y0 = y1;
	}
}
end_body
member
public: list Execute(Hit h);
body
{
	var integer type, modif;
	var list info;
	type = h.event.head;
	modif = h.event.tail.tail.tail.tail.head;
	if (info = h.info) {
		info = info.head;
	} else {
	}
	if (type == Event::LeftPress && modif != 0x2) {
		if (info == TargetInfo::CtrlPt && status == Status::Layout && _BeginCtrlPt(h)) {
			status = Status::CtrlPt;
			return 1;
		} else {
		}
		if (info == TargetInfo::MidPt && status == Status::Layout && _BeginMidPt(h)) {
			status = Status::CtrlPt;
			return 1;
		} else {
		}
		if (info == TargetInfo::CtrlPt && status == Status::Layout && _DeleteCtrlPt(h)) {
			return 1;
		} else {
		}
	} else {
	}
	if (type == Event::MouseMove) {
		if (status == Status::CtrlPt && _DragPt(h)) {
			return 1;
		} else {
		}
	} else {
	}
	if (type == Event::LeftRelease) {
		if (status == Status::CtrlPt && _EndDragPt(h)) {
			status = Status::Layout;
			return 1;
		} else {
		}
	} else {
	}
	return Glyph::Execute(h);
}
end_body
member
public: void _CalcBBox();
body
{
	var list itr, xy;
	var integer x, y;
	itr = al_dst_itr(pts);
	xy = al_next_a(itr, null);
	left = right = xy.head;
	top = bottom = xy.tail.head;
	loop {
		if (xy = al_next_a(itr, null)) {
		} else {
			break;
		}
		x = xy.head;
		y = xy.tail.head;
		left = al_min(x, left);
		top = al_min(y, top);
		right = al_max(x, right);
		bottom = al_max(y, bottom);
	}
}
end_body
member
public: list pts;
member
public: list _BeginCtrlPt(Hit h);
body
{
	var integer modifier;
	modifier = h.event.tail.tail.tail.tail.head;
	if (modifier == 0) {
	} else {
		return null;
	}
	h.root.grab = this;
	_tm = h.tm;
	var list xy, info;
	xy = al_inverse_xy(_tm, h.event.tail.head, h.event.tail.tail.head);
	_x0 = xy.head;
	_y0 = xy.tail.head;
	info = h.info;
	_pt = info.tail.head;
	DrawRBand(h.wnd, _tm, _pt, _x0, _y0);
	return 1;
}
end_body
member
public: list _BeginMidPt(Hit h);
body
{
	var integer modifier;
	modifier = h.event.tail.tail.tail.tail.head;
	if (modifier == 0) {
	} else {
		return null;
	}
	h.root.grab = this;
	_tm = h.tm;
	var list xy, info, pt;
	xy = al_inverse_xy(_tm, h.event.tail.head, h.event.tail.tail.head);
	_x0 = xy.head;
	_y0 = xy.tail.head;
	info = h.info;
	pt = info.tail.head;
	var list itr;
	itr = al_dst_itr(pts);
	loop {
		_pt = al_next(itr);
		if (al_addr_eq(_pt, pt)) {
			break;
		} else {
		}
	}
	_pt = al_list2(_x0, _y0);
	al_insert(itr, _pt, null);
	DrawRBand(h.wnd, _tm, _pt, _x0, _y0);
	return 1;
}
end_body
member
public: list _DragPt(Hit h);
body
{
	DrawRBand(h.wnd, _tm, _pt, _x0, _y0);
	var list xy;
	xy = al_inverse_xy(_tm, h.event.tail.head, h.event.tail.tail.head);
	_x0 = xy.head;
	_y0 = xy.tail.head;
	DrawRBand(h.wnd, _tm, _pt, _x0, _y0);
	return 1;
}
end_body
member
public: list _EndDragPt(Hit h);
body
{
	DrawRBand(h.wnd, _tm, _pt, _x0, _y0);
	h.root.grab = null;
	Damage();
	KnobDamage();
	_pt.head = _x0;
	_pt.tail.head = _y0;
	_CalcBBox();
	AllocationChanged(this);
	Damage();
	KnobDamage();
	_tm = null;
	_x0 = null;
	_y0 = null;
	_pt = null;
	return 1;
}
end_body
member
public: list _DeleteCtrlPt(Hit h);
body
{
	var integer modifier;
	modifier = h.event.tail.tail.tail.tail.head;
	if (modifier == Event::ModifControl) {
	} else {
		return null;
	}
	var list info, pt, pt1, pt2;
	info = h.info;
	pt = info.tail.head;
	pt1 = al_prev_dst_node(pts, pt, null);
	pt2 = al_next_dst_node(pts, pt, null);
	if (pt1 && pt2) {
		var list itr;
		itr = al_dst_itr(pts);
		loop {
			pt1 = al_next(itr);
			if (al_addr_eq(pt1, pt)) {
				break;
			} else {
			}
		}
		Damage();
		KnobDamage();
		al_remove(itr);
		_CalcBBox();
		AllocationChanged(this);
		Damage();
		KnobDamage();
		return 1;
	} else {
		return null;
	}
}
end_body
member
public: list _pt;
member
public: void DrawRBand(window w, matrix tm, list pt, integer x, integer y);
body
{
	al_start_quick_draw(w);
	al_push_color_func(w, 2);
	al_push_pen(w, "Solid", 0, 0xffffff);
	var list pt1, pt2;
	var integer x1, y1, x2, y2;
	pt1 = al_prev_dst_node(pts, pt, null);
	pt2 = al_next_dst_node(pts, pt, null);
	al_push_tm(w, _tm);
	if (pt1) {
		x1 = pt1.head;
		y1 = pt1.tail.head;
		al_line(w, x1, y1, x, y);
	} else {
	}
	if (pt2) {
		x2 = pt2.head;
		y2 = pt2.tail.head;
		al_line(w, x, y, x2, y2);
	} else {
	}
	al_pop_tm(w);
	al_pop_pen(w);
	al_pop_color_func(w);
	al_end_quick_draw(w);
}
end_body
member
public: void AddPt(integer x, integer y);
body
{
	al_create_arc(pts, al_list2(x, y), null);
	_CalcBBox();
}
end_body
member
public: list GbCode(list pif);
body
{
	var list err, itr, pt;
	var string xy0, xy1, xy;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var PathGlyph pp;"));
	err = (err || GbCode(pif, "pp = new  PathGlyph;"));
	itr = al_dst_itr(pts);
	pt = al_next(itr);
	xy0 = (string)pt.head + ", " + (string)pt.tail.head;
	pt = al_next(itr);
	xy1 = (string)pt.head + ", " + (string)pt.tail.head;
	err = (err || GbCode(pif, "pp.Create(" + xy0 + ", " + xy1 + ");"));
	loop {
		if (pt = al_next(itr)) {
		} else {
			break;
		}
		xy = (string)pt.head + ", " + (string)pt.tail.head;
		err = (err || GbCode(pif, "pp.AddPt(" + xy + ");"));
	}
	err = (err || GbAttr(pif));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
class ArrowPath
member
public: void Draw(window w);
body
{
	if (al_is_damaged(w, al_window_tm(w), left, top, right + 1, bottom + 1)) {
	} else {
		return;
	}
	PathGlyph::Draw(w);
	var list itr, pt1, pt2;
	itr = al_dst_itr(pts);
	pt2 = al_prev(itr);
	pt1 = al_prev(itr);
	var integer x1, y1, x2, y2;
	x1 = pt1.head;
	y1 = pt1.tail.head;
	x2 = pt2.head;
	y2 = pt2.tail.head;
	var integer dx, dy, l, xx1, yy1, xx2, yy2;
	dx = x2 - x1;
	dy = y2 - y1;
	l = al_sqrt(dx * dx + dy * dy);
	dx = dx / l;
	dy = dy / l;
	xx1 = x2 - 10 * (dx + dy / 2);
	yy1 = y2 - 10 * (dy - dx / 2);
	xx2 = x2 - 10 * (dx - dy / 2);
	yy2 = y2 - 10 * (dy + dx / 2);
	var integer color;
	if (al_get_sys_color(0) != line_color) {
		color = line_color;
	} else {
		color =  ~ line_color & 0xffffff;
	}
	al_push_pen(w, line_style, line_width, color);
	al_line(w, x2, y2, xx1, yy1);
	al_line(w, x2, y2, xx2, yy2);
	al_pop_pen(w);
}
end_body
member
public: void Damage();
body
{
	Glyph::Damage();
	var list itr, pt2;
	itr = al_dst_itr(pts);
	pt2 = al_prev(itr);
	var integer x2, y2;
	x2 = pt2.head;
	y2 = pt2.tail.head;
	Glyph::Damage(x2 - 10, y2 - 10, x2 + 10, y2 + 10);
}
end_body
member
public: list GbCode(list pif);
body
{
	var list err, itr, pt;
	var string xy0, xy1, xy;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var ArrowPath pp;"));
	err = (err || GbCode(pif, "pp = new  ArrowPath;"));
	itr = al_dst_itr(pts);
	pt = al_next(itr);
	xy0 = (string)pt.head + ", " + (string)pt.tail.head;
	pt = al_next(itr);
	xy1 = (string)pt.head + ", " + (string)pt.tail.head;
	err = (err || GbCode(pif, "pp.Create(" + xy0 + ", " + xy1 + ");"));
	loop {
		if (pt = al_next(itr)) {
		} else {
			break;
		}
		xy = (string)pt.head + ", " + (string)pt.tail.head;
		err = (err || GbCode(pif, "pp.AddPt(" + xy + ");"));
	}
	err = (err || GbAttr(pif));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
end_class
end_class
class HierIcon
member
public: void Draw(window w);
body
{
	if (al_is_damaged(w, al_window_tm(w), left, top, right + 1, bottom + 1)) {
	} else {
		return;
	}
	if (icon_color) {
	} else {
		icon_color = 0xffffff;
	}
	var integer color;
	if (al_get_sys_color(0) != 0x0) {
		color = 0x0;
	} else {
		color = 0xffffff;
	}
	al_push_pen(w, "Solid", 0, color);
	if (al_get_sys_color(0) != 0x0) {
		color = icon_color;
	} else {
		if (icon_color != 0xffffff) {
			color = icon_color;
		} else {
			color = 0x0;
		}
	}
	al_push_brush(w, "Solid", color, null);
	al_line(w, left, (top + bottom) / 2, right, (top + bottom) / 2);
	if (close) {
		if (close_bmp) {
			al_image(w, (left * 3 + right) / 4, top + 2, close_bmp, (right + left) / 2, bottom - top);
		} else {
			al_rectangle(w, (left * 3 + right) / 4, top + 2, (left + right * 3) / 4, bottom - 2);
		}
	} else {
		if (open_bmp) {
			al_image(w, (left * 3 + right) / 4, top + 2, open_bmp, (right + left) / 2, bottom - top);
		} else {
			al_rectangle(w, (left * 3 + right) / 4, top + 2, (left + right * 3) / 4, bottom - 2);
		}
	}
	al_pop_brush(w);
	al_pop_pen(w);
}
end_body
member
public: list Execute(Hit h);
body
{
	var integer type, modif;
	type = h.event.head;
	modif = h.event.tail.tail.tail.tail.head;
	if (type == Event::LeftPress && modif != 0x2) {
		if (_ClickCallback(h)) {
			return 1;
		} else {
		}
	} else {
	}
	if (type == Event::LeftDoubleClick) {
		if (_ChangeFold(h)) {
			return 1;
		} else {
		}
	} else {
	}
	return Glyph::Execute(h);
}
end_body
member
public: list _ClickCallback(Hit h);
body
{
	var list node, node1, node2;
	if (node = al_src_node(this, "$hier_icon")) {
	} else {
		// al_print("illegal HierIcon.(click)\n");
		return null;
	}
	node1 = node;
	loop {
		if (node2 = al_src_node(node1, "$hier")) {
		} else {
			break;
		}
		node1 = node2;
	}
	var HierEditor ed;
	if (ed = al_src_node(node1, "tree_root")) {
	} else {
		// al_print("can\'t find HierEditor.\n");
		return null;
	}
	if (ed.click_obj && ed.click_func) {
		ed.click_obj.*ed.click_func(node);
	} else {
		return null;
	}
	return 1;
}
end_body
member
public: list _ChangeFold(Hit h);
body
{
	if (close) {
		close = null;
	} else {
		close = 1;
	}
	var list node1, node2;
	if (node1 = al_src_node(this, "$hier_icon")) {
	} else {
		// al_print("illegal HierIcon.(double click)\n");
		return null;
	}
	loop {
		if (node2 = al_src_node(node1, "$hier")) {
		} else {
			break;
		}
		node1 = node2;
	}
	var HierEditor ed;
	if (ed = al_src_node(node1, "tree_root")) {
	} else {
		// al_print("can\'t find HierEditor.\n");
		return null;
	}
	ed.Damage();
	ed.Adjust();
	ed.Damage();
	return 1;
}
end_body
member
public: integer icon_color;
member
public: list close;
member
public: list close_bmp;
member
public: list open_bmp;
end_class
end_class
class ImageGlyph
member
public: void Create();
body
{
	Glyph::Create();
	Glyph::Resize(0, 0, 100, 100);
	tiling = stretching = 0;
}
end_body
member
public: list Load(string dir, string name);
body
{
	bitmap = null;
	if (loaded_images) {
		if (bitmap = al_dst_node(loaded_images, dir + "/" + name)) {
		} else {
		}
	} else {
		loaded_images = al_cons(null, null);
	}
	if (bitmap) {
	} else {
		bitmap = al_bitmap("create", null, null);
		al_bitmap("set_file", bitmap, name);
		if (al_bitmap("load", bitmap, dir)) {
			return 1;
		} else {
		}
		al_set_dst_node(loaded_images, dir + "/" + name, bitmap);
	}
	var integer width, height;
	width = al_bitmap("width", bitmap, null);
	height = al_bitmap("height", bitmap, null);
	right = left + width;
	bottom = top + height;
	AllocationChanged(this);
	return null;
}
end_body
member
public: void Draw(window w);
body
{
	if (al_is_damaged(w, al_window_tm(w), left, top, right + 1, bottom + 1)) {
	} else {
		return;
	}
	var integer width, height, x, y;
	width = al_bitmap("width", bitmap, null);
	height = al_bitmap("height", bitmap, null);
	var list poly;
	poly = al_create_poly_poly();
	al_add_rect_to_poly(poly, left, top, right, bottom);
	poly = al_transform_poly(al_window_tm(w), poly);
	al_push_clipping(w, poly);
	if (tiling != 0) {
		x = left;
		loop {
			if (x > right) {
				break;
			} else {
			}
			y = top;
			loop {
				if (y > bottom) {
					break;
				} else {
					al_image(w, x, y, bitmap, width, height);
				}
				y = y + height;
			}
			x = x + width;
		}
	} else {
		if (stretching != 0) {
			al_image(w, left, top, bitmap, right - left, bottom - top);
		} else {
			al_image(w, left, top, bitmap, width, height);
		}
	}
	al_pop_clipping(w);
}
end_body
member
public: list bitmap;
member
public: list Execute(Hit h);
body
{
	var integer type;
	type = h.event.head;
	if (type == Event::LeftDoubleClick) {
		if (status == Status::Layout && _Load(h)) {
			return 1;
		} else {
		}
	} else {
	}
	return Glyph::Execute(h);
}
end_body
member
public: list _Load(Hit h);
body
{
	var list dir_name;
	dir_name = al_get_read_filename("BMP Files (*.bmp)|*.bmp|GIF Files (*.gif)|*.gif|JPEG Files (*.jpg,*jpeg)|*.jpg;*.jpeg||", null);
	if (dir_name) {
	} else {
		return null;
	}
	var string dir, name;
	dir = dir_name.head;
	name = dir_name.tail.head;
	Damage();
	KnobDamage();
	if (Load(dir, name)) {
		al_print("Fail to load bitmap file.\n");
		return null;
	} else {
	}
	Damage();
	KnobDamage();
	return 1;
}
end_body
member
public: void public_func();
body
{
	Create();
	Load((string)null, (string)null);
}
end_body
member
public: void public_var();
body
{
	tiling;
	stretching;
}
end_body
member
public: list GbCode(list pif);
body
{
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var ImageGlyph pp;"));
	err = (err || GbCode(pif, "pp = new  ImageGlyph;"));
	err = (err || GbCode(pif, "pp.Create();"));
	err = (err || GbCode(pif, "pp.left = " + (string)left + ";"));
	err = (err || GbCode(pif, "pp.top = " + (string)top + ";"));
	err = (err || GbCode(pif, "pp.Load(GUIbuilder::GetPath(), \"" + (string)al_bitmap("get_file", bitmap, null) + "\");"));
	err = (err || GbCode(pif, "pp.right = " + (string)right + ";"));
	err = (err || GbCode(pif, "pp.bottom = " + (string)bottom + ";"));
	err = (err || GbCode(pif, "pp.tiling = " + (string)tiling + ";"));
	err = (err || GbCode(pif, "pp.stretching = " + (string)stretching + ";"));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
member
public: static list loaded_images;
member
public: integer tiling;
member
public: integer stretching;
end_class
class Editor
member
public: void Resize(integer l, integer t, integer r, integer b);
body
{
	if (l == left && t == top && r == right && b == bottom) {
		return;
	} else {
	}
	Glyph::Resize(l, t, r, b);
	child.Resize(l, t, r, b);
}
end_body
member
public: void MoveControl(window w);
body
{
	if (child) {
		child.MoveControl(w);
	} else {
	}
}
end_body
member
public: void Destroy();
body
{
	if (child) {
		child.Destroy();
	} else {
	}
}
end_body
member
public: void MakeSpaceIndex();
body
{
	if (child) {
		child.MakeSpaceIndex();
	} else {
	}
}
end_body
member
public: void ClearSpaceIndex();
body
{
	if (child) {
		child.ClearSpaceIndex();
	} else {
	}
}
end_body
member
public: SpIdxGlyph child;
member
public: list selection;
member
public: void Delete();
body
{
	var list itr;
	itr = al_dst_itr(selection);
	var TMGlyph info;
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		info.child.Damage();
		info.child.KnobDamage();
		child.Remove(info);
		al_remove(itr);
	}
}
end_body
member
public: void Save();
body
{
	var list dir_name;
	var string dir, name;
	dir_name = al_get_write_filename("All Files (*.*)|*.*||", null);
	if (dir_name) {
	} else {
		return;
	}
	dir = dir_name.head;
	name = dir_name.tail.head;
	var file f;
	if (f = al_file_open(dir + "/" + name, "w")) {
	} else {
		return;
	}
	if (Save(f)) {
		al_print("Fail to save.\n");
	} else {
	}
}
end_body
member
public: void Load();
body
{
	var list dir_name;
	var string dir, name;
	dir_name = al_get_read_filename("All Files (*.*)|*.*||", null);
	if (dir_name) {
	} else {
		return;
	}
	dir = dir_name.head;
	name = dir_name.tail.head;
	var file f;
	if (f = al_file_open(dir + "/" + name, "r")) {
	} else {
		return;
	}
	Damage();
	Load(f);
	Damage();
}
end_body
member
public: integer Save(file f);
body
{
	var list data, result;
	child.ClearSpaceIndex();
	data = al_list2(selection, child);
	result = al_file_write(f, "graph", data);
	child.MakeSpaceIndex();
	return result;
}
end_body
member
public: integer Load(file f);
body
{
	var list data;
	if (data = al_file_read(f, "graph")) {
	} else {
		return 1;
	}
	selection = data.head;
	child = data.tail.head;
	child.MakeSpaceIndex();
	Glyph::Resize(child);
	return null;
}
end_body
member
public: integer type;
member
public: string class_name;
member
public: window wnd;
member
public: void public_func();
body
{
	Resize((integer)null, (integer)null, (integer)null, (integer)null);
	Save();
	Load();
	Save((file)null);
	Load((file)null);
}
end_body
class GlyphEditor
member
public: void Create(integer l, integer t, integer r, integer b);
body
{
	Glyph::Create();
	child = new SpIdxGlyph;
	selection = al_cons(null, null);
	status = Status::Edit;
	Editor::Resize(l, t, r, b);
}
end_body
member
public: void Draw(window w);
body
{
	child.Draw(w);
	var list itr;
	itr = al_dst_itr(selection);
	var TMGlyph info;
	al_push_color_func(w, 2);
	al_push_brush(w, "Solid", 0xffffff, null);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		info.KnobDraw(w);
	}
	al_pop_brush(w);
	al_pop_color_func(w);
}
end_body
member
public: void Pick(Hit h);
body
{
	cache_tm = al_window_tm(h.wnd);
	if (Glyph::HitTest(h)) {
		h.Target(this, null);
	} else {
		return;
	}
	h.BeginTarget(this, TargetInfo::ParentEditor);
	child.Pick(h);
	var list itr;
	itr = al_dst_itr(selection);
	var TMGlyph info;
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		info.KnobPick(h);
	}
	h.EndTarget();
}
end_body
member
public: matrix cache_tm;
member
public: list Execute(Hit h);
body
{
	var integer type, modif;
	type = h.event.head;
	modif = h.event.tail.tail.tail.tail.head;
	if (type == Event::LeftPress && modif != 0x2) {
		if (status == Status::InsertObject && _InsertObject(h)) {
			status = Status::Edit;
			return 1;
		} else {
		}
		if (status == Status::Edit && _BeginRange(h)) {
			status = Status::Range;
			return 1;
		} else {
		}
	} else {
	}
	if (type == Event::MouseMove) {
		if (status == Status::Drag && _Drag(h)) {
			return 1;
		} else {
		}
		if (status == Status::Range && _Range(h)) {
			return 1;
		} else {
		}
	} else {
	}
	if (type == Event::LeftRelease) {
		if (status == Status::Drag && _EndDrag(h)) {
			status = Status::Edit;
			return 1;
		} else {
		}
		if (status == Status::Range && _EndRange(h)) {
			status = Status::Edit;
			return 1;
		} else {
		}
	} else {
	}
	return Glyph::Execute(h);
}
end_body
member
public: list ExecuteParent(integer msg, Glyph g, Hit h);
body
{
	info = al_src_node(g, "child");
	if (msg == Message::Select) {
		if (status == Status::Edit && _BeginDrag(h)) {
			status = Status::Drag;
			info = null;
			return 1;
		} else {
		}
	} else {
	}
	if (msg == Message::XorSelect) {
		if (status == Status::Edit && _ChildXorSelect(h)) {
			info = null;
			return 1;
		} else {
		}
	} else {
	}
	info = null;
	return null;
}
end_body
member
public: TMGlyph info;
member
public: integer _x0;
member
public: integer _y0;
member
public: integer _x1;
member
public: integer _y1;
member
public: integer _left;
member
public: integer _top;
member
public: integer _right;
member
public: integer _bottom;
member
public: list _BeginDrag(Hit h);
body
{
	h.root.grab = this;
	DoSelect(info);
	_x0 = h.event.tail.head;
	_y0 = h.event.tail.tail.head;
	_x1 = _x0;
	_y1 = _y0;
	// al_repair(h.wnd);
	DrawRBand(h.wnd, cache_tm, _left, _top, _right, _bottom, _x0, _y0, _x1, _y1);
	return 1;
}
end_body
member
public: list _Drag(Hit h);
body
{
	DrawRBand(h.wnd, cache_tm, _left, _top, _right, _bottom, _x0, _y0, _x1, _y1);
	_x1 = h.event.tail.head;
	_y1 = h.event.tail.tail.head;
	DrawRBand(h.wnd, cache_tm, _left, _top, _right, _bottom, _x0, _y0, _x1, _y1);
	return 1;
}
end_body
member
public: list _EndDrag(Hit h);
body
{
	DrawRBand(h.wnd, cache_tm, _left, _top, _right, _bottom, _x0, _y0, _x1, _y1);
	if (cache_tm) {
		var list xy0, xy1;
		xy0 = al_inverse_xy(cache_tm, _x0, _y0);
		_x0 = xy0.head;
		_y0 = xy0.tail.head;
		xy1 = al_inverse_xy(cache_tm, _x1, _y1);
		_x1 = xy1.head;
		_y1 = xy1.tail.head;
	} else {
	}
	DoMove(_x1 - _x0, _y1 - _y0);
	h.root.grab = null;
	_x0 = _y0 = _x1 = _y1 = null;
	_left = _top = _right = _bottom = null;
	return 1;
}
end_body
member
public: list _BeginRange(Hit h);
body
{
	DoSelect((TMGlyph)null);
	_x0 = h.event.tail.head;
	_y0 = h.event.tail.tail.head;
	_x1 = _x0;
	_y1 = _y0;
	_left = al_min(_x0, _x1);
	_top = al_min(_y0, _y1);
	_right = al_max(_x0, _x1);
	_bottom = al_max(_y0, _y1);
	DrawRBand(h.wnd, (matrix)null, _left, _top, _right, _bottom, 0, 0, 0, 0);
	return 1;
}
end_body
member
public: list _Range(Hit h);
body
{
	DrawRBand(h.wnd, (matrix)null, _left, _top, _right, _bottom, 0, 0, 0, 0);
	_x1 = h.event.tail.head;
	_y1 = h.event.tail.tail.head;
	_left = al_min(_x0, _x1);
	_top = al_min(_y0, _y1);
	_right = al_max(_x0, _x1);
	_bottom = al_max(_y0, _y1);
	DrawRBand(h.wnd, (matrix)null, _left, _top, _right, _bottom, 0, 0, 0, 0);
	return 1;
}
end_body
member
public: list _EndRange(Hit h);
body
{
	DrawRBand(h.wnd, (matrix)null, _left, _top, _right, _bottom, 0, 0, 0, 0);
	if (cache_tm) {
		var list xy;
		xy = al_inverse_xy(cache_tm, _left, _top);
		_left = xy.head;
		_top = xy.tail.head;
		xy = al_inverse_xy(cache_tm, _right, _bottom);
		_right = xy.head;
		_bottom = xy.tail.head;
	} else {
	}
	var list itr, itr2;
	itr = al_dst_itr(child);
	itr2 = al_dst_itr(selection);
	var TMGlyph info;
	loop {
		if (info = al_next_a(itr, "child")) {
		} else {
			break;
		}
		if (_left <= info.left && info.right <= _right && _top <= info.top && info.bottom <= _bottom) {
			al_append(itr2, info, "$select");
			info.child.KnobDamage();
		} else {
		}
	}
	_x0 = _y0 = _x1 = _y1 = null;
	_left = _top = _right = _bottom = null;
	return 1;
}
end_body
member
public: list _ChildXorSelect(Hit h);
body
{
	DoXorSelect(info);
	return 1;
}
end_body
member
public: list _InsertObject(Hit h);
body
{
	var list xy;
	var integer x, y;
	xy = al_inverse_xy(cache_tm, h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	var TMGlyph info;
	info = child.Append(insert_object, x, y);
	insert_object = null;
	child.MakeSpaceIndex(info);
	al_create_arc(selection, info, "$select");
	info.child.Damage();
	info.child.KnobDamage();
	return 1;
}
end_body
member
public: Glyph insert_object;
member
public: void DrawRBand(window w, matrix tm, integer l, integer t, integer r, integer b, integer x0, integer y0, integer x1, integer y1);
body
{
	if (tm) {
		var list xy0, xy1;
		xy0 = al_inverse_xy(tm, x0, y0);
		x0 = xy0.head;
		y0 = xy0.tail.head;
		xy1 = al_inverse_xy(tm, x1, y1);
		x1 = xy1.head;
		y1 = xy1.tail.head;
	} else {
	}
	DrawRBand(w, tm, l + x1 - x0, t + y1 - y0, r + x1 - x0, b + y1 - y0);
}
end_body
member
public: void DoSelect(TMGlyph info1);
body
{
	if (info1) {
		_left = info1.left;
		_top = info1.top;
		_right = info1.right;
		_bottom = info1.bottom;
	} else {
		_left = _top = 1.e+030;
		_right = _bottom = -1.e+030;
	}
	var list itr;
	itr = al_dst_itr(selection);
	var TMGlyph info, info2;
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		if (al_addr_eq(info, info1)) {
			info2 = info1;
		} else {
			_left = al_min(_left, info.left);
			_top = al_min(_top, info.top);
			_right = al_max(_right, info.right);
			_bottom = al_max(_bottom, info.bottom);
		}
	}
	if (info2) {
		return;
	} else {
	}
	itr = al_dst_itr(selection);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		al_remove(itr);
		info.child.KnobDamage();
	}
	if (info1) {
		_left = info1.left;
		_top = info1.top;
		_right = info1.right;
		_bottom = info1.bottom;
	} else {
		return;
	}
	al_append(itr, info1, "$select");
	info1.child.KnobDamage();
}
end_body
member
public: void DoXorSelect(TMGlyph info1);
body
{
	var list itr;
	itr = al_dst_itr(selection);
	var TMGlyph info;
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		if (al_addr_eq(info, info1)) {
			al_remove(itr);
			info.child.KnobDamage();
			return;
		} else {
		}
	}
	al_append(itr, info1, "$select");
	info1.child.KnobDamage();
}
end_body
member
public: void DoMove(integer dx, integer dy);
body
{
	var list itr;
	itr = al_dst_itr(selection);
	var TMGlyph info;
	var SpIdxGlyph parent;
	var matrix tm1;
	tm1 = al_translate_tm(dx, dy);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		info.child.Damage();
		info.child.KnobDamage();
		if (info.tm) {
			info.SetTM(tm1 * info.tm);
		} else {
			info.SetTM(tm1);
		}
		parent = al_src_node(info, "child");
		parent.MakeSpaceIndex(info);
		info.child.Damage();
		info.child.KnobDamage();
	}
}
end_body
member
public: void Raise();
body
{
	var TMGlyph info;
	if (info = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	_Raise(info);
}
end_body
member
public: void Lower();
body
{
	var TMGlyph info;
	if (info = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	_Lower(info);
}
end_body
member
public: void _Raise(TMGlyph info);
body
{
	var list itr;
	child.Remove(info);
	itr = al_dst_itr(child);
	al_insert(itr, info, "child");
	child.MakeSpaceIndex(info);
	info.Damage();
	info.child.BringWindowToTop((list)1);
}
end_body
member
public: void _Lower(TMGlyph info);
body
{
	var list itr;
	child.Remove(info);
	itr = al_dst_itr(child);
	al_append(itr, info, "child");
	child.MakeSpaceIndex(info);
	info.Damage();
	info.child.BringWindowToTop(null);
}
end_body
member
public: list GbCode(list pif);
body
{
	var string file_name;
	if (file_name = al_dst_node(this, "$editor_id")) {
	} else {
		return 1;
	}
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var GlyphEditor pp;"));
	err = (err || GbCode(pif, "pp = new GlyphEditor;"));
	err = (err || GbCode(pif, "pp.Create(" + GbGeom() + ");"));
	err = (err || GbCode(pif, "var file f;"));
	err = (err || GbCode(pif, "if (f = al_file_open(GUIbuilder::GetPath() + \"/\\" + file_name + "\", \"r\")) {"));
	err = (err || GbCode(pif, "pp.Load(f);"));
	err = (err || GbCode(pif, "f = null;"));
	err = (err || GbCode(pif, "} else {"));
	err = (err || GbCode(pif, "}"));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
class GraphEditor
member
public: void Create(integer l, integer t, integer r, integer b);
body
{
	GlyphEditor::Create(l, t, r, b);
	nodes = al_cons(null, null);
	arcs = al_cons(null, null);
	labels = al_cons(null, null);
}
end_body
member
public: list CreateNode(Glyph g, integer x, integer y);
body
{
	var TMGlyph info;
	info = child.Append(g, x, y);
	child.MakeSpaceIndex(info);
	info.child.Damage();
	info.child.KnobDamage();
	var list node;
	node = al_cons(1, null);
	al_create_arc(nodes, node, null);
	al_create_arc(node, info, "$geom");
	return node;
}
end_body
member
public: list CreateArc(list src, list dst);
body
{
	var TMGlyph src_info, dst_info, arc_info;
	src_info = al_dst_node(src, "$geom");
	dst_info = al_dst_node(dst, "$geom");
	var ArrowPath path;
	path = new ArrowPath;
	var integer x1, y1, x2, y2;
	x1 = (src_info.left + src_info.right) / 2;
	y1 = (src_info.top + src_info.bottom) / 2;
	x2 = (dst_info.left + dst_info.right) / 2;
	y2 = (dst_info.top + dst_info.bottom) / 2;
	path.Create(x1, y1, x2, y2);
	arc_info = child.Append(path, 0, 0);
	var list arc;
	arc = al_cons(2, null);
	al_create_arc(arcs, arc, null);
	al_create_arc(arc, src, "$src");
	al_create_arc(arc, dst, "$dst");
	al_create_arc(arc, arc_info, "$geom");
	AdjustInArc(arc);
	AdjustOutArc(arc);
	return arc;
}
end_body
member
public: list CreateLabel(list elem, string s, integer x, integer y);
body
{
	var TMGlyph info;
	var LabelGlyph lab;
	lab = new MLabel;
	lab.Create(0, 0, 60, 20, s);
	info = child.Append(lab, x, y);
	child.MakeSpaceIndex(info);
	info.child.Damage();
	info.child.KnobDamage();
	var list label;
	label = al_cons(3, null);
	al_create_arc(labels, label, null);
	al_create_arc(label, elem, "$refer");
	al_create_arc(label, info, "$geom");
	return label;
}
end_body
member
public: void DeleteNode(list node);
body
{
	var list itr, label;
	itr = al_src_itr(node);
	loop {
		if (label = al_next_a(itr, "$refer")) {
		} else {
			break;
		}
		DeleteLabel(label);
	}
	var list arc, itr;
	itr = al_src_itr(node);
	loop {
		if (arc = al_next_a(itr, "$dst")) {
		} else {
			break;
		}
		DeleteArc(arc);
	}
	itr = al_src_itr(node);
	loop {
		if (arc = al_next_a(itr, "$src")) {
		} else {
			break;
		}
		DeleteArc(arc);
	}
	var TMGlyph info;
	info = al_dst_node(node, "$geom");
	info.child.Damage();
	info.child.KnobDamage();
	if (child.Remove(info)) {
		al_remove_from(nodes, node, null);
	} else {
	}
}
end_body
member
public: void DeleteArc(list arc);
body
{
	var list itr, label;
	itr = al_src_itr(arc);
	loop {
		if (label = al_next_a(itr, "$refer")) {
		} else {
			break;
		}
		DeleteLabel(label);
	}
	var TMGlyph info;
	info = al_dst_node(arc, "$geom");
	info.child.Damage();
	info.child.KnobDamage();
	if (child.Remove(info)) {
		al_remove_from(arcs, arc, null);
	} else {
	}
}
end_body
member
public: void DeleteLabel(list label);
body
{
	var TMGlyph info;
	info = al_dst_node(label, "$geom");
	info.child.Damage();
	info.child.KnobDamage();
	if (child.Remove(info)) {
		al_remove_from(labels, label, null);
	} else {
	}
}
end_body
member
public: void Delete();
body
{
	var list itr, elem;
	var TMGlyph info;
	itr = al_dst_itr(selection);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		if (elem = al_src_node(info, "$geom")) {
		} else {
			continue;
		}
		if (elem.head == 3) {
			DeleteLabel(elem);
		} else {
		}
	}
	itr = al_dst_itr(selection);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		if (elem = al_src_node(info, "$geom")) {
		} else {
			continue;
		}
		if (elem.head == 2) {
			DeleteArc(elem);
		} else {
		}
	}
	itr = al_dst_itr(selection);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		if (elem = al_src_node(info, "$geom")) {
		} else {
			continue;
		}
		if (elem.head == 1) {
			DeleteNode(elem);
		} else {
		}
	}
	selection = al_cons(null, null);
}
end_body
member
public: void MoveNode(list node, integer dx, integer dy);
body
{
	var TMGlyph node_info;
	var list sel;
	node_info = al_dst_node(node, "$geom");
	sel = al_src_node(node_info, "$select");
	node_info.child.Damage();
	if (sel) {
		node_info.child.KnobDamage();
	} else {
	}
	node_info.Move(dx, dy);
	child.MakeSpaceIndex(node_info);
	node_info.child.Damage();
	if (sel) {
		node_info.child.KnobDamage();
	} else {
	}
	AdjustNode(node);
	var list itr, label;
	itr = al_src_itr(node);
	loop {
		if (label = al_next_a(itr, "$refer")) {
		} else {
			break;
		}
		MoveLabel(label, dx, dy);
	}
}
end_body
member
public: void AdjustNode(list node);
body
{
	var list arc, itr;
	itr = al_src_itr(node);
	loop {
		if (arc = al_next_a(itr, "$dst")) {
		} else {
			break;
		}
		AdjustInArc(arc);
	}
	itr = al_src_itr(node);
	loop {
		if (arc = al_next_a(itr, "$src")) {
		} else {
			break;
		}
		AdjustOutArc(arc);
	}
}
end_body
member
public: void AdjustInArc(list arc);
body
{
	var list dst;
	dst = al_dst_node(arc, "$dst");
	var TMGlyph dst_info, arc_info;
	var list sel;
	dst_info = al_dst_node(dst, "$geom");
	arc_info = al_dst_node(arc, "$geom");
	sel = al_src_node(arc_info, "$select");
	var PathGlyph path;
	path = arc_info.child;
	var list itr, pt1, pt2;
	itr = al_dst_itr(path.pts);
	pt2 = al_prev(itr);
	pt1 = al_prev(itr);
	var integer x1, y1, x2, y2, dx, dy;
	x1 = pt1.head;
	y1 = pt1.tail.head;
	x2 = (dst_info.left + dst_info.right) / 2;
	y2 = (dst_info.top + dst_info.bottom) / 2;
	dx = x2 - x1;
	dy = y2 - y1;
	if (al_abs(dx) > al_abs(dy)) {
		if (dx > 0) {
			x2 = dst_info.left;
		} else {
			x2 = dst_info.right;
		}
	} else {
		if (dy > 0) {
			y2 = dst_info.top;
		} else {
			y2 = dst_info.bottom;
		}
	}
	arc_info.child.Damage();
	if (sel) {
		arc_info.child.KnobDamage();
	} else {
	}
	pt2.head = x2;
	pt2.tail.head = y2;
	path._CalcBBox();
	arc_info.Body(path);
	child.MakeSpaceIndex(arc_info);
	arc_info.child.Damage();
	if (sel) {
		arc_info.child.KnobDamage();
	} else {
	}
}
end_body
member
public: void AdjustOutArc(list arc);
body
{
	var list src;
	src = al_dst_node(arc, "$src");
	var TMGlyph src_info, arc_info;
	var list sel;
	src_info = al_dst_node(src, "$geom");
	arc_info = al_dst_node(arc, "$geom");
	sel = al_src_node(arc_info, "$select");
	var PathGlyph path;
	path = arc_info.child;
	var list itr, pt1, pt2;
	itr = al_dst_itr(path.pts);
	pt2 = al_next(itr);
	pt1 = al_next(itr);
	var integer x1, y1, x2, y2, dx, dy;
	x1 = pt1.head;
	y1 = pt1.tail.head;
	x2 = (src_info.left + src_info.right) / 2;
	y2 = (src_info.top + src_info.bottom) / 2;
	dx = x2 - x1;
	dy = y2 - y1;
	if (al_abs(dx) > al_abs(dy)) {
		if (dx > 0) {
			x2 = src_info.left;
		} else {
			x2 = src_info.right;
		}
	} else {
		if (dy > 0) {
			y2 = src_info.top;
		} else {
			y2 = src_info.bottom;
		}
	}
	arc_info.child.Damage();
	if (sel) {
		arc_info.child.Damage();
	} else {
	}
	pt2.head = x2;
	pt2.tail.head = y2;
	path._CalcBBox();
	arc_info.Body(path);
	child.MakeSpaceIndex(arc_info);
	arc_info.child.Damage();
	if (sel) {
		arc_info.child.KnobDamage();
	} else {
	}
}
end_body
member
public: void MoveLabel(list label, integer dx, integer dy);
body
{
	var TMGlyph info;
	var list sel;
	info = al_dst_node(label, "$geom");
	sel = al_src_node(info, "$select");
	info.child.Damage();
	if (sel) {
		info.child.KnobDamage();
	} else {
	}
	info.Move(dx, dy);
	child.MakeSpaceIndex(info);
	info.child.Damage();
	if (sel) {
		info.child.KnobDamage();
	} else {
	}
}
end_body
member
public: void AllocationChanged(Glyph g);
body
{
	var TMGlyph info;
	if (info = child.allo_chg_glyph) {
		var list elem;
		elem = al_src_node(info, "$geom");
		if (elem && elem.head == 1) {
			AdjustNode(elem);
		} else {
		}
	} else {
	}
}
end_body
member
public: list nodes;
member
public: list arcs;
member
public: list labels;
member
public: list Execute(Hit h);
body
{
	var integer type, modif;
	type = h.event.head;
	modif = h.event.tail.tail.tail.tail.head;
	if (type == Event::LeftPress && modif != 0x2) {
		if (status == Status::InputNode && _Node(h)) {
			return 1;
		} else {
		}
		if (status == Status::InputArc && _ExitArc(h)) {
			status = Status::Edit;
			return 1;
		} else {
		}
		if (status == Status::InputLabel && _ExitLabel(h)) {
			status = Status::Edit;
			return 1;
		} else {
		}
		if (status == Status::SelectArc && _ExitReconnect(h)) {
			status = Status::Edit;
			return 1;
		} else {
		}
		if (status == Status::Paste && _Paste(h)) {
			status = Status::Edit;
			return 1;
		} else {
		}
		if (status == Status::ReconnectArc) {
			return 1;
		} else {
		}
	} else {
	}
	if (type == Event::MouseMove) {
		if (status == Status::InputArcDrag && _DragArc(h)) {
			return 1;
		} else {
		}
	} else {
	}
	if (type == Event::LeftRelease) {
		if (status == Status::InputArcDrag && _ArcNone(h)) {
			status = Status::InputArc;
			return 1;
		} else {
		}
	} else {
	}
	return GlyphEditor::Execute(h);
}
end_body
member
public: list ExecuteParent(integer msg, Glyph g, Hit h);
body
{
	info = al_src_node(g, "child");
	if (msg == Message::Select) {
		if (status == Status::InputNode && _ExitNode(h)) {
			status = Status::Edit;
			return 1;
		} else {
		}
		if (status == Status::InputArc && _BeginArc(h, info)) {
			status = Status::InputArcDrag;
			return 1;
		} else {
		}
		if (status == Status::InputLabel && _Label(h, info)) {
			return 1;
		} else {
		}
		if (status == Status::SelectArc && _SelectArc(h, info)) {
			status = Status::ReconnectArc;
			return 1;
		} else {
		}
	} else {
	}
	if (msg == Message::Release) {
		if (status == Status::InputArcDrag && _EndArc(h, info)) {
			status = Status::InputArc;
			return 1;
		} else {
		}
		if (status == Status::ReconnectArc && _ReconnectArc(h, info)) {
			status = Status::SelectArc;
			return 1;
		} else {
		}
	} else {
	}
	return GlyphEditor::ExecuteParent(msg, g, h);
}
end_body
member
public: list _Node(Hit h);
body
{
	if (insert_object) {
	} else {
		return 1;
	}
	var list xy;
	var integer x, y;
	xy = al_inverse_xy(cache_tm, h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	var Glyph g;
	var list node;
	g = al_copy(insert_object);
	node = CreateNode(g, x, y);
	al_message_text(h.wnd, "Node Input");
	return 1;
}
end_body
member
public: list _ExitNode(Hit h);
body
{
	insert_object = null;
	al_message_text(h.wnd, "");
	return 1;
}
end_body
member
public: list _BeginArc(Hit h, TMGlyph info);
body
{
	if (src_node = al_src_node(info, "$geom")) {
	} else {
		return null;
	}
	if (src_node.head == 1) {
	} else {
		return null;
	}
	_x0 = h.event.tail.head;
	_y0 = h.event.tail.tail.head;
	_x1 = _x0;
	_y1 = _y0;
	// al_repair(h.wnd);
	DrawRBand(h.wnd, _x0, _y0, _x1, _y1);
	return 1;
}
end_body
member
public: list _DragArc(Hit h);
body
{
	DrawRBand(h.wnd, _x0, _y0, _x1, _y1);
	_x1 = h.event.tail.head;
	_y1 = h.event.tail.tail.head;
	DrawRBand(h.wnd, _x0, _y0, _x1, _y1);
	return 1;
}
end_body
member
public: list _EndArc(Hit h, TMGlyph info);
body
{
	if (dst_node = al_src_node(info, "$geom")) {
	} else {
		return null;
	}
	if (dst_node.head == 1) {
	} else {
		return null;
	}
	if (al_addr_eq(src_node, dst_node)) {
		return null;
	} else {
	}
	DrawRBand(h.wnd, _x0, _y0, _x1, _y1);
	var list arc;
	arc = CreateArc(src_node, dst_node);
	src_node = dst_node = null;
	_x0 = _y0 = _x1 = _y1 = null;
	al_message_text(h.wnd, "Arc Input");
	return 1;
}
end_body
member
public: list _ArcNone(Hit h);
body
{
	DrawRBand(h.wnd, _x0, _y0, _x1, _y1);
	src_node = dst_node = null;
	_x0 = _y0 = _x1 = _y1 = null;
	al_message_text(h.wnd, "Arc Input");
	return 1;
}
end_body
member
public: list _ExitArc(Hit h);
body
{
	al_message_text(h.wnd, "");
	return 1;
}
end_body
member
public: list _Label(Hit h, TMGlyph info);
body
{
	var list elem;
	elem = al_src_node(info, "$geom");
	if (elem.head == 3) {
		return 1;
	} else {
	}
	var list xy;
	var integer x, y;
	xy = al_inverse_xy(cache_tm, h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	var list label;
	label = CreateLabel(elem, "***", x, y);
	var TMGlyph info;
	info = al_dst_node(label, "$geom");
	al_create_arc(selection, info, "$select");
	al_message_text(h.wnd, "Label Input");
	return 1;
}
end_body
member
public: list _ExitLabel(Hit h);
body
{
	al_message_text(h.wnd, "");
	return 1;
}
end_body
member
public: list _SelectArc(Hit h, TMGlyph info);
body
{
	if (_arc = al_src_node(info, "$geom")) {
	} else {
		return null;
	}
	if (_arc.head == 2) {
	} else {
		return null;
	}
	var TMGlyph info;
	info = al_dst_node(_arc, "$geom");
	al_create_arc(selection, info, "$select");
	info.child.KnobDamage();
	return 1;
}
end_body
member
public: list _ReconnectArc(Hit h, TMGlyph info);
body
{
	if (dst_node = al_src_node(info, "$geom")) {
	} else {
		return null;
	}
	if (dst_node.head == 1) {
	} else {
		return null;
	}
	al_set_dst_node(_arc, "$dst", dst_node);
	info = al_dst_node(_arc, "$geom");
	al_remove_from(selection, info, "$select");
	AdjustInArc(_arc);
	dst_node = _arc = null;
	al_message_text(h.wnd, "Arc Reconnect");
	return 1;
}
end_body
member
public: list _ExitReconnect(Hit h);
body
{
	al_message_text(h.wnd, "");
	return 1;
}
end_body
member
public: list _Paste(Hit h);
body
{
	var list xy;
	var integer x, y;
	x = h.event.tail.head;
	y = h.event.tail.tail.head;
	xy = al_inverse_xy(h.tm, x, y);
	x = xy.head;
	y = xy.tail.head;
	var list data;
	var GraphEditor ed;
	data = al_get_clipboard();
	if (data && al_is_type(data, "list")) {
	} else {
		return 1;
	}
	if (data.head == "GraphData") {
	} else {
		return 1;
	}
	ed = data.tail.head;
	ed = al_copy(ed);
	ed.DoMove(x, y);
	var list itr;
	var list elem;
	var TMGlyph info;
	selection = al_cons(null, null);
	itr = al_dst_itr(ed.nodes);
	loop {
		if (elem = al_next(itr)) {
		} else {
			break;
		}
		al_create_arc(nodes, elem, null);
		info = al_dst_node(elem, "$geom");
		al_create_arc(selection, info, "$select");
		al_create_arc(child, info, "child");
	}
	itr = al_dst_itr(ed.arcs);
	loop {
		if (elem = al_next(itr)) {
		} else {
			break;
		}
		al_create_arc(arcs, elem, null);
		info = al_dst_node(elem, "$geom");
		al_create_arc(selection, info, "$select");
		al_create_arc(child, info, "child");
	}
	itr = al_dst_itr(ed.labels);
	loop {
		if (elem = al_next(itr)) {
		} else {
			break;
		}
		al_create_arc(labels, elem, null);
		info = al_dst_node(elem, "$geom");
		al_create_arc(selection, info, "$select");
		al_create_arc(child, info, "child");
	}
	ClearSpaceIndex();
	MakeSpaceIndex();
	Damage();
	return 1;
}
end_body
member
public: list src_node;
member
public: list dst_node;
member
public: list _arc;
member
public: void DrawRBand(window w, integer x0, integer y0, integer x1, integer y1);
body
{
	al_start_quick_draw(w);
	al_push_color_func(w, 2);
	al_push_pen(w, "Solid", 0, 0xffffff);
	al_push_brush(w, "Null", 0x0, null);
	al_line(w, x0, y0, x1, y1);
	al_pop_brush(w);
	al_pop_pen(w);
	al_pop_color_func(w);
	al_end_quick_draw(w);
}
end_body
member
public: void DoMove(integer dx, integer dy);
body
{
	var list itr, itr2;
	itr = al_dst_itr(selection);
	var TMGlyph info, info2;
	var list elem, elem2;
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		elem = al_src_node(info, "$geom");
		if (elem.head == 1) {
			MoveNode(elem, dx, dy);
		} else {
		}
		if (elem.head == 2) {
		} else {
		}
		if (elem.head == 3) {
			elem2 = al_dst_node(elem, "$refer");
			info2 = al_dst_node(elem2, "$geom");
			if (elem2.head == 1 && al_src_node(info2, "$select")) {
			} else {
				MoveLabel(elem, dx, dy);
			}
		} else {
		}
	}
}
end_body
member
public: integer Save(file f);
body
{
	var list data, result;
	child.ClearSpaceIndex();
	data = al_list5(labels, arcs, nodes, selection, child);
	result = al_file_write(f, "graph", data);
	child.MakeSpaceIndex();
	return result;
}
end_body
member
public: integer Load(file f);
body
{
	var list data;
	if (data = al_file_read(f, "graph")) {
	} else {
		return 1;
	}
	labels = data.head;
	arcs = data.tail.head;
	nodes = data.tail.tail.head;
	selection = data.tail.tail.tail.head;
	child = data.tail.tail.tail.tail.head;
	child.MakeSpaceIndex();
	Glyph::Resize(child);
	return null;
}
end_body
member
public: list GetSelectedNode();
body
{
	var TMGlyph info;
	if (info = al_dst_node(selection, "$select")) {
	} else {
		return null;
	}
	var list node;
	node = al_src_node(info, "$geom");
	if (node && node.head == 1) {
	} else {
		return null;
	}
	return node;
}
end_body
member
public: static list LabelText(list node, string attr);
body
{
	var list label;
	if (label = al_src_node(node, attr)) {
	} else {
		return null;
	}
	var TMGlyph info;
	if (info = al_dst_node(label, "$geom")) {
	} else {
		return null;
	}
	var LabelGlyph lab;
	if (lab = info.child) {
	} else {
		return null;
	}
	return lab.text;
}
end_body
member
public: void Copy();
body
{
	var GraphEditor ed;
	ed = new GraphEditor;
	ed.Create(0, 0, 1200, 1200);
	var list itr;
	var TMGlyph info;
	var integer x, y;
	var list elem;
	x = y = 1.e+030;
	itr = al_dst_itr(selection);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		x = al_min(x, info.left);
		y = al_min(y, info.top);
		elem = al_src_node(info, "$geom");
		if (elem.head == 1) {
			al_create_arc(ed.nodes, elem, null);
			al_create_arc(ed.selection, info, "$select");
			al_create_arc(ed.child, info, "child");
		} else {
		}
		if (elem.head == 2) {
			al_create_arc(ed.arcs, elem, null);
			al_create_arc(ed.selection, info, "$select");
			al_create_arc(ed.child, info, "child");
		} else {
		}
		if (elem.head == 3) {
			al_create_arc(ed.labels, elem, null);
			al_create_arc(ed.selection, info, "$select");
			al_create_arc(ed.child, info, "child");
		} else {
		}
	}
	ed = al_copy(ed);
	ed.DoMove( - x,  - y);
	al_set_clipboard(al_list2("GraphData", ed));
}
end_body
member
public: void Paste();
body
{
	status = Status::Paste;
}
end_body
member
public: list GbCode(list pif);
body
{
	var string file_name;
	if (file_name = al_dst_node(this, "$editor_id")) {
	} else {
		return 1;
	}
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var GraphEditor pp;"));
	err = (err || GbCode(pif, "pp = new GraphEditor;"));
	err = (err || GbCode(pif, "pp.Create(" + GbGeom() + ");"));
	err = (err || GbCode(pif, "var file f;"));
	err = (err || GbCode(pif, "if (f = al_file_open(GUIbuilder::GetPath() + \"/\\" + file_name + "\", \"r\")) {"));
	err = (err || GbCode(pif, "pp.Load(f);"));
	err = (err || GbCode(pif, "f = null;"));
	err = (err || GbCode(pif, "} else {"));
	err = (err || GbCode(pif, "}"));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
member
public: void public_func();
body
{
	Create((integer)null, (integer)null, (integer)null, (integer)null);
	CreateNode((Glyph)null, (integer)null, (integer)null);
	CreateArc(null, null);
	CreateLabel(null, (string)null, (integer)null, (integer)null);
	DeleteNode(null);
	DeleteArc(null);
	DeleteLabel(null);
	MoveNode(null, (integer)null, (integer)null);
	AdjustNode(null);
	AdjustInArc(null);
	AdjustOutArc(null);
	MoveLabel(null, (integer)null, (integer)null);
	GetSelectedNode();
	Copy();
	Paste();
}
end_body
end_class
end_class
class TableEditor
member
public: void Create(integer n_row, integer n_col, integer width, integer height, string s);
body
{
	default_width = 100;
	default_height = 20;
	Glyph::Create();
	nrow = n_row;
	ncol = n_col;
	child = new SpIdxGlyph;
	selection = al_cons(null, null);
	cells = al_cons(null, null);
	var integer i, j, x, y;
	var TMGlyph info;
	var Glyph g;
	var list row_frame, cell_frame;
	y = 0;
	i = 1;
	loop {
		if (i > nrow) {
			break;
		} else {
		}
		row_frame = al_cons(height, null);
		al_create_arc(cells, row_frame, i);
		x = 0;
		j = 1;
		loop {
			if (j > ncol) {
				break;
			} else {
			}
			g = DefaultCell(width, height, s);
			info = child.Append(g, x, y);
			cell_frame = al_cons(width, al_cons(info, null));
			al_create_arc(row_frame, cell_frame, j);
			x = x + width;
			j = j + 1;
		}
		y = y + height;
		i = i + 1;
	}
	Editor::Resize(0, 0, x, y);
	status = Status::Edit;
}
end_body
member
public: integer default_width;
member
public: integer default_height;
member
public: void Draw(window w);
body
{
	_DrawingArea(w);
	_DrawCells(w);
	_DrawLines(w);
	_DrawSelection(w);
}
end_body
member
public: void _DrawingArea(window w);
body
{
	var list area, itr, pt, flag, row_frame, cell_frame;
	var integer l, t, r, b, i, j, vpos, hpos;
	area = al_intersection(al_damage_rect_poly(w), al_clipping(w));
	area = al_inverse_poly(al_translate_tm(left, top) * al_window_tm(w), area);
	itr = al_dst_itr(al_dst_node(area, null));
	l = t = 1.e+030;
	r = b = -1.e+030;
	loop {
		if (pt = al_next(itr)) {
		} else {
			break;
		}
		l = al_min(l, pt.head);
		t = al_min(t, pt.tail.head);
		r = al_max(r, pt.head);
		b = al_max(b, pt.tail.head);
	}
	flag = 1;
	vpos = 0;
	i = 1;
	loop {
		row_frame = al_dst_node(cells, i);
		vpos = vpos + row_frame.head;
		if (flag && t <= vpos) {
			s_row = i;
			flag = null;
		} else {
		}
		if (i == nrow || b <= vpos) {
			e_row = i;
			break;
		} else {
		}
		i = i + 1;
	}
	flag = 1;
	hpos = 0;
	j = 1;
	row_frame = al_dst_node(cells, 1);
	loop {
		cell_frame = al_dst_node(row_frame, j);
		hpos = hpos + cell_frame.head;
		if (flag && l <= hpos) {
			s_col = j;
			flag = null;
		} else {
		}
		if (j == ncol || r <= hpos) {
			e_col = j;
			break;
		} else {
		}
		j = j + 1;
	}
}
end_body
member
public: void _DrawCells(window w);
body
{
	var list row_frame, cell_frame;
	var integer i, j;
	var TMGlyph info;
	i = s_row;
	loop {
		if (i > e_row) {
			break;
		} else {
		}
		row_frame = al_dst_node(cells, i);
		j = s_col;
		loop {
			if (j > e_col) {
				break;
			} else {
			}
			cell_frame = al_dst_node(row_frame, j);
			info = cell_frame.tail.head;
			info.Draw(w);
			j = j + 1;
		}
		i = i + 1;
	}
}
end_body
member
public: void _DrawLines(window w);
body
{
	var list row_frame, cell_frame;
	var integer i, j, x, x2, y, y2;
	x = HPosition(s_col - 1);
	x2 = HPosition(e_col);
	y = VPosition(s_row - 1);
	i = s_row - 1;
	var integer color;
	if (al_get_sys_color(0) != 0x0) {
		color = 0x0;
	} else {
		color = 0xffffff;
	}
	al_push_pen(w, "Solid", 0, color);
	loop {
		al_line(w, x, y, x2, y);
		i = i + 1;
		if (i > e_row) {
			break;
		} else {
		}
		row_frame = al_dst_node(cells, i);
		y = y + row_frame.head;
	}
	x = HPosition(s_col - 1);
	y = VPosition(s_row - 1);
	y2 = VPosition(e_row);
	j = s_col - 1;
	row_frame = al_dst_node(cells, 1);
	loop {
		al_line(w, x, y, x, y2);
		j = j + 1;
		if (j > e_col) {
			break;
		} else {
		}
		cell_frame = al_dst_node(row_frame, j);
		x = x + cell_frame.head;
	}
	al_pop_pen(w);
}
end_body
member
public: void _DrawSelection(window w);
body
{
	var list itr, info_ij;
	var TMGlyph info;
	al_push_color_func(w, 2);
	al_push_pen(w, "Null,", 0, 0x0);
	al_push_brush(w, "Solid", 0xffffff, null);
	itr = al_dst_itr(selection);
	loop {
		if (info_ij = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		info = info_ij.head;
		al_rectangle(w, info.left, info.top, info.right, info.bottom);
	}
	al_pop_brush(w);
	al_pop_pen(w);
	al_pop_color_func(w);
}
end_body
member
public: integer s_row;
member
public: integer e_row;
member
public: integer s_col;
member
public: integer e_col;
member
public: void Pick(Hit h);
body
{
	h.BeginTarget(this, TargetInfo::ParentEditor);
	child.Pick(h);
	h.EndTarget();
	_PickLines(h);
}
end_body
member
public: void _PickLines(Hit h);
body
{
	var list xxyy;
	var integer xx, yy;
	xxyy = al_inverse_xy(al_window_tm(h.wnd), h.event.tail.head, h.event.tail.tail.head);
	xx = xxyy.head - left;
	yy = xxyy.tail.head - top;
	var list row_frame, cell_frame;
	var integer i, j, x, x2, y, y2;
	x = 0;
	x2 = HPosition(ncol);
	y = 0;
	i = 1;
	loop {
		if (i > nrow) {
			break;
		} else {
		}
		row_frame = al_dst_node(cells, i);
		y = y + row_frame.head;
		if (y > yy + 2) {
			break;
		} else {
		}
		if (x <= xx && xx <= x2 && al_abs(yy - y) <= 2) {
			h.Target(this, (list)al_cons(TargetInfo::HLine, al_cons(i, null)));
			return;
		} else {
		}
		i = i + 1;
	}
	x = 0;
	y = 0;
	y2 = VPosition(nrow);
	j = 1;
	row_frame = al_dst_node(cells, 1);
	loop {
		if (j > ncol) {
			break;
		} else {
		}
		cell_frame = al_dst_node(row_frame, j);
		x = x + cell_frame.head;
		if (x > xx + 2) {
			break;
		} else {
		}
		if (al_abs(xx - x) <= 2 && y <= yy && yy <= y2) {
			h.Target(this, (list)al_cons(TargetInfo::VLine, al_cons(j, null)));
			return;
		} else {
		}
		j = j + 1;
	}
}
end_body
member
public: list Execute(Hit h);
body
{
	var integer type, modif;
	type = h.event.head;
	modif = h.event.tail.tail.tail.tail.head;
	var list info;
	info = h.info;
	if (type == Event::LeftPress && modif != 0x2) {
		if (status == Status::Edit) {
			if (info && info != TargetInfo::ParentEditor) {
				if (info.head == TargetInfo::VLine && _BeginVLineDrag(h)) {
					status = Status::VLineDrag;
					return 1;
				} else {
				}
				if (info.head == TargetInfo::HLine && _BeginHLineDrag(h)) {
					status = Status::HLineDrag;
					return 1;
				} else {
				}
			} else {
			}
		} else {
		}
	} else {
	}
	if (type == Event::MouseMove) {
		if (status == Status::VLineDrag && _VLineDrag(h)) {
			return 1;
		} else {
		}
		if (status == Status::HLineDrag && _HLineDrag(h)) {
			return 1;
		} else {
		}
	} else {
	}
	if (type == Event::LeftRelease) {
		if (status == Status::VLineDrag && _EndVLineDrag(h)) {
			status = Status::Edit;
			return 1;
		} else {
		}
		if (status == Status::HLineDrag && _EndHLineDrag(h)) {
			status = Status::Edit;
			return 1;
		} else {
		}
	} else {
	}
	return Glyph::Execute(h);
}
end_body
member
public: list ExecuteParent(integer msg, Glyph g, Hit h);
body
{
	info = al_src_node(g, "child");
	var list itr, info_ij, flag, row_frame, cell_frame;
	var integer i, j;
	var TMGlyph info1;
	if (msg == Message::Select) {
		itr = al_dst_itr(selection);
		loop {
			info_ij = al_next_a(itr, "$select");
			if (info_ij) {
			} else {
				break;
			}
			info1 = info_ij.head;
			Glyph::Damage(info1.left, info1.top, info1.right, info1.bottom);
		}
		selection = al_cons(null, null);
		i = 1;
		loop {
			if (i > nrow) {
				break;
			} else {
			}
			row_frame = al_dst_node(cells, i);
			j = 1;
			loop {
				if (j > ncol) {
					break;
				} else {
				}
				cell_frame = al_dst_node(row_frame, j);
				if (al_addr_eq(cell_frame.tail.head, info)) {
					flag = 1;
					break;
				} else {
				}
				j = j + 1;
			}
			if (flag) {
				break;
			} else {
			}
			i = i + 1;
		}
		info_ij = al_cons(info, al_cons(i, al_cons(j, null)));
		al_create_arc(selection, info_ij, "$select");
		Glyph::Damage(info.left, info.top, info.right, info.bottom);
		return 1;
	} else {
	}
	if (msg == Message::XorSelect) {
		itr = al_dst_itr(selection);
		loop {
			if (info_ij = al_next_a(itr, "$select")) {
			} else {
				i = 1;
				loop {
					if (i > nrow) {
						break;
					} else {
					}
					row_frame = al_dst_node(cells, i);
					j = 1;
					loop {
						if (j > ncol) {
							break;
						} else {
						}
						cell_frame = al_dst_node(row_frame, j);
						if (al_addr_eq(cell_frame.tail.head, info)) {
							flag = 1;
							break;
						} else {
						}
						j = j + 1;
					}
					if (flag) {
						break;
					} else {
					}
					i = i + 1;
				}
				info_ij = al_cons(info, al_cons(i, al_cons(j, null)));
				al_append(itr, info_ij, "$select");
				break;
			}
			if (al_addr_eq(info_ij.head, info)) {
				al_remove(itr);
				break;
			} else {
			}
		}
		Glyph::Damage(info.left, info.top, info.right, info.bottom);
		return 1;
	} else {
	}
	return null;
}
end_body
member
public: Glyph glyph;
member
public: TMGlyph info;
member
public: void InsertRow();
body
{
	var list info_ij;
	if (info_ij = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	var integer row, col;
	row = info_ij.tail.head;
	col = info_ij.tail.tail.head;
	InsertRow(row, default_height, "");
	Glyph::AllocationChanged(this);
	Damage();
	MakeSpaceIndex();
}
end_body
member
public: void InsertColumn();
body
{
	var list info_ij;
	if (info_ij = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	var integer row, col;
	row = info_ij.tail.head;
	col = info_ij.tail.tail.head;
	InsertColumn(col, default_width, "");
	Glyph::AllocationChanged(this);
	Damage();
	MakeSpaceIndex();
}
end_body
member
public: void AppendRow();
body
{
	var list info_ij;
	if (info_ij = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	var integer row, col;
	row = info_ij.tail.head;
	col = info_ij.tail.tail.head;
	InsertRow(row + 1, default_height, "");
	Glyph::AllocationChanged(this);
	Damage();
	MakeSpaceIndex();
}
end_body
member
public: void AppendColumn();
body
{
	var list info_ij;
	if (info_ij = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	var integer row, col;
	row = info_ij.tail.head;
	col = info_ij.tail.tail.head;
	InsertColumn(col + 1, default_width, "");
	Glyph::AllocationChanged(this);
	Damage();
	MakeSpaceIndex();
}
end_body
member
public: void DeleteRow();
body
{
	var list info_ij;
	if (info_ij = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	selection = al_cons(null, null);
	var integer row, col;
	row = info_ij.tail.head;
	col = info_ij.tail.tail.head;
	Damage();
	DeleteRow(row);
	Glyph::AllocationChanged(this);
	MakeSpaceIndex();
}
end_body
member
public: void DeleteColumn();
body
{
	var list info_ij;
	if (info_ij = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	selection = al_cons(null, null);
	var integer row, col;
	row = info_ij.tail.head;
	col = info_ij.tail.tail.head;
	Damage();
	DeleteColumn(col);
	Glyph::AllocationChanged(this);
	MakeSpaceIndex();
}
end_body
member
public: void Cell(integer row, integer col, Glyph g);
body
{
	var list row_frame, cell_frame;
	var TMGlyph info;
	var integer width, height;
	row_frame = al_dst_node(cells, row);
	cell_frame = al_dst_node(row_frame, col);
	height = row_frame.head;
	width = cell_frame.head;
	info = cell_frame.tail.head;
	g.Resize(0, 0, width, height);
	info.child = g;
}
end_body
member
public: Glyph Cell(integer row, integer col);
body
{
	var list row_frame, cell_frame;
	var TMGlyph info;
	row_frame = al_dst_node(cells, row);
	cell_frame = al_dst_node(row_frame, col);
	info = cell_frame.tail.head;
	return info.child;
}
end_body
member
public: void RowHeight(integer row, integer height);
body
{
	if (row < 1 || nrow < row) {
		return;
	} else {
	}
	var list itr2, row_frame, cell_frame;
	var TMGlyph info;
	var integer h;
	row_frame = al_dst_node(cells, row);
	h = row_frame.head;
	row_frame.head = height;
	itr2 = al_dst_itr(row_frame);
	loop {
		if (cell_frame = al_next(itr2)) {
		} else {
			break;
		}
		info = cell_frame.tail.head;
		info.Resize(info.left, info.top, info.right, info.top + height);
	}
	_ShiftTB(row + 1, height - h, 0);
	Damage();
	bottom = bottom - h + height;
	child.Resize(this);
	Glyph::AllocationChanged(this);
	Damage();
	MakeSpaceIndex();
}
end_body
member
public: void ColumnWidth(integer col, integer width);
body
{
	if (col < 1 || ncol < col) {
		return;
	} else {
	}
	var list itr1, row_frame, cell_frame;
	var TMGlyph info;
	var integer w;
	itr1 = al_dst_itr(cells);
	loop {
		if (row_frame = al_next(itr1)) {
		} else {
			break;
		}
		cell_frame = al_dst_node(row_frame, col);
		w = cell_frame.head;
		cell_frame.head = width;
		info = cell_frame.tail.head;
		info.Resize(info.left, info.top, info.left + width, info.bottom);
	}
	_ShiftLR(col + 1, width - w, 0);
	Damage();
	right = right - w + width;
	child.Resize(this);
	Glyph::AllocationChanged(this);
	Damage();
	MakeSpaceIndex();
}
end_body
member
public: integer RowHeight(integer row);
body
{
	var list row_frame;
	row_frame = al_dst_node(cells, row);
	return row_frame.head;
}
end_body
member
public: integer ColumnWidth(integer col);
body
{
	var list row_frame, cell_frame;
	row_frame = al_dst_node(cells, 1);
	cell_frame = al_dst_node(row_frame, col);
	return cell_frame.head;
}
end_body
member
public: void InsertRow(integer row, integer height, string s);
body
{
	if (row < 1 || nrow + 1 < row) {
		return;
	} else {
	}
	var list itr1, itr2, row_frame0, cell_frame0, row_frame, cell_frame;
	var integer j, w, x, y;
	var Glyph g;
	var TMGlyph info;
	row_frame0 = al_dst_node(cells, 1);
	_ShiftTB(row, height, 1);
	row_frame = al_cons(height, null);
	itr1 = al_dst_itr(cells);
	al_next_a(itr1, row + 1);
	al_insert(itr1, row_frame, row);
	itr2 = al_dst_itr(row_frame0);
	x = 0;
	y = VPosition(row - 1);
	j = 1;
	loop {
		if (cell_frame0 = al_next(itr2)) {
		} else {
			break;
		}
		w = cell_frame0.head;
		g = DefaultCell(w, height, s);
		info = child.Append(g, x, y);
		cell_frame = al_cons(w, al_cons(info, null));
		al_create_arc(row_frame, cell_frame, j);
		x = x + w;
		j = j + 1;
	}
	nrow = nrow + 1;
	bottom = bottom + height;
	child.Resize(this);
	AllocationChanged(this);
}
end_body
member
public: void InsertColumn(integer col, integer width, string s);
body
{
	if (col < 1 || ncol + 1 < col) {
		return;
	} else {
	}
	var list itr1, itr2, cell_frame0, row_frame, cell_frame;
	var integer h, x, y;
	var Glyph g;
	var TMGlyph info;
	_ShiftLR(col, width, 1);
	itr1 = al_dst_itr(cells);
	x = HPosition(col - 1);
	y = 0;
	loop {
		if (row_frame = al_next(itr1)) {
		} else {
			break;
		}
		h = row_frame.head;
		g = DefaultCell(width, default_height, s);
		info = child.Append(g, x, y);
		cell_frame = al_cons(width, al_cons(info, null));
		itr2 = al_dst_itr(row_frame);
		al_next_a(itr2, col + 1);
		al_insert(itr2, cell_frame, col);
		y = y + h;
	}
	ncol = ncol + 1;
	right = right + width;
	child.Resize(this);
	AllocationChanged(this);
}
end_body
member
public: void DeleteRow(integer row);
body
{
	if (row < 1 || nrow < row || nrow == 1) {
		return;
	} else {
	}
	var list itr1, itr2, row_frame, cell_frame;
	var integer h;
	var TMGlyph info;
	itr1 = al_dst_itr(cells);
	row_frame = al_next_a(itr1, row);
	h = row_frame.head;
	itr2 = al_dst_itr(row_frame);
	loop {
		if (cell_frame = al_next(itr2)) {
		} else {
			break;
		}
		info = cell_frame.tail.head;
		child.Remove(info);
	}
	al_remove(itr1);
	_ShiftTB(row + 1,  - h, -1);
	nrow = nrow - 1;
	bottom = bottom - h;
	child.Resize(this);
	AllocationChanged(this);
}
end_body
member
public: void DeleteColumn(integer col);
body
{
	if (col < 1 || ncol < col || ncol == 1) {
		return;
	} else {
	}
	var list itr1, itr2, row_frame, cell_frame;
	var integer w;
	var TMGlyph info;
	itr1 = al_dst_itr(cells);
	loop {
		if (row_frame = al_next(itr1)) {
		} else {
			break;
		}
		itr2 = al_dst_itr(row_frame);
		cell_frame = al_next_a(itr2, col);
		w = cell_frame.head;
		info = cell_frame.tail.head;
		child.Remove(info);
		al_remove(itr2);
	}
	_ShiftLR(col + 1,  - w, -1);
	ncol = ncol - 1;
	right = right - w;
	child.Resize(this);
	AllocationChanged(this);
}
end_body
member
public: Glyph DefaultCell(integer width, integer height, string s);
body
{
	var LabelGlyph l;
	l = new MLabel;
	l.Create(0, 0, width, height, s);
	return l;
}
end_body
member
public: integer VPosition(integer row);
body
{
	var list itr1, row_frame;
	var integer i, h, y;
	itr1 = al_dst_itr(cells);
	i = 1;
	y = 0;
	loop {
		if (i > row) {
			break;
		} else {
		}
		row_frame = al_next(itr1);
		h = row_frame.head;
		y = y + h;
		i = i + 1;
	}
	return top + y;
}
end_body
member
public: integer HPosition(integer col);
body
{
	var list itr2, row_frame, cell_frame;
	var integer j, w, x;
	row_frame = al_dst_node(cells, 1);
	itr2 = al_dst_itr(row_frame);
	j = 1;
	x = 0;
	loop {
		if (j > col) {
			break;
		} else {
		}
		cell_frame = al_next(itr2);
		w = cell_frame.head;
		x = x + w;
		j = j + 1;
	}
	return left + x;
}
end_body
member
public: void _ShiftLR(integer col, integer dx, integer d_idx);
body
{
	if (col > ncol) {
		return;
	} else {
	}
	var list itr1, itr2, row_frame, cell_frame;
	var TMGlyph info;
	var matrix tm1;
	itr1 = al_dst_itr(cells);
	loop {
		if (row_frame = al_next(itr1)) {
		} else {
			break;
		}
		itr2 = al_dst_itr(row_frame);
		al_next_a(itr2, col);
		loop {
			if (cell_frame = al_component(itr2)) {
			} else {
				break;
			}
			info = cell_frame.tail.head;
			info.Move(dx, 0);
			al_set_arc_a(itr2, al_arc_a(itr2) + d_idx);
			al_next(itr2);
		}
	}
}
end_body
member
public: void _ShiftTB(integer row, integer dy, integer d_idx);
body
{
	if (row > nrow) {
		return;
	} else {
	}
	var list itr1, itr2, row_frame, cell_frame;
	var TMGlyph info;
	var matrix tm1;
	itr1 = al_dst_itr(cells);
	al_next_a(itr1, row);
	loop {
		if (row_frame = al_component(itr1)) {
		} else {
			break;
		}
		itr2 = al_dst_itr(row_frame);
		loop {
			if (cell_frame = al_next(itr2)) {
			} else {
				break;
			}
			info = cell_frame.tail.head;
			info.Move(0, dy);
		}
		al_set_arc_a(itr1, al_arc_a(itr1) + d_idx);
		al_next(itr1);
	}
}
end_body
member
public: integer nrow;
member
public: integer ncol;
member
public: list cells;
member
public: list _BeginVLineDrag(Hit h);
body
{
	h.root.grab = this;
	var list info;
	info = h.info;
	drag_line_index = info.tail.head;
	_tm = h.tm;
	_x0 = _l = _r = HPosition(drag_line_index);
	_t = top;
	_b = VPosition(nrow);
	DrawRBand(h.wnd, _tm, _l, _t, _r, _b);
	return 1;
}
end_body
member
public: list _VLineDrag(Hit h);
body
{
	DrawRBand(h.wnd, _tm, _l, _t, _r, _b);
	var list xy1;
	xy1 = al_inverse_xy(_tm, h.event.tail.head, h.event.tail.tail.head);
	_l = _r = xy1.head;
	DrawRBand(h.wnd, _tm, _l, _t, _r, _b);
	return 1;
}
end_body
member
public: list _EndVLineDrag(Hit h);
body
{
	h.root.grab = null;
	DrawRBand(h.wnd, _tm, _l, _t, _r, _b);
	var integer width1, width2;
	width1 = ColumnWidth(drag_line_index);
	width2 = width1 + _l - _x0;
	if (al_abs(width2 - width1) > 1) {
		ColumnWidth(drag_line_index, width2);
	} else {
	}
	_tm = null;
	_x0 = _l = _t = _r = _b = null;
	return 1;
}
end_body
member
public: list _BeginHLineDrag(Hit h);
body
{
	h.root.grab = this;
	var list info;
	info = h.info;
	drag_line_index = info.tail.head;
	_tm = h.tm;
	_y0 = _t = _b = VPosition(drag_line_index);
	_l = left;
	_r = HPosition(ncol);
	DrawRBand(h.wnd, _tm, _l, _t, _r, _b);
	return 1;
}
end_body
member
public: list _HLineDrag(Hit h);
body
{
	DrawRBand(h.wnd, _tm, _l, _t, _r, _b);
	var list xy1;
	xy1 = al_inverse_xy(_tm, h.event.tail.head, h.event.tail.tail.head);
	_t = _b = xy1.tail.head;
	DrawRBand(h.wnd, _tm, _l, _t, _r, _b);
	return 1;
}
end_body
member
public: list _EndHLineDrag(Hit h);
body
{
	h.root.grab = null;
	DrawRBand(h.wnd, _tm, _l, _t, _r, _b);
	var integer height1, height2;
	height1 = RowHeight(drag_line_index);
	height2 = height1 + _t - _y0;
	if (al_abs(height2 - height1) > 1) {
		RowHeight(drag_line_index, height2);
	} else {
	}
	_tm = null;
	_y0 = _l = _t = _r = _b = null;
	return 1;
}
end_body
member
public: integer drag_line_index;
member
public: void DrawRBand(window w, matrix tm, integer x1, integer y1, integer x2, integer y2);
body
{
	al_start_quick_draw(w);
	al_push_color_func(w, 2);
	al_push_pen(w, "Solid", 0, 0xffffff);
	al_push_brush(w, "Null", 0x0, null);
	al_push_tm(w, tm);
	al_line(w, x1, y1, x2, y2);
	al_pop_tm(w);
	al_pop_brush(w);
	al_pop_pen(w);
	al_pop_color_func(w);
	al_end_quick_draw(w);
}
end_body
member
public: integer Save(file f);
body
{
	var list data, result;
	child.ClearSpaceIndex();
	data = al_list5(nrow, ncol, cells, selection, child);
	result = al_file_write(f, "graph", data);
	child.MakeSpaceIndex();
	return result;
}
end_body
member
public: integer Load(file f);
body
{
	var list data;
	if (data = al_file_read(f, "graph")) {
	} else {
		return 1;
	}
	nrow = data.head;
	ncol = data.tail.head;
	cells = data.tail.tail.head;
	selection = data.tail.tail.tail.head;
	child = data.tail.tail.tail.tail.head;
	child.MakeSpaceIndex();
	Glyph::Resize(child);
	return null;
}
end_body
member
public: list GbCode(list pif);
body
{
	var string file_name;
	if (file_name = al_dst_node(this, "$editor_id")) {
	} else {
		return 1;
	}
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var TableEditor pp;"));
	err = (err || GbCode(pif, "pp = new TableEditor;"));
	err = (err || GbCode(pif, "pp.Create(1, 1, 60, 20, \"\");"));
	err = (err || GbCode(pif, "var file f;"));
	err = (err || GbCode(pif, "if (f = al_file_open(GUIbuilder::GetPath() + \"/\\" + file_name + "\", \"r\")) {"));
	err = (err || GbCode(pif, "pp.Load(f);"));
	err = (err || GbCode(pif, "f = null;"));
	err = (err || GbCode(pif, "} else {"));
	err = (err || GbCode(pif, "}"));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
member
public: void ClearRecords();
body
{
	Damage();
	var integer i;
	i = nrow;
	loop {
		if (i > 1) {
		} else {
			break;
		}
		DeleteRow(i);
		i = i - 1;
	}
}
end_body
member
public: void AddRecord(list rec);
body
{
	InsertRow(nrow + 1, default_height, "");
	var integer j;
	var LabelGlyph lab;
	var list value;
	j = 1;
	loop {
		if (j <= ncol) {
		} else {
			break;
		}
		lab = Cell(1, j);
		if (value = al_dst_node(rec, lab.text)) {
			lab = Cell(nrow, j);
			lab.text = (string)value;
		} else {
		}
		j = j + 1;
	}
	Damage();
}
end_body
member
public: void public_var();
body
{
	nrow;
	ncol;
}
end_body
member
public: void public_func();
body
{
	Create((integer)null, (integer)null, (integer)null, (integer)null, (string)null);
	Cell((integer)null, (integer)null, (Glyph)null);
	Cell((integer)null, (integer)null);
	RowHeight((integer)null, (integer)null);
	RowHeight((integer)null);
	ColumnWidth((integer)null, (integer)null);
	ColumnWidth((integer)null);
	InsertRow((integer)null, (integer)null, (string)null);
	DeleteRow((integer)null);
	InsertColumn((integer)null, (integer)null, (string)null);
	DeleteColumn((integer)null);
	ClearRecords();
	AddRecord(null);
}
end_body
end_class
class HierEditor
member
public: void Create();
body
{
	Glyph::Create();
	indent_width = 20;
	icon_color = 0xffffff;
	child = new SpIdxGlyph;
	tree_root = __CreateOneItem(DefaultIcon(), "", 0, 0);
	var TMGlyph icon_info, title_info;
	icon_info = tree_root.head;
	title_info = tree_root.tail.head;
	Editor::Resize(icon_info.left, icon_info.top, title_info.right, icon_info.bottom);
	selection = al_cons(null, null);
	status = Status::Edit;
}
end_body
member
public: integer indent_width;
member
public: integer icon_color;
member
public: void Draw(window w);
body
{
	_DrawingArea(w);
	_DrawItems(w);
	_DrawLines(w);
	_DrawSelection(w);
}
end_body
member
public: void _DrawingArea(window w);
body
{
	var list area, itr, pt;
	area = al_intersection(al_damage_rect_poly(w), al_clipping(w));
	area = al_inverse_poly(al_window_tm(w), area);
	itr = al_dst_itr(al_dst_node(area, null));
	s_vpos = 1.e+030;
	e_vpos = -1.e+030;
	loop {
		if (pt = al_next(itr)) {
		} else {
			break;
		}
		s_vpos = al_min(s_vpos, pt.tail.head);
		e_vpos = al_max(e_vpos, pt.tail.head);
	}
}
end_body
member
public: void _DrawItems(window w);
body
{
	var TMGlyph icon_info, title_info;
	var HierEditorNodeItr n_itr;
	n_itr = new HierEditorNodeItr;
	n_itr.ItrReset(this, Root());
	loop {
		icon_info = n_itr.itr_node.head;
		title_info = n_itr.itr_node.tail.head;
		if (icon_info.top > e_vpos) {
			break;
		} else {
		}
		if (icon_info.bottom >= s_vpos) {
			icon_info.Draw(w);
			title_info.Draw(w);
		} else {
		}
		if (n_itr.ItrNext()) {
		} else {
			break;
		}
	}
}
end_body
member
public: void _DrawLines(window w);
body
{
	var TMGlyph icon_info, icon_info2;
	var list node;
	var integer x, y, y2;
	var integer color;
	if (al_get_sys_color(0) != 0x0) {
		color = 0x0;
	} else {
		color = 0xffffff;
	}
	al_push_pen(w, "Solid", 0, color);
	var HierEditorNodeItr n_itr;
	n_itr = new HierEditorNodeItr;
	n_itr.ItrReset(this, Root());
	loop {
		icon_info = n_itr.itr_node.head;
		if (icon_info.top > e_vpos) {
			break;
		} else {
		}
		node = Child(n_itr.itr_node);
		var HierIcon icon;
		icon = icon_info.child;
		if (node && icon.close == null) {
			node = Last(node);
			icon_info2 = node.head;
			x = indent_width * n_itr.itr_indent + icon_info.Width() / 2;
			y = icon_info.bottom;
			y2 = (icon_info2.top + icon_info2.bottom) / 2;
			al_line(w, x, y, x, y2);
		} else {
		}
		if (n_itr.ItrNext()) {
		} else {
			break;
		}
	}
	al_pop_pen(w);
}
end_body
member
public: void _DrawSelection(window w);
body
{
	var list itr, node;
	var TMGlyph icon_info, title_info;
	al_push_color_func(w, 2);
	al_push_pen(w, "Null", 0, 0x0);
	al_push_brush(w, "Solid", 0xffffff, null);
	itr = al_dst_itr(selection);
	loop {
		if (node = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		icon_info = node.head;
		title_info = node.tail.head;
		al_rectangle(w, icon_info.left, icon_info.top, title_info.right, icon_info.bottom);
	}
	al_pop_brush(w);
	al_pop_pen(w);
	al_pop_color_func(w);
}
end_body
member
public: void s_vpos;
member
public: void e_vpos;
member
public: void Pick(Hit h);
body
{
	h.BeginTarget(this, TargetInfo::ParentEditor);
	if (Event::IsMouseEvent((integer)h.event.head)) {
		var integer y;
		var list xy;
		var TMGlyph icon_info, title_info;
		xy = al_inverse_xy(al_window_tm(h.wnd), h.event.tail.head, h.event.tail.tail.head);
		y = xy.tail.head;
		var HierEditorNodeItr n_itr;
		n_itr = new HierEditorNodeItr;
		n_itr.ItrReset(this, Root());
		loop {
			icon_info = n_itr.itr_node.head;
			title_info = n_itr.itr_node.tail.head;
			if (icon_info.top <= y && y <= icon_info.bottom) {
				icon_info.Pick(h);
				title_info.Pick(h);
				break;
			} else {
			}
			if (n_itr.ItrNext()) {
			} else {
				break;
			}
		}
	} else {
		child.Pick(h);
	}
	h.EndTarget();
}
end_body
member
public: void Destroy();
body
{
	click_obj = click_func = null;
}
end_body
member
public: list Execute(Hit h);
body
{
	return Glyph::Execute(h);
}
end_body
member
public: list ExecuteParent(integer msg, Glyph g, Hit h);
body
{
	info = al_src_node(g, "child");
	var list itr, node;
	var TMGlyph info1, info2;
	if (msg == Message::Select) {
		itr = al_dst_itr(selection);
		loop {
			if (node = al_next_a(itr, "$select")) {
			} else {
				break;
			}
			info1 = node.head;
			info2 = node.tail.head;
			Glyph::Damage(info1.left, info1.top, info2.right, info1.bottom);
		}
		selection = al_cons(null, null);
		var HierEditorNodeItr n_itr;
		n_itr = new HierEditorNodeItr;
		n_itr.ItrReset(this, Root());
		loop {
			info1 = n_itr.itr_node.head;
			info2 = n_itr.itr_node.tail.head;
			if (al_addr_eq(info1, info) || al_addr_eq(info2, info)) {
				al_create_arc(selection, n_itr.itr_node, "$select");
				Glyph::Damage(info1.left, info1.top, info2.right, info1.bottom);
				break;
			} else {
			}
			if (n_itr.ItrNext()) {
			} else {
				break;
			}
		}
		Glyph::Damage(info1.left, info1.top, info2.right, info1.bottom);
		return 1;
	} else {
	}
	if (msg == Message::XorSelect) {
		itr = al_dst_itr(selection);
		loop {
			if (node = al_next_a(itr, "$select")) {
			} else {
				var HierEditorNodeItr n_itr;
				n_itr = new HierEditorNodeItr;
				n_itr.ItrReset(this, Root());
				loop {
					info1 = n_itr.itr_node.head;
					info2 = n_itr.itr_node.tail.head;
					if (al_addr_eq(info1, info) || al_addr_eq(info2, info)) {
						break;
					} else {
					}
					if (n_itr.ItrNext()) {
					} else {
						break;
					}
				}
				al_append(itr, n_itr.itr_node, "$select");
				break;
			}
			info1 = node.head;
			info2 = node.tail.head;
			if (al_addr_eq(info1, info) || al_addr_eq(info2, info)) {
				al_remove(itr);
				break;
			} else {
			}
		}
		Glyph::Damage(info1.left, info1.top, info2.right, info1.bottom);
		return 1;
	} else {
	}
	return null;
}
end_body
member
public: Glyph glyph;
member
public: TMGlyph info;
member
public: void CreateChild();
body
{
	var list node;
	if (node = al_dst_node(selection, "$select")) {
		CreateChild(node);
		Damage();
	} else {
	}
}
end_body
member
public: void CreateBrother();
body
{
	var list node;
	if (node = al_dst_node(selection, "$select")) {
		CreateBrother(node);
		Damage();
	} else {
	}
}
end_body
member
public: void CreateElderBrother();
body
{
	var list node;
	if (node = al_dst_node(selection, "$select")) {
		CreateEdlerBrother(node);
		Damage();
	} else {
	}
}
end_body
member
public: void Up();
body
{
	var list node;
	if (node = al_dst_node(selection, "$select")) {
		Up(node);
		Damage();
	} else {
	}
}
end_body
member
public: void Down();
body
{
	var list node;
	if (node = al_dst_node(selection, "$select")) {
		Down(node);
		Damage();
	} else {
	}
}
end_body
member
public: void Left();
body
{
	var list itr, node;
	itr = al_dst_itr(selection);
	loop {
		if (node = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		Left(node);
	}
	Damage();
}
end_body
member
public: void Right();
body
{
	var list itr, node;
	itr = al_dst_itr(selection);
	loop {
		if (node = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		Right(node);
	}
	Damage();
}
end_body
member
public: void Delete();
body
{
	var list node;
	node = al_dst_node(selection, "$select");
	if (node && node != tree_root) {
		al_remove_from(selection, node, "$select");
		Damage();
		Delete(node);
		Glyph::AllocationChanged(this);
	} else {
	}
}
end_body
member
public: list CreateChild(list node);
body
{
	var HierIcon icon;
	var TMGlyph icon_info, title_info;
	var list node2, node3;
	var integer x, y, height;
	icon = DefaultIcon();
	height = icon.Height();
	var HierEditorNodeItr n_itr;
	n_itr = new HierEditorNodeItr;
	n_itr.ItrReset(this, Root());
	loop {
		if (al_addr_eq(n_itr.itr_node, node)) {
			break;
		} else {
		}
		if (n_itr.ItrNext()) {
		} else {
			break;
		}
	}
	icon_info = node.head;
	x = indent_width * (n_itr.itr_indent + 1);
	y = icon_info.bottom;
	node2 = __CreateOneItem(icon, "", x, y);
	if (node3 = Child(node)) {
		al_insert_before(node, node3, node2, "$hier");
	} else {
		al_create_arc(node, node2, "$hier");
	}
	n_itr.ItrNext();
	loop {
		if (n_itr.ItrNext()) {
		} else {
			break;
		}
		icon_info = n_itr.itr_node.head;
		title_info = n_itr.itr_node.tail.head;
		icon_info.Move(0, height);
		title_info.Move(0, height);
	}
	bottom = bottom + height;
	child.Resize(this);
	AllocationChanged(this);
	return node2;
}
end_body
member
public: list CreateBrother(list node);
body
{
	var list parent;
	if (parent = Parent(node)) {
	} else {
		return null;
	}
	var HierIcon icon;
	var TMGlyph icon_info, title_info;
	var list node2;
	var integer x, y, height;
	icon = DefaultIcon();
	height = icon.Height();
	var HierEditorNodeItr n_itr;
	n_itr = new HierEditorNodeItr;
	n_itr.ItrReset(this, Root());
	loop {
		if (al_addr_eq(n_itr.itr_node, node)) {
			break;
		} else {
		}
		if (n_itr.ItrNext()) {
		} else {
			break;
		}
	}
	icon_info = node.head;
	x = indent_width * n_itr.itr_indent;
	y = icon_info.top;
	node2 = __CreateOneItem(icon, "", x, y + _WholeHeight(node));
	al_append_after(parent, node, node2, "$hier");
	n_itr.ItrReset(this, Root());
	loop {
		if (al_addr_eq(n_itr.itr_node, node2)) {
			break;
		} else {
		}
		if (n_itr.ItrNext()) {
		} else {
			al_print("not found\n");
			break;
		}
	}
	loop {
		if (n_itr.ItrNext()) {
		} else {
			break;
		}
		icon_info = n_itr.itr_node.head;
		title_info = n_itr.itr_node.tail.head;
		icon_info.Move(0, height);
		title_info.Move(0, height);
	}
	bottom = bottom + height;
	child.Resize(this);
	AllocationChanged(this);
	return node2;
}
end_body
member
public: list CreateEdlerBrother(list node);
body
{
	var list parent;
	if (parent = Parent(node)) {
	} else {
		return null;
	}
	var HierIcon icon;
	var TMGlyph icon_info, title_info;
	var list node2;
	var integer x, y, height;
	icon = DefaultIcon();
	height = icon.Height();
	var HierEditorNodeItr n_itr;
	n_itr = new HierEditorNodeItr;
	n_itr.ItrReset(this, Root());
	loop {
		if (al_addr_eq(n_itr.itr_node, node)) {
			break;
		} else {
		}
		if (n_itr.ItrNext()) {
		} else {
			break;
		}
	}
	icon_info = node.head;
	x = indent_width * n_itr.itr_indent;
	y = icon_info.top;
	node2 = __CreateOneItem(icon, "", x, y);
	al_insert_before(parent, node, node2, "$hier");
	loop {
		icon_info = n_itr.itr_node.head;
		title_info = n_itr.itr_node.tail.head;
		icon_info.Move(0, height);
		title_info.Move(0, height);
		if (n_itr.ItrNext()) {
		} else {
			break;
		}
	}
	bottom = bottom + height;
	child.Resize(this);
	AllocationChanged(this);
	return node2;
}
end_body
member
public: void Adjust();
body
{
	var TMGlyph icon_info, title_info;
	var integer l, t, r, b;
	t = 0;
	var HierEditorNodeItr n_itr;
	n_itr = new HierEditorNodeItr;
	n_itr.ItrReset(this, Root());
	loop {
		icon_info = n_itr.itr_node.head;
		title_info = n_itr.itr_node.tail.head;
		l = indent_width * n_itr.itr_indent;
		r = l + icon_info.Width();
		b = t + icon_info.Height();
		icon_info.Resize(l, t, r, b);
		l = r;
		r = l + title_info.Width();
		title_info.Resize(l, t, r, b);
		child.MakeSpaceIndex(icon_info);
		child.MakeSpaceIndex(title_info);
		t = b;
		if (n_itr.ItrNext()) {
		} else {
			break;
		}
	}
	bottom = top + b;
	child.Resize(this);
	AllocationChanged(this);
}
end_body
member
public: list CreateChild(list node, string s);
body
{
	var HierIcon icon;
	var list node2;
	icon = DefaultIcon();
	node2 = __CreateOneItem(icon, s, 0, 0);
	al_create_arc(node, node2, "$hier");
	return node2;
}
end_body
member
public: list CreateBrother(list node, string s);
body
{
	var list parent;
	if (parent = Parent(node)) {
	} else {
		return null;
	}
	var HierIcon icon;
	icon = DefaultIcon();
	var list node2;
	node2 = __CreateOneItem(icon, s, 0, 0);
	al_append_after(parent, node, node2, "$hier");
	return node2;
}
end_body
member
public: list CreateElderBrother(list node, string s);
body
{
	var list parent;
	if (parent = Parent(node)) {
	} else {
		return null;
	}
	var HierIcon icon;
	icon = DefaultIcon();
	var list node2;
	node2 = __CreateOneItem(icon, s, 0, 0);
	al_insert_before(parent, node, node2, "$hier");
	return node2;
}
end_body
member
public: list __CreateOneItem(Glyph icn, string s, integer x, integer y);
body
{
	var TMGlyph icon_info, title_info;
	icn.Move( - icn.left,  - icn.top);
	icon_info = child.Append(icn, x, y);
	var LabelGlyph lab;
	lab = new LabelGlyph;
	lab.Create(0, 0, 1000, icn.Height(), s);
	title_info = child.Append(lab, x + icn.Width(), y);
	var list node;
	node = al_cons(icon_info, al_cons(title_info, null));
	al_create_arc(node, icn, "$hier_icon");
	return node;
}
end_body
member
public: void Up(list node);
body
{
	var list node2;
	if (node2 = Prev(node)) {
	} else {
		return;
	}
	_Exchange(node2, node);
	MakeSpaceIndex();
}
end_body
member
public: void Down(list node);
body
{
	var list node2;
	if (node2 = Next(node)) {
	} else {
		return;
	}
	_Exchange(node, node2);
	MakeSpaceIndex();
}
end_body
member
public: void Left(list node);
body
{
	var list parent, node2, node3, grandparent;
	parent = Parent(node);
	if (parent == null || al_addr_eq(parent, tree_root)) {
		return;
	} else {
	}
	var TMGlyph icon_info, title_info;
	var HierEditorNodeItr n_itr;
	n_itr = new HierEditorNodeItr;
	n_itr.ItrReset(this, node);
	loop {
		icon_info = n_itr.itr_node.head;
		title_info = n_itr.itr_node.tail.head;
		icon_info.Move( - indent_width, 0);
		title_info.Move( - indent_width, 0);
		if (n_itr.ItrNext()) {
		} else {
			break;
		}
	}
	node2 = Next(node);
	loop {
		if (node2) {
		} else {
			break;
		}
		node3 = Next(node2);
		al_remove_from(parent, node2, "$hier");
		al_create_arc(node, node2, "$hier");
		node2 = node3;
	}
	grandparent = Parent(parent);
	al_remove_from(parent, node, "$hier");
	if (node2 = al_next_dst_node(grandparent, parent, "$hier")) {
		al_insert_before(grandparent, node2, node, "$hier");
	} else {
		al_create_arc(grandparent, node, "$hier");
	}
	MakeSpaceIndex();
}
end_body
member
public: void Right(list node);
body
{
	var list parent, node2;
	parent = Parent(node);
	if (parent == null || al_addr_eq(Child(parent), node)) {
		return;
	} else {
	}
	var TMGlyph icon_info, title_info;
	var HierEditorNodeItr n_itr;
	n_itr = new HierEditorNodeItr;
	n_itr.ItrReset(this, node);
	loop {
		icon_info = n_itr.itr_node.head;
		title_info = n_itr.itr_node.tail.head;
		icon_info.Move(indent_width, 0);
		title_info.Move(indent_width, 0);
		if (n_itr.ItrNext()) {
		} else {
			break;
		}
	}
	node2 = al_prev_dst_node(parent, node, "$hier");
	al_remove_from(parent, node, "$hier");
	al_create_arc(node2, node, "$hier");
	MakeSpaceIndex();
}
end_body
member
public: void Delete(list node);
body
{
	var integer height;
	height = _WholeHeight(node);
	var HierEditorNodeItr n_itr;
	n_itr = new HierEditorNodeItr;
	n_itr.ItrReset(this, Root());
	loop {
		if (al_addr_eq(n_itr.itr_node, node)) {
			break;
		} else {
		}
		if (n_itr.ItrNext()) {
		} else {
			break;
		}
	}
	if (n_itr.ItrNext()) {
		var TMGlyph icon_info, title_info;
		loop {
			icon_info = n_itr.itr_node.head;
			title_info = n_itr.itr_node.tail.head;
			icon_info.Move(0,  - height);
			title_info.Move(0,  - height);
			if (n_itr.ItrNext()) {
			} else {
				break;
			}
		}
	} else {
	}
	al_remove_from(Parent(node), node, "$hier");
	var TMGlyph icon_info, title_info;
	icon_info = node.head;
	title_info = node.tail.head;
	child.Remove(icon_info);
	child.Remove(title_info);
	bottom = bottom - height;
	child.Resize(this);
	AllocationChanged(this);
	selection = al_cons(null, null);
}
end_body
member
public: void DeleteDescendants(list node);
body
{
	var list n;
	loop {
		if (n = Child(node)) {
			Delete(n);
		} else {
			break;
		}
	}
}
end_body
member
public: void _Exchange(list node1, list node2);
body
{
	var integer height1, height2;
	height1 = _WholeHeight(node1);
	height2 = _WholeHeight(node2);
	var TMGlyph icon_info, title_info;
	var HierEditorNodeItr n_itr;
	n_itr = new HierEditorNodeItr;
	n_itr.ItrReset(this, node1);
	loop {
		icon_info = n_itr.itr_node.head;
		title_info = n_itr.itr_node.tail.head;
		icon_info.Move(0, height2);
		title_info.Move(0, height2);
		if (n_itr.ItrNext()) {
		} else {
			break;
		}
	}
	n_itr.ItrReset(this, node2);
	loop {
		icon_info = n_itr.itr_node.head;
		title_info = n_itr.itr_node.tail.head;
		icon_info.Move(0,  - height1);
		title_info.Move(0,  - height1);
		if (n_itr.ItrNext()) {
		} else {
			break;
		}
	}
	var list parent;
	parent = Parent(node1);
	al_remove_from(parent, node1, "$hier");
	al_append_after(parent, node2, node1, "$hier");
}
end_body
member
public: integer _WholeHeight(list node);
body
{
	var integer height;
	height = 0;
	var TMGlyph icon_info;
	var HierEditorNodeItr n_itr;
	n_itr = new HierEditorNodeItr;
	n_itr.ItrReset(this, node);
	loop {
		icon_info = n_itr.itr_node.head;
		height = height + icon_info.Height();
		if (n_itr.ItrNext()) {
		} else {
			break;
		}
	}
	return height;
}
end_body
member
public: HierIcon DefaultIcon();
body
{
	var HierIcon g;
	g = new HierIcon;
	g.Create();
	g.Resize(0, 0, indent_width * 2, 18);
	g.icon_color = icon_color;
	return g;
}
end_body
member
public: list Root();
body
{
	return tree_root;
}
end_body
member
public: list Parent(list node);
body
{
	return al_src_node(node, "$hier");
}
end_body
member
public: list Child(list node);
body
{
	return al_dst_node(node, "$hier");
}
end_body
member
public: list Next(list node);
body
{
	var list parent;
	if (parent = al_src_node(node, "$hier")) {
	} else {
		return null;
	}
	return al_next_dst_node(parent, node, "$hier");
}
end_body
member
public: list Prev(list node);
body
{
	var list parent;
	if (parent = al_src_node(node, "$hier")) {
	} else {
		return null;
	}
	return al_prev_dst_node(parent, node, "$hier");
}
end_body
member
public: list Last(list node);
body
{
	var list parent, node2;
	if (parent = al_src_node(node, "$hier")) {
	} else {
		return node;
	}
	loop {
		if (node2 = al_next_dst_node(parent, node, "$hier")) {
		} else {
			break;
		}
		node = node2;
	}
	return node;
}
end_body
member
public: list LastLast(list node);
body
{
	var list node2;
	loop {
		if (node2 = Next(node)) {
			node = node2;
			continue;
		} else {
		}
		if (node2 = Child(node)) {
			node = node2;
			continue;
		} else {
		}
		return node;
	}
}
end_body
member
public: list tree_root;
member
public: integer Save(file f);
body
{
	var list data, result;
	child.ClearSpaceIndex();
	data = al_list3(tree_root, selection, child);
	result = al_file_write(f, "graph", data);
	child.MakeSpaceIndex();
	return result;
}
end_body
member
public: integer Load(file f);
body
{
	var list data;
	if (data = al_file_read(f, "graph")) {
	} else {
		return 1;
	}
	tree_root = data.head;
	selection = data.tail.head;
	child = data.tail.tail.head;
	child.MakeSpaceIndex();
	Glyph::Resize(child);
	return null;
}
end_body
member
public: list GbCode(list pif);
body
{
	var string file_name;
	if (file_name = al_dst_node(this, "$editor_id")) {
	} else {
		return 1;
	}
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var HierEditor pp;"));
	err = (err || GbCode(pif, "pp = new HierEditor;"));
	err = (err || GbCode(pif, "pp.Create();"));
	err = (err || GbCode(pif, "var file f;"));
	err = (err || GbCode(pif, "if (f = al_file_open(GUIbuilder::GetPath() + \"/\\" + file_name + "\", \"r\")) {"));
	err = (err || GbCode(pif, "pp.Load(f);"));
	err = (err || GbCode(pif, "f = null;"));
	err = (err || GbCode(pif, "} else {"));
	err = (err || GbCode(pif, "}"));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
member
public: list GetSelectedNode();
body
{
	return al_dst_node(selection, "$select");
}
end_body
member
public: void public_func();
body
{
	Create();
	GetSelectedNode();
	CreateChild(null);
	CreateBrother(null);
	CreateEdlerBrother(null);
	Up(null);
	Down(null);
	Left(null);
	Right(null);
	Delete(null);
	Parent(null);
	Child(null);
	Next(null);
	Prev(null);
	Last(null);
	LastLast(null);
}
end_body
member
public: HierIcon GetIcon(list node);
body
{
	var TMGlyph icon_info;
	icon_info = node.head;
	return icon_info.child;
}
end_body
member
public: LabelGlyph GetTitle(list node);
body
{
	var TMGlyph title_info;
	title_info = node.tail.head;
	return title_info.child;
}
end_body
member
public: list FindNext(list node, string str);
body
{
	var HierEditorNodeItr n_itr;
	n_itr = new HierEditorNodeItr;
	n_itr.all = 1;
	n_itr.ItrReset(this, Root());
	loop {
		if (al_addr_eq(n_itr.itr_node, node)) {
			break;
		} else {
		}
		if (n_itr.ItrNext()) {
		} else {
			return null;
		}
	}
	var LabelGlyph lab;
	loop {
		if (n_itr.ItrNext()) {
		} else {
			return null;
		}
		lab = GetTitle(n_itr.itr_node);
		if (al_search_str(lab.text, 0, str) >= 0) {
			return n_itr.itr_node;
		} else {
		}
	}
}
end_body
member
public: void SetSelection(list node);
body
{
	selection = al_cons(null, null);
	al_create_arc(selection, node, "$select");
}
end_body
member
public: integer GetPos(list node);
body
{
	var TMGlyph info;
	info = node.head;
	return info.top;
}
end_body
member
public: void SetClickCallback(GUI obj, GUIfunc1 func);
body
{
	click_obj = obj;
	click_func = func;
}
end_body
member
public: GUI click_obj;
member
public: GUIfunc1 click_func;
class HierEditorNodeItr
member
public: void ItrReset(HierEditor hier, list node);
body
{
	this.hier = hier;
	itr_indent = 0;
	itr_root = itr_node = node;
	itr_parent = hier.Parent(node);
}
end_body
member
public: list ItrNext();
body
{
	var list node;
	var TMGlyph icon_info;
	var HierIcon icon;
	icon_info = itr_node.head;
	icon = icon_info.child;
	if (all || icon.close == null) {
		if (node = hier.Child(itr_node)) {
			itr_indent = itr_indent + 1;
			itr_node = node;
			return 1;
		} else {
		}
	} else {
	}
	var list parent;
	parent = hier.Parent(itr_node);
	if (al_addr_eq(parent, itr_parent)) {
		return null;
	} else {
	}
	if (node = hier.Next(itr_node)) {
		itr_node = node;
		return 1;
	} else {
	}
	loop {
		itr_indent = itr_indent - 1;
		parent = hier.Parent(itr_node);
		if (parent == null || al_addr_eq(parent, itr_root)) {
			return null;
		} else {
		}
		if (node = hier.Next(parent)) {
			itr_node = node;
			return 1;
		} else {
		}
		itr_node = parent;
	}
}
end_body
member
public: HierEditor hier;
member
public: list itr_indent;
member
public: list itr_root;
member
public: list itr_parent;
member
public: list itr_node;
member
public: list all;
end_class
end_class
class TextEditor
member
public: void Create();
body
{
	Glyph::Create();
	status = Status::Edit;
	Glyph::Resize(0, 0, 8000, 40000);
	text = al_copy("");
	al_insert_char(text, 0, 0xa);
	lines = al_cons(null, null);
	if (al_misc("platform", null, null) == "windows") {
		font = al_list7("lr SVbN", 12, 0, 0x0, 0, 0, 0);
	} else {
	}
	if (al_misc("platform", null, null) == "linux" || al_misc("platform", null, null) == "mac") {
		font = al_list7("-*-*-medium-r-normal-*-14-*-*-*-*-*-*-*,*", 12, 0, 0x0, 0, 0, 0);
	} else {
	}
	pitch = 2;
	from_pos = from_line_pos = from_line_vpos = 0;
	to_pos = to_line_pos = to_line_vpos = 0;
	from_line = to_line = al_cons(0, null);
	al_create_arc(lines, from_line, null);
	up_down_hpos = 0;
	// debug = 1;
}
end_body
member
public: void Resize(integer l, integer t, integer r, integer b);
body
{
	Glyph::Resize(l, t, r, b);
}
end_body
member
public: void Destroy();
body
{
	_obj = _func = null;
	Editor::Destroy();
}
end_body
member
public: string text;
member
public: list lines;
member
public: list font;
member
public: integer pitch;
member
public: integer from_pos;
member
public: integer from_line_pos;
member
public: integer from_line_vpos;
member
public: list from_line;
member
public: integer to_pos;
member
public: integer to_line_pos;
member
public: integer to_line_vpos;
member
public: list to_line;
member
public: void SelFromXY(Hit h);
body
{
	var integer x, y;
	var list xy;
	x = h.event.tail.head;
	y = h.event.tail.tail.head;
	xy = al_inverse_xy(h.tm, x, y);
	x = xy.head - 5;
	y = xy.tail.head;
	var list line;
	sel_line_pos = sel_line_vpos = 0;
	sel_line = al_dst_node(lines, null);
	loop {
		if (sel_line_vpos + font.tail.head + pitch < y) {
		} else {
			break;
		}
		line = al_next_dst_node(lines, sel_line, null);
		if (line == null) {
			break;
		} else {
		}
		sel_line_pos = sel_line_pos + sel_line.head + 1;
		sel_line_vpos = sel_line_vpos + font.tail.head + pitch;
		sel_line = line;
	}
	PosFromX(h, sel_line_pos, sel_line, x);
}
end_body
member
public: void PosFromX(Hit h, integer line_pos, list line, integer x);
body
{
	al_push_font_ex(h.wnd, font);
	var integer ch, num, hpos;
	var list wh;
	sel_pos = line_pos;
	loop {
		if (sel_pos < line_pos + line.head) {
		} else {
			break;
		}
		ch = al_get_char(text, sel_pos);
		if (al_is_normal_char(ch)) {
			num = 1;
		} else {
			if (al_is_first_char(ch)) {
				num = 2;
			} else {
				al_print("PosFromX: There is an illegal character.\n");
				break;
			}
		}
		wh = al_text_width_from_to(h.wnd, text, line_pos, sel_pos + num);
		hpos = wh.head;
		if (hpos < x) {
		} else {
			break;
		}
		sel_pos = sel_pos + num;
	}
	al_pop_font(h.wnd);
}
end_body
member
public: integer sel_pos;
member
public: integer sel_line_pos;
member
public: integer sel_line_vpos;
member
public: list sel_line;
member
public: integer up_down_hpos;
member
public: matrix tm;
member
public: void Draw(window w);
body
{
	if (no_redraw) {
		return;
	} else {
	}
	if (font_color_checked) {
	} else {
		var integer color;
		color = font.tail.tail.tail.head;
		if (al_get_sys_color(0) == color) {
			font.tail.tail.tail.head =  ~ color & 0xffffff;
		} else {
		}
		font_color_checked = 1;
	}
	tm = al_window_tm(w);
	wnd = w;
	_DrawingArea(w);
	_DrawText(w);
	_DrawSelection(w);
}
end_body
member
public: list font_color_checked;
member
public: void _DrawingArea(window w);
body
{
	var list area, itr, pt;
	var integer t, b;
	area = al_intersection(al_damage_rect_poly(w), al_clipping(w));
	area = al_inverse_poly(al_translate_tm(left, top) * al_window_tm(w), area);
	itr = al_dst_itr(al_dst_node(area, null));
	t = 1.e+030;
	b = -1.e+030;
	loop {
		if (pt = al_next(itr)) {
		} else {
			break;
		}
		t = al_min(t, pt.tail.head);
		b = al_max(b, pt.tail.head);
	}
	var list flag, line, line2;
	var integer pos, vpos;
	s_line = null;
	flag = 1;
	pos = 0;
	vpos = 0;
	line = al_dst_node(lines, null);
	loop {
		if (flag && t <= vpos + font.tail.head + pitch) {
			s_pos = pos;
			s_vpos = vpos;
			s_line = line;
			flag = null;
		} else {
		}
		pos = pos + line.head + 1;
		vpos = vpos + font.tail.head + pitch;
		line2 = al_next_dst_node(lines, line, null);
		if (b <= vpos || line2 == null) {
			e_line = line;
			break;
		} else {
		}
		line = line2;
	}
}
end_body
member
public: void _DrawText(window w);
body
{
	if (s_line) {
	} else {
		return;
	}
	al_push_font_ex(w, font);
	loop {
		al_text_from_to(w, 5, s_vpos, text, s_pos, s_pos + s_line.head);
		s_pos = s_pos + s_line.head + 1;
		s_vpos = s_vpos + font.tail.head + pitch;
		if (al_addr_eq(s_line, e_line)) {
			break;
		} else {
		}
		s_line = al_next_dst_node(lines, s_line, null);
	}
	al_pop_font(w);
	s_pos = s_vpos = s_line = e_line = null;
}
end_body
member
public: void _DrawSelection(window w);
body
{
	var list wh;
	var integer from_hpos, to_hpos, vpos, hpos;
	al_push_font_ex(w, font);
	wh = al_text_width_from_to(w, text, from_line_pos, from_pos);
	from_hpos = wh.head;
	wh = al_text_width_from_to(w, text, to_line_pos, to_pos);
	to_hpos = wh.head;
	vpos = from_line_vpos;
	if (from_pos == to_pos) {
		al_push_color_func(w, 2);
		al_push_pen(w, "Solid", 0, 0xffffff);
		al_line(w, from_hpos + 5, vpos, from_hpos + 5, vpos + font.tail.head);
		al_pop_pen(w);
		al_pop_color_func(w);
		al_pop_font(w);
		return;
	} else {
		al_push_color_func(w, 2);
		al_push_brush(w, "Solid", 0xffffff, null);
		vpos = from_line_vpos;
		if (al_addr_eq(from_line, to_line)) {
			al_rectangle(w, from_hpos + 5, vpos, to_hpos + 5, vpos + font.tail.head);
		} else {
			var integer pos;
			var list line;
			pos = from_line_pos;
			line = from_line;
			wh = al_text_width_from_to(w, text, pos, pos + line.head);
			hpos = wh.head;
			al_rectangle(w, from_hpos + 5, vpos, hpos + 5, vpos + font.tail.head);
			pos = pos + line.head + 1;
			vpos = vpos + font.tail.head + pitch;
			loop {
				line = al_next_dst_node(lines, line, null);
				if (al_addr_eq(line, to_line)) {
					break;
				} else {
				}
				wh = al_text_width_from_to(w, text, pos, pos + line.head);
				hpos = wh.head;
				al_rectangle(w, 5, vpos, hpos + 5, vpos + font.tail.head);
				pos = pos + line.head + 1;
				vpos = vpos + font.tail.head + pitch;
			}
			al_rectangle(w, 5, vpos, to_hpos + 5, vpos + font.tail.head);
		}
		al_pop_brush(w);
		al_pop_color_func(w);
	}
	al_pop_font(w);
}
end_body
member
public: integer s_pos;
member
public: integer s_vpos;
member
public: list s_line;
member
public: list e_line;
member
public: list Execute(Hit h);
body
{
	wnd = h.wnd;
	var integer type, code, modif;
	type = h.event.head;
	code = h.event.tail.tail.tail.head;
	modif = h.event.tail.tail.tail.tail.head;
	if (debug) {
		al_print("eventType = " + (string)type + "\n");
		al_print("code = " + (string)code + "\n");
	} else {
	}
	if (type == Event::LeftPress && modif != 0x2) {
		if (_BeginDrag(h)) {
			status = Status::Drag;
			return 1;
		} else {
		}
	} else {
	}
	if (type == Event::MouseMove) {
		if (status == Status::Drag && _Drag(h)) {
			return 1;
		} else {
		}
	} else {
	}
	if (type == Event::LeftRelease) {
		if (status == Status::Drag && _EndDrag(h)) {
			status = Status::Edit;
			return 1;
		} else {
		}
	} else {
	}
	if (type == Event::KeyPress) {
		if (status == Status::Edit && code == Event::LeftArrow && _Left(h)) {
			return 1;
		} else {
		}
		if (status == Status::Edit && code == Event::RightArrow && _Right(h)) {
			return 1;
		} else {
		}
		if (status == Status::Edit && code == Event::UpArrow && _Up(h)) {
			return 1;
		} else {
		}
		if (status == Status::Edit && code == Event::DownArrow && _Down(h)) {
			return 1;
		} else {
		}
		if (al_misc("platform", null, null) == "linux" || al_misc("platform", null, null) == "mac") {
			if (status == Status::Edit && al_is_normal_char(code) && _Code(code)) {
				return 1;
			} else {
			}
			if (status == Status::Edit && al_is_first_char(code) && _Code1(code)) {
				status = Status::SecondChar;
				return 1;
			} else {
			}
			if (status == Status::SecondChar && _Code2(code)) {
				status = Status::Edit;
				return 1;
			} else {
			}
			if (status == Status::Edit && code == 0xd && _Newline()) {
				return 1;
			} else {
			}
			if (status == Status::Edit && code == 0x8 && _BackSpace()) {
				return 1;
			} else {
			}
			if (status == Status::Edit && code == 0x9 && _Code(0x20) && _Code(0x20) && _Code(0x20) && _Code(0x20)) {
				return 1;
			} else {
			}
		} else {
		}
	} else {
	}
	if (al_misc("platform", null, null) == "windows") {
		if (type == Event::KeyChar) {
			if (status == Status::Edit && al_is_normal_char(code) && _Code(code)) {
				return 1;
			} else {
			}
			if (status == Status::Edit && al_is_first_char(code) && _Code1(code)) {
				status = Status::SecondChar;
				return 1;
			} else {
			}
			if (status == Status::SecondChar && _Code2(code)) {
				status = Status::Edit;
				return 1;
			} else {
			}
			if (status == Status::Edit && code == 0xd && _Newline()) {
				return 1;
			} else {
			}
			if (status == Status::Edit && code == 0x8 && _BackSpace()) {
				return 1;
			} else {
			}
			if (status == Status::Edit && code == 0x9 && _Code(0x20) && _Code(0x20) && _Code(0x20) && _Code(0x20)) {
				return 1;
			} else {
			}
		} else {
		}
	} else {
	}
	if (type == Event::LeftDoubleClick) {
		if ((status == Status::Edit || status == Status::Drag) && _DoubleClick(h)) {
			status = Status::Edit;
			return 1;
		} else {
		}
	} else {
	}
	return Glyph::Execute(h);
}
end_body
member
public: list _BeginDrag(Hit h);
body
{
	h.root.focus = this;
	var window w;
	w = h.wnd;
	al_start_quick_draw(w);
	al_push_tm(w, h.tm);
	_DrawSelection(w);
	SelFromXY(h);
	from_pos = to_pos = sel_pos;
	from_line_pos = to_line_pos = sel_line_pos;
	from_line_vpos = to_line_vpos = sel_line_vpos;
	from_line = to_line = sel_line;
	_DrawSelection(w);
	al_pop_tm(w);
	al_end_quick_draw(w);
	return 1;
}
end_body
member
public: list _Drag(Hit h);
body
{
	var window w;
	w = h.wnd;
	al_start_quick_draw(w);
	al_push_tm(w, h.tm);
	_DrawSelection(w);
	SelFromXY(h);
	if (from_pos <= sel_pos) {
		to_pos = sel_pos;
		to_line_pos = sel_line_pos;
		to_line_vpos = sel_line_vpos;
		to_line = sel_line;
	} else {
	}
	_DrawSelection(w);
	al_pop_tm(w);
	al_end_quick_draw(w);
	return 1;
}
end_body
member
public: list _EndDrag(Hit h);
body
{
	sel_pos = sel_line_pos = sel_line_vpos = sel_line = null;
	return 1;
}
end_body
member
public: list _Left(Hit h);
body
{
	var window w;
	w = h.wnd;
	al_start_quick_draw(w);
	al_push_tm(w, tm);
	_DrawSelection(w);
	if (from_pos > from_line_pos) {
		var integer pos, ch, num;
		pos = from_line_pos;
		loop {
			ch = al_get_char(text, pos);
			if (al_is_normal_char(ch)) {
				num = 1;
			} else {
			}
			if (al_is_first_char(ch)) {
				num = 2;
			} else {
			}
			if (pos + num >= from_pos) {
				from_pos = pos;
				break;
			} else {
			}
			pos = pos + num;
		}
	} else {
		var list line;
		if (line = al_prev_dst_node(lines, from_line, null)) {
			from_pos = from_line_pos - 1;
			from_line_pos = from_pos - line.head;
			from_line_vpos = from_line_vpos - font.tail.head - pitch;
			from_line = line;
		} else {
		}
	}
	to_pos = from_pos;
	to_line_pos = from_line_pos;
	to_line_vpos = from_line_vpos;
	to_line = from_line;
	al_push_font_ex(w, font);
	var list wh;
	wh = al_text_width_from_to(w, text, from_line_pos, from_pos);
	up_down_hpos = wh.head;
	al_pop_font(w);
	_DrawSelection(w);
	al_pop_tm(w);
	al_end_quick_draw(w);
	return 1;
}
end_body
member
public: list _Right(Hit h);
body
{
	var window w;
	w = h.wnd;
	al_start_quick_draw(w);
	al_push_tm(w, tm);
	_DrawSelection(w);
	if (to_pos < to_line_pos + to_line.head) {
		var integer pos, ch, num;
		pos = to_line_pos;
		loop {
			ch = al_get_char(text, pos);
			if (al_is_normal_char(ch)) {
				num = 1;
			} else {
			}
			if (al_is_first_char(ch)) {
				num = 2;
			} else {
			}
			pos = pos + num;
			if (pos > to_pos) {
				to_pos = pos;
				break;
			} else {
			}
		}
	} else {
		var list line;
		if (line = al_next_dst_node(lines, to_line, null)) {
			to_line_pos = to_pos = to_pos + 1;
			to_line_vpos = to_line_vpos + font.tail.head + pitch;
			to_line = line;
		} else {
		}
	}
	from_pos = to_pos;
	from_line_pos = to_line_pos;
	from_line_vpos = to_line_vpos;
	from_line = to_line;
	al_push_font_ex(w, font);
	var list wh;
	wh = al_text_width_from_to(w, text, to_line_pos, to_pos);
	up_down_hpos = wh.head;
	al_pop_font(w);
	_DrawSelection(w);
	al_pop_tm(w);
	al_end_quick_draw(w);
	return 1;
}
end_body
member
public: list _Up(Hit h);
body
{
	var window w;
	w = h.wnd;
	al_start_quick_draw(w);
	al_push_tm(w, tm);
	_DrawSelection(w);
	var list line;
	if (line = al_prev_dst_node(lines, from_line, null)) {
		from_line_pos = from_line_pos - line.head - 1;
		from_line_vpos = from_line_vpos - font.tail.head - pitch;
		from_line = line;
		PosFromX(h, from_line_pos, from_line, up_down_hpos);
		from_pos = sel_pos;
		sel_pos = null;
	} else {
	}
	to_pos = from_pos;
	to_line_pos = from_line_pos;
	to_line_vpos = from_line_vpos;
	to_line = from_line;
	_DrawSelection(w);
	al_pop_tm(w);
	al_end_quick_draw(w);
	return 1;
}
end_body
member
public: list _Down(Hit h);
body
{
	var window w;
	w = h.wnd;
	al_start_quick_draw(w);
	al_push_tm(w, tm);
	_DrawSelection(w);
	var list line;
	if (line = al_next_dst_node(lines, to_line, null)) {
		to_line_pos = to_line_pos + to_line.head + 1;
		to_line_vpos = to_line_vpos + font.tail.head + pitch;
		to_line = line;
		PosFromX(h, to_line_pos, to_line, up_down_hpos);
		to_pos = sel_pos;
		sel_pos = null;
	} else {
	}
	from_pos = to_pos;
	from_line_pos = to_line_pos;
	from_line_vpos = to_line_vpos;
	from_line = to_line;
	_DrawSelection(w);
	al_pop_tm(w);
	al_end_quick_draw(w);
	return 1;
}
end_body
member
public: list _Code(integer code);
body
{
	if (debug) {
		al_print("TextEditor::_Code()\n");
	} else {
	}
	al_insert_char(text, from_pos, code);
	from_pos = from_pos + 1;
	from_line.head = from_line.head + 1;
	to_pos = from_pos;
	to_line_pos = from_line_pos;
	to_line_vpos = from_line_vpos;
	to_line = from_line;
	if (no_redraw) {
	} else {
		var window w;
		w = wnd;
		al_start_quick_draw(w);
		al_push_font_ex(w, font);
		var list wh;
		wh = al_text_width_from_to(w, text, from_line_pos, from_pos);
		up_down_hpos = wh.head;
		al_pop_font(w);
		al_end_quick_draw(w);
		Damage(0, from_line_vpos, 2000, (integer)(from_line_vpos + font.tail.head));
	}
	return 1;
}
end_body
member
public: list _Code1(integer code);
body
{
	if (al_is_first_char(code)) {
	} else {
		return null;
	}
	first_char = code;
	return 1;
}
end_body
member
public: list _Code2(integer code);
body
{
	al_insert_char(text, from_pos, first_char);
	from_pos = from_pos + 1;
	from_line.head = from_line.head + 1;
	al_insert_char(text, from_pos, code);
	from_pos = from_pos + 1;
	from_line.head = from_line.head + 1;
	to_pos = from_pos;
	to_line_pos = from_line_pos;
	to_line_vpos = from_line_vpos;
	to_line = from_line;
	if (no_redraw) {
	} else {
		var window w;
		w = wnd;
		al_start_quick_draw(w);
		al_push_font_ex(w, font);
		var list wh;
		wh = al_text_width_from_to(w, text, from_line_pos, from_pos);
		up_down_hpos = wh.head;
		al_pop_font(w);
		al_end_quick_draw(w);
		Damage(0, from_line_vpos, 2000, (integer)(from_line_vpos + font.tail.head));
	}
	first_char = null;
	return 1;
}
end_body
member
public: list _Newline();
body
{
	al_insert_char(text, from_pos, 0xa);
	var list line;
	line = al_cons(from_line.head - from_pos + from_line_pos, null);
	from_line.head = from_pos - from_line_pos;
	al_append_after(lines, from_line, line, null);
	from_pos = from_line_pos = from_pos + 1;
	from_line_vpos = from_line_vpos + font.tail.head + pitch;
	from_line = line;
	to_pos = from_pos;
	to_line_pos = from_line_pos;
	to_line_vpos = from_line_vpos;
	to_line = from_line;
	up_down_hpos = 0;
	if (no_redraw) {
	} else {
		Damage();
	}
	return 1;
}
end_body
member
public: list _BackSpace();
body
{
	if (from_pos > from_line_pos) {
		var integer pos, ch, num;
		pos = from_line_pos;
		loop {
			ch = al_get_char(text, pos);
			if (al_is_normal_char(ch)) {
				num = 1;
			} else {
				if (al_is_first_char(ch)) {
					num = 2;
				} else {
					al_print("BackSpace: There is an illegal character.\n");
					return null;
				}
			}
			if (pos + num >= from_pos) {
				break;
			} else {
			}
			pos = pos + num;
		}
		if (num == 1) {
			al_delete_char(text, pos);
		} else {
		}
		if (num == 2) {
			al_delete_char(text, pos);
			al_delete_char(text, pos);
		} else {
		}
		from_pos = from_pos - num;
		from_line.head = from_line.head - num;
		to_pos = from_pos;
		to_line_pos = from_line_pos;
		to_line_vpos = from_line_vpos;
		to_line = from_line;
		var window w;
		w = wnd;
		al_start_quick_draw(w);
		al_push_font_ex(w, font);
		var list wh;
		wh = al_text_width_from_to(w, text, from_line_pos, from_pos);
		up_down_hpos = wh.head;
		al_pop_font(w);
		al_end_quick_draw(w);
		Damage(0, from_line_vpos, 2000, (integer)(from_line_vpos + font.tail.head));
		return 1;
	} else {
	}
	var list line;
	if (line = al_prev_dst_node(lines, from_line, null)) {
	} else {
		return null;
	}
	al_delete_char(text, from_line_pos - 1);
	from_pos = from_pos - 1;
	from_line_pos = from_line_pos - 1 - line.head;
	line.head = line.head + from_line.head;
	al_remove_from(lines, from_line, null);
	from_line_vpos = from_line_vpos - font.tail.head - pitch;
	from_line = line;
	to_pos = from_pos;
	to_line_pos = from_line_pos;
	to_line_vpos = from_line_vpos;
	to_line = from_line;
	var window w;
	w = wnd;
	al_start_quick_draw(w);
	al_push_font_ex(w, font);
	var list wh;
	wh = al_text_width_from_to(w, text, from_line_pos, from_pos);
	up_down_hpos = wh.head;
	al_pop_font(w);
	al_end_quick_draw(w);
	Damage();
	return 1;
}
end_body
member
public: integer first_char;
member
public: void Cut();
body
{
	Copy();
	Clear();
}
end_body
member
public: void Copy();
body
{
	var string str;
	str = al_substr(text, from_pos, to_pos);
	al_misc("to_clipboard", str, null);
}
end_body
member
public: void Paste();
body
{
	var string str;
	str = al_misc("from_clipboard", null, null);
	if (al_is_type(str, "string")) {
	} else {
		return;
	}
	Replace(str);
}
end_body
member
public: void Clear();
body
{
	var integer pos;
	pos = from_pos;
	from_pos = to_pos;
	from_line_pos = to_line_pos;
	from_line_vpos = to_line_vpos;
	from_line = to_line;
	loop {
		if (pos < from_pos) {
		} else {
			break;
		}
		_BackSpace();
	}
	if (no_redraw) {
	} else {
		Damage();
	}
}
end_body
member
public: void Replace(string str);
body
{
	Clear();
	_Replace(str);
	if (no_redraw) {
	} else {
		Damage();
	}
}
end_body
member
public: void _Replace(string str);
body
{
	var list line;
	var integer len, pos, ch, ch2;
	len = al_strlen(str);
	pos = 0;
	loop {
		if (pos < len) {
		} else {
			break;
		}
		ch = al_get_char(str, pos);
		if (ch == 0xa) {
			pos = pos + 1;
			al_insert_char(text, to_pos, 0xa);
			line = al_cons(to_line.head - to_pos + to_line_pos, null);
			to_line.head = to_pos - to_line_pos;
			al_append_after(lines, to_line, line, null);
			from_line = to_line = line;
			from_line_pos = to_line_pos = from_pos = to_pos = to_pos + 1;
			to_line_vpos = from_line_vpos = to_line_vpos + font.tail.head + pitch;
		} else {
			if (al_is_normal_char(ch)) {
				pos = pos + 1;
				al_insert_char(text, to_pos, ch);
				from_pos = to_pos = to_pos + 1;
				to_line.head = to_line.head + 1;
			} else {
				if (al_is_first_char(ch)) {
					pos = pos + 1;
					ch2 = al_get_char(str, pos);
					pos = pos + 1;
					al_insert_char(text, to_pos, ch);
					to_pos = to_pos + 1;
					al_insert_char(text, to_pos, ch2);
					from_pos = to_pos = to_pos + 1;
					to_line.head = to_line.head + 2;
				} else {
					if (ch == 0x9) {
						pos = pos + 1;
						al_insert_char(text, to_pos, 0x20);
						to_pos = to_pos + 1;
						al_insert_char(text, to_pos, 0x20);
						to_pos = to_pos + 1;
						al_insert_char(text, to_pos, 0x20);
						to_pos = to_pos + 1;
						al_insert_char(text, to_pos, 0x20);
						from_pos = to_pos = to_pos + 1;
						to_line.head = to_line.head + 4;
					} else {
						al_print("TextEditor::Replace: illegal character. (");
						al_print(ch);
						al_print(")\n");
						pos = pos + 1;
						al_insert_char(text, from_pos, '?');
						from_pos = to_pos = to_pos + 1;
						to_line.head = to_line.head + 1;
					}
				}
			}
		}
	}
}
end_body
member
public: string GetSelText();
body
{
	return al_substr(text, from_pos, to_pos);
}
end_body
member
public: list no_redraw;
member
public: integer Save(file f);
body
{
	return al_file_write(f, "graph", al_list2(text, lines));
}
end_body
member
public: integer Load(file f);
body
{
	var list data;
	if (data = al_file_read(f, "graph")) {
	} else {
		return 1;
	}
	text = al_copy(data.head);
	lines = data.tail.head;
	from_line = to_line = al_dst_node(lines, null);
	return null;
}
end_body
member
public: list GbCode(list pif);
body
{
	var string file_name;
	if (file_name = al_dst_node(this, "$editor_id")) {
	} else {
		return 1;
	}
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var TextEditor pp;"));
	err = (err || GbCode(pif, "pp = new TextEditor;"));
	err = (err || GbCode(pif, "pp.Create();"));
	err = (err || GbCode(pif, "var file f;"));
	err = (err || GbCode(pif, "if (f = al_file_open(GUIbuilder::GetPath() + \"/\\" + file_name + "\", \"r\")) {"));
	err = (err || GbCode(pif, "pp.Load(f);"));
	err = (err || GbCode(pif, "f = null;"));
	err = (err || GbCode(pif, "} else {"));
	err = (err || GbCode(pif, "}"));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
member
public: void ClearAll();
body
{
	text = al_copy("");
	al_insert_char(text, 0, 0xa);
	lines = al_cons(null, null);
	from_pos = from_line_pos = from_line_vpos = 0;
	to_pos = to_line_pos = to_line_vpos = 0;
	from_line = to_line = al_cons(0, null);
	al_create_arc(lines, from_line, null);
	up_down_hpos = 0;
	Damage();
}
end_body
member
public: void public_var();
body
{
	text;
	font;
	pitch;
	from_pos;
	to_pos;
}
end_body
member
public: void public_func();
body
{
	Create();
	Cut();
	Copy();
	Paste();
	Clear();
	Replace((string)null);
	ClearAll();
}
end_body
member
public: integer GetLineCount();
body
{
	var list itr;
	itr = al_dst_itr(lines);
	return al_count(itr);
}
end_body
member
public: integer GetCursorPos();
body
{
	return from_pos;
}
end_body
member
public: integer GetPosLineNumber(integer pos);
body
{
	var list itr, line;
	itr = al_dst_itr(lines);
	var integer p, line_no, line_no1;
	p = 0;
	line_no = line_no1 = 1;
	loop {
		if (p > pos) {
			return line_no;
		} else {
		}
		line_no = line_no1;
		if (line = al_next(itr)) {
		} else {
			return -1;
		}
		p = p + line.head + 1;
		line_no1 = line_no1 + 1;
	}
}
end_body
member
public: list GetLineStartEndPos(integer line_no);
body
{
	var list itr, line;
	itr = al_dst_itr(lines);
	var integer n, pos;
	n = 1;
	pos = 0;
	loop {
		if (line = al_next(itr)) {
		} else {
			return null;
		}
		if (n >= line_no) {
			break;
		} else {
		}
		n = n + 1;
		pos = pos + line.head + 1;
	}
	return al_list2(pos, pos + line.head + 1);
}
end_body
member
public: list SetSelection(integer from, integer to);
body
{
	from_pos = from_line_pos = from_line_vpos = 0;
	to_pos = to_line_pos = to_line_vpos = 0;
	from_line = to_line = al_dst_node(lines, null);
	up_down_hpos = 0;
	var list line;
	var integer pos, ch, num;
	loop {
		if (line = al_next_dst_node(lines, to_line, null)) {
			if (to_line_pos + to_line.head + 1 > to) {
				break;
			} else {
			}
			to_line_pos = to_pos = to_line_pos + to_line.head + 1;
			to_line_vpos = to_line_vpos + font.tail.head + pitch;
			to_line = line;
		} else {
			break;
		}
	}
	pos = to_pos = to_line_pos;
	loop {
		ch = al_get_char(text, pos);
		if (al_is_normal_char(ch) || ch == 0xa) {
			num = 1;
		} else {
		}
		if (al_is_first_char(ch)) {
			num = 2;
		} else {
		}
		pos = pos + num;
		if (pos > to) {
			break;
		} else {
		}
		to_pos = pos;
	}
	loop {
		if (line = al_next_dst_node(lines, from_line, null)) {
			if (from_line_pos + from_line.head + 1 > from) {
				break;
			} else {
			}
			from_line_pos = from_pos = from_line_pos + from_line.head + 1;
			from_line_vpos = from_line_vpos + font.tail.head + pitch;
			from_line = line;
		} else {
			break;
		}
	}
	pos = from_pos = from_line_pos;
	loop {
		ch = al_get_char(text, pos);
		if (al_is_normal_char(ch) || ch == 0xa) {
			num = 1;
		} else {
		}
		if (al_is_first_char(ch)) {
			num = 2;
		} else {
		}
		pos = pos + num;
		if (pos > from) {
			break;
		} else {
		}
		from_pos = pos;
	}
	return 1;
}
end_body
member
public: integer GetCursorYPos();
body
{
	return from_line_vpos;
}
end_body
member
public: string GetCurrentLine();
body
{
	var integer pos, lno;
	var list start_end;
	var integer start, end;
	pos = GetCursorPos();
	lno = GetPosLineNumber(pos);
	if (start_end = GetLineStartEndPos(lno)) {
	} else {
		return null;
	}
	start = start_end.head;
	end = start_end.tail.head;
	return al_substr(text, start, end - 1);
}
end_body
member
public: void SetDoubleClickCallback(GUI obj, GUIfunc func);
body
{
	_obj = obj;
	_func = func;
}
end_body
member
public: GUI _obj;
member
public: GUIfunc _func;
member
public: list _DoubleClick(Hit h);
body
{
	if (_obj && _func) {
		_obj.*_func();
		return 1;
	} else {
	}
	return Glyph::_Clicked(h);
}
end_body
member
public: string GetText();
body
{
	return al_substr(text, 0, al_strlen(text) - 1);
}
end_body
member
public: void Find(string str);
body
{
	search_pos = al_search_str(text, 0, str);
	if (search_pos >= 0) {
		SetSelection(search_pos, search_pos + (integer)al_strlen(str));
	} else {
	}
}
end_body
member
public: void FindNext(string str);
body
{
	if (search_pos) {
	} else {
		search_pos = 0;
	}
	search_pos = al_search_str(text, search_pos + 1, str);
	if (search_pos >= 0) {
		SetSelection(search_pos, search_pos + (integer)al_strlen(str));
	} else {
	}
}
end_body
member
public: integer search_pos;
member
public: list debug;
end_class
end_class
class AlControl
member
public: void Create(integer l, integer t, integer r, integer b);
body
{
	Glyph::Create();
	Glyph::Resize(l, t, r, b);
	face_color = 0xc0c0c0;
	highlight_color = 0xffffff;
	shadow_color = 0x808080;
	frame_color = 0x0;
	text_color = 0x0;
	text_bg_color = 0xc0c0c0;
}
end_body
member
public: integer face_color;
member
public: integer highlight_color;
member
public: integer shadow_color;
member
public: integer frame_color;
member
public: integer text_color;
member
public: integer text_bg_color;
member
public: integer font_name;
member
public: integer font_height;
member
public: integer font_width;
member
public: list GbAttr(list pif);
body
{
	var list err;
	err = (err || GbCode(pif, "pp.face_color = " + (string)face_color + ";"));
	err = (err || GbCode(pif, "pp.highlight_color = " + (string)highlight_color + ";"));
	err = (err || GbCode(pif, "pp.shadow_color = " + (string)shadow_color + ";"));
	err = (err || GbCode(pif, "pp.frame_color = " + (string)frame_color + ";"));
	err = (err || GbCode(pif, "pp.text_color = " + (string)text_color + ";"));
	err = (err || GbCode(pif, "pp.text_bg_color = " + (string)text_bg_color + ";"));
	if (font_name) {
		err = (err || GbCode(pif, "pp.font_name = \"" + (string)font_name + "\";"));
		err = (err || GbCode(pif, "pp.font_height = " + (string)font_height + ";"));
		err = (err || GbCode(pif, "pp.font_width = " + (string)font_width + ";"));
	} else {
	}
	return err;
}
end_body
member
public: void public_var();
body
{
	face_color;
	highlight_color;
	shadow_color;
	frame_color;
	text_color;
	text_bg_color;
	font_name;
	font_height;
	font_width;
}
end_body
class AlButton
member
public: void Create(integer l, integer t, integer r, integer b, string txt);
body
{
	AlControl::Create(l, t, r, b);
	face_text = txt;
	if (al_misc("platform", null, null) == "windows") {
		font_name = "lr SVbN";
	} else {
	}
	if (al_misc("platform", null, null) == "linux" || al_misc("platform", null, null) == "mac") {
		font_name = "-*-*-medium-r-normal-*-14-*-*-*-*-*-*-*,*";
	} else {
	}
	font_height = 12;
	font_width = 6;
}
end_body
member
public: void Draw(window w);
body
{
	var integer lt_color, rb_color;
	if (status != Status::Click) {
		lt_color = highlight_color;
		rb_color = shadow_color;
	} else {
		lt_color = shadow_color;
		rb_color = face_color;
	}
	DrawBase(w, left, top, right, bottom, frame_color, face_color, lt_color, rb_color);
	if (face_text) {
		var list wh;
		wh = al_text_width(w, face_text);
		var integer x, y;
		x = (left + right) / 2 - wh.head / 2;
		y = (top + bottom) / 2 - font_height / 2;
		al_push_font(w, font_name, font_height, font_width, text_color);
		var list poly;
		poly = al_create_poly_poly();
		al_add_rect_to_poly(poly, left, top, right, bottom);
		if (al_window_tm(w)) {
			poly = al_transform_poly(al_window_tm(w), poly);
		} else {
		}
		al_push_clipping(w, al_intersection(al_clipping(w), poly));
		al_push_bg_color(w, text_bg_color);
		al_text(w, x, y, face_text);
		al_pop_bg_color(w);
		al_pop_clipping(w);
		al_pop_font(w);
	} else {
	}
}
end_body
member
public: void Destroy();
body
{
	_obj = _func = null;
}
end_body
member
public: static void DrawBase(window w, integer l, integer t, integer r, integer b, integer frame, integer face, integer lt, integer rb);
body
{
	al_push_pen(w, "Solid", 0, frame);
	al_push_brush(w, "Solid", face, null);
	al_rectangle(w, l, t, r, b);
	al_pop_brush(w);
	al_pop_pen(w);
	var list poly;
	al_push_pen(w, "Null", 0, 0x0);
	al_push_brush(w, "Solid", lt, null);
	poly = al_create_poly_poly();
	al_add_point_to_poly(poly, l + 1, b - 1);
	al_add_point_to_poly(poly, l + 1, t + 1);
	al_add_point_to_poly(poly, r - 1, t + 1);
	al_add_point_to_poly(poly, r - 3, t + 3);
	al_add_point_to_poly(poly, l + 3, t + 3);
	al_add_point_to_poly(poly, l + 3, b - 3);
	al_add_point_to_poly(poly, l + 1, b - 1);
	al_polygon(w, poly);
	al_pop_brush(w);
	al_push_brush(w, "Solid", rb, null);
	poly = al_create_poly_poly();
	al_add_point_to_poly(poly, r, t);
	al_add_point_to_poly(poly, r, b);
	al_add_point_to_poly(poly, l, b);
	al_add_point_to_poly(poly, l + 2, b - 2);
	al_add_point_to_poly(poly, r - 2, b - 2);
	al_add_point_to_poly(poly, r - 2, t + 2);
	al_add_point_to_poly(poly, r, t);
	al_polygon(w, poly);
	al_pop_brush(w);
	al_pop_pen(w);
}
end_body
member
public: string face_text;
member
public: void SetCallback(GUI obj, GUIfunc func);
body
{
	_obj = obj;
	_func = func;
}
end_body
member
public: GUI _obj;
member
public: GUIfunc _func;
member
public: list _Clicked(Hit h);
body
{
	if (_obj && _func) {
		_obj.*_func();
		Damage();
		return 1;
	} else {
	}
	return Glyph::_Clicked(h);
}
end_body
member
public: void public_var();
body
{
	face_text;
}
end_body
member
public: void public_func();
body
{
	SetCallback((GUI)null, (GUIfunc)null);
}
end_body
member
public: list GbCode(list pif);
body
{
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var AlButton pp;"));
	err = (err || GbCode(pif, "pp = new AlButton;"));
	err = (err || GbCode(pif, "pp.Create(" + GbGeom() + ", \"" + (string)face_text + "\");"));
	err = (err || GbAttr(pif));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
end_class
class AlScrollBar
member
public: integer direction;
member
public: integer delta1;
member
public: integer delta2;
member
public: integer max;
member
public: integer pos;
member
public: integer prepos;
member
public: integer dmgpos;
member
public: integer timer_id;
member
public: integer delta;
member
public: list Execute(Hit h);
body
{
	var integer type, modif, info;
	type = h.event.head;
	modif = h.event.tail.tail.tail.tail.head;
	info = h.info;
	if (type == Event::LeftPress && modif != 0x2) {
		if (status == Status::Execute) {
			if (info == TargetInfo::LowButton && _BeginLowB(h)) {
				status = Status::LowButton;
				return 1;
			} else {
			}
			if (info == TargetInfo::LowArea && _BeginLowA(h)) {
				status = Status::LowArea;
				return 1;
			} else {
			}
			if (info == TargetInfo::SlideButton && _BeginSlide(h)) {
				status = Status::SlideButton;
				return 1;
			} else {
			}
			if (info == TargetInfo::HighArea && _BeginHighA(h)) {
				status = Status::HighArea;
				return 1;
			} else {
			}
			if (info == TargetInfo::HighButton && _BeginHighB(h)) {
				status = Status::HighButton;
				return 1;
			} else {
			}
		} else {
		}
	} else {
	}
	if (type == Event::MouseMove) {
		if (status == Status::SlideButton && _Slide(h)) {
			return 1;
		} else {
		}
	} else {
	}
	if (type == Event::LeftRelease) {
		if (status == Status::LowButton && _EndLowB(h)) {
			status = Status::Execute;
			return 1;
		} else {
		}
		if (status == Status::LowArea && _EndTimer(h)) {
			status = Status::Execute;
			return 1;
		} else {
		}
		if (status == Status::SlideButton && _EndSlide(h)) {
			status = Status::Execute;
			return 1;
		} else {
		}
		if (status == Status::HighArea && _EndTimer(h)) {
			status = Status::Execute;
			return 1;
		} else {
		}
		if (status == Status::HighButton && _EndHighB(h)) {
			status = Status::Execute;
			return 1;
		} else {
		}
	} else {
	}
}
end_body
member
public: list _BeginSlide(Hit h);
body
{
	h.root.grab = this;
	_x0 = h.event.tail.head;
	_y0 = h.event.tail.tail.head;
	prepos = pos;
	return 1;
}
end_body
member
public: list _Slide(Hit h);
body
{
	dmgpos = pos;
	if (direction == 0) {
		delta = h.event.tail.head - _x0;
	} else {
		delta = h.event.tail.tail.head - _y0;
	}
	pos = al_max(0, al_min(max, prepos + delta));
	if (pos == dmgpos) {
		return 1;
	} else {
	}
	DamageSlideButton();
	dmgpos = pos;
	DamageSlideButton();
	Scroll();
	return 1;
}
end_body
member
public: list _EndSlide(Hit h);
body
{
	h.root.grab = null;
	_x0 = null;
	_y0 = null;
	prepos = null;
	dmgpos = null;
	delta = null;
	return 1;
}
end_body
member
public: list _BeginLowB(Hit h);
body
{
	h.root.grab = this;
	delta =  - delta1;
	_Timer(h);
	timer_id = al_get_id();
	set_timer(100);
	DamageLowButton();
	return 1;
}
end_body
member
public: list _BeginHighB(Hit h);
body
{
	h.root.grab = this;
	delta = delta1;
	_Timer(h);
	timer_id = al_get_id();
	set_timer(100);
	DamageHighButton();
	return 1;
}
end_body
member
public: list _BeginLowA(Hit h);
body
{
	h.root.grab = this;
	delta =  - delta2;
	_Timer(h);
	timer_id = al_get_id();
	set_timer(300);
	return 1;
}
end_body
member
public: list _BeginHighA(Hit h);
body
{
	h.root.grab = this;
	delta = delta2;
	_Timer(h);
	timer_id = al_get_id();
	set_timer(300);
	return 1;
}
end_body
member
public: list _Timer(Hit h);
body
{
	dmgpos = pos;
	pos = al_max(0, al_min(max, pos + delta));
	if (pos == dmgpos) {
		return 1;
	} else {
	}
	DamageSlideButton();
	dmgpos = pos;
	DamageSlideButton();
	Scroll();
	return 1;
}
end_body
member
public: list _EndTimer(Hit h);
body
{
	h.root.grab = null;
	clear_timer();
	al_release_id(timer_id);
	dmgpos = null;
	timer_id = null;
	delta = null;
	return 1;
}
end_body
member
public: list _EndLowB(Hit h);
body
{
	DamageLowButton();
	return _EndTimer(h);
}
end_body
member
public: list _EndHighB(Hit h);
body
{
	DamageHighButton();
	return _EndTimer(h);
}
end_body
member
public: void DamageLowButton();
body
{
}
end_body
member
public: void DamageSlideButton();
body
{
}
end_body
member
public: void DamageHighButton();
body
{
}
end_body
member
public: void Connect(ScrollGlyph sg);
body
{
}
end_body
member
public: void Adjust(ScrollGlyph sg);
body
{
}
end_body
member
public: void Scroll();
body
{
}
end_body
member
public: void set_timer(integer period);
body
{
	al_gui_misc("timer", al_list2(timer_id, period), al_list3(al_root_class(), this, AlScrollBar::timer_callback));
}
end_body
member
public: void clear_timer();
body
{
	al_gui_misc("timer", al_list2(timer_id, 300), null);
}
end_body
member
public: void timer_callback();
body
{
	_Timer((Hit)null);
}
end_body
class AlVScrollBar
member
public: void Create(integer l, integer t, integer r, integer b);
body
{
	AlControl::Create(l, t, r, b);
	direction = 1;
	delta1 = 20;
	delta2 = 120;
	pos = 0;
	max = bottom - top - 60;
	scrolls = al_cons(null, null);
}
end_body
member
public: void Resize(integer l, integer t, integer r, integer b);
body
{
	Glyph::Resize(l, t, r, b);
	max = bottom - top - 60;
	pos = al_min(pos, max);
}
end_body
member
public: void Draw(window w);
body
{
	var integer lt, rb;
	al_push_pen(w, "Null", 0, 0);
	al_push_brush(w, "Solid", face_color, null);
	al_rectangle(w, left, top, right, bottom);
	al_pop_brush(w);
	al_pop_pen(w);
	AlButton::DrawBase(w, left, top + 20 + pos, right, top + 40 + pos, frame_color, face_color, highlight_color, shadow_color);
	al_push_pen(w, "Null", 0, 0x0);
	al_push_brush(w, "Solid", text_color, null);
	if (status == Status::LowButton) {
		lt = shadow_color;
		rb = face_color;
	} else {
		lt = highlight_color;
		rb = shadow_color;
	}
	AlButton::DrawBase(w, left, top, right, top + 20, frame_color, face_color, lt, rb);
	if (status == Status::HighButton) {
		lt = shadow_color;
		rb = face_color;
	} else {
		lt = highlight_color;
		rb = shadow_color;
	}
	AlButton::DrawBase(w, left, bottom - 20, right, bottom, frame_color, face_color, lt, rb);
	var list poly;
	poly = al_create_poly_poly();
	al_add_point_to_poly(poly, left + 5, top + 15);
	al_add_point_to_poly(poly, (left + right) / 2, top + 5);
	al_add_point_to_poly(poly, right - 5, top + 15);
	al_polygon(w, poly);
	poly = al_create_poly_poly();
	al_add_point_to_poly(poly, left + 5, bottom - 15);
	al_add_point_to_poly(poly, right - 5, bottom - 15);
	al_add_point_to_poly(poly, (left + right) / 2, bottom - 5);
	al_polygon(w, poly);
	al_pop_brush(w);
	al_pop_pen(w);
	al_push_pen(w, "Solid", 0, frame_color);
	al_push_brush(w, "Null", 0, null);
	al_rectangle(w, left, top, right, bottom);
	al_pop_brush(w);
	al_pop_pen(w);
}
end_body
member
public: void Pick(Hit h);
body
{
	if (Event::IsMouseEvent((integer)h.event.head)) {
	} else {
		return;
	}
	var list xy;
	var integer x, y;
	xy = al_inverse_xy(al_window_tm(h.wnd), h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	if (left <= x && x <= right && top <= y && y <= bottom) {
	} else {
		return;
	}
	if (status == Status::Layout) {
		h.Target(this, null);
		return;
	} else {
	}
	if (y <= top + 20) {
		h.Target(this, TargetInfo::LowButton);
		return;
	} else {
	}
	if (bottom - 20 <= y) {
		h.Target(this, TargetInfo::HighButton);
		return;
	} else {
	}
	if (y <= top + 20 + pos) {
		h.Target(this, TargetInfo::LowArea);
		return;
	} else {
	}
	if (y <= top + 40 + pos) {
		h.Target(this, TargetInfo::SlideButton);
	} else {
		h.Target(this, TargetInfo::HighArea);
	}
}
end_body
member
public: void DamageLowButton();
body
{
	Damage(left, top, right, top + 20);
}
end_body
member
public: void DamageSlideButton();
body
{
	Damage();
}
end_body
member
public: void DamageHighButton();
body
{
	Damage(left, bottom - 20, right, bottom);
}
end_body
member
public: void Connect(ScrollGlyph sg);
body
{
	al_create_arc(scrolls, sg, "$scroll");
	Adjust(sg);
}
end_body
member
public: void Adjust(ScrollGlyph sg);
body
{
	if (sg.tm) {
	} else {
		sg.tm = al_unit_tm();
	}
	var integer dy1, dy2;
	dy1 = sg.top - sg.tm[1][1] * sg.range_top;
	dy2 = sg.bottom - sg.tm[1][1] * sg.range_bottom;
	if (dy2 >= dy1) {
		delta1 = delta2 = 0;
	} else {
		delta1 = 20 * max / (dy1 - dy2);
		delta2 = 0.8 * (sg.bottom - sg.top) * max / (dy1 - dy2);
	}
}
end_body
member
public: void Scroll();
body
{
	var list itr;
	itr = al_dst_itr(scrolls);
	var ScrollGlyph sg;
	loop {
		if (sg = al_next_a(itr, "$scroll")) {
		} else {
			break;
		}
		sg.VScroll(pos, max);
	}
}
end_body
member
public: list scrolls;
member
public: list GbCode(list pif);
body
{
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var AlVScrollBar pp;"));
	err = (err || GbCode(pif, "pp = new  AlVScrollBar;"));
	err = (err || GbCode(pif, "pp.Create(" + GbGeom() + ");"));
	err = (err || GbAttr(pif));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
end_class
class AlHScrollBar
member
public: void Create(integer l, integer t, integer r, integer b);
body
{
	AlControl::Create(l, t, r, b);
	direction = 0;
	delta1 = 20;
	delta2 = 120;
	pos = 0;
	max = right - left - 60;
	scrolls = al_cons(null, null);
}
end_body
member
public: void Resize(integer l, integer t, integer r, integer b);
body
{
	Glyph::Resize(l, t, r, b);
	max = right - left - 60;
	pos = al_min(pos, max);
}
end_body
member
public: void Draw(window w);
body
{
	var integer lt, rb;
	al_push_pen(w, "Null", 0, 0);
	al_push_brush(w, "Solid", face_color, null);
	al_rectangle(w, left, top, right, bottom);
	al_pop_brush(w);
	al_pop_pen(w);
	AlButton::DrawBase(w, left + 20 + pos, top, left + 40 + pos, bottom, frame_color, face_color, highlight_color, shadow_color);
	al_push_pen(w, "Null", 0, 0x0);
	al_push_brush(w, "Solid", text_color, null);
	if (status == Status::LowButton) {
		lt = shadow_color;
		rb = face_color;
	} else {
		lt = highlight_color;
		rb = shadow_color;
	}
	AlButton::DrawBase(w, left, top, left + 20, bottom, frame_color, face_color, lt, rb);
	if (status == Status::HighButton) {
		lt = shadow_color;
		rb = face_color;
	} else {
		lt = highlight_color;
		rb = shadow_color;
	}
	AlButton::DrawBase(w, right - 20, top, right, bottom, frame_color, face_color, lt, rb);
	var list poly;
	poly = al_create_poly_poly();
	al_add_point_to_poly(poly, left + 5, (top + bottom) / 2);
	al_add_point_to_poly(poly, left + 15, top + 5);
	al_add_point_to_poly(poly, left + 15, bottom - 5);
	al_polygon(w, poly);
	poly = al_create_poly_poly();
	al_add_point_to_poly(poly, right - 15, bottom - 5);
	al_add_point_to_poly(poly, right - 15, top + 5);
	al_add_point_to_poly(poly, right - 5, (top + bottom) / 2);
	al_polygon(w, poly);
	al_pop_brush(w);
	al_pop_pen(w);
	al_push_pen(w, "Solid", 0, frame_color);
	al_push_brush(w, "Null", 0, null);
	al_rectangle(w, left, top, right, bottom);
	al_pop_brush(w);
	al_pop_pen(w);
}
end_body
member
public: void Pick(Hit h);
body
{
	if (Event::IsMouseEvent((integer)h.event.head)) {
	} else {
		return;
	}
	var list xy;
	var integer x, y;
	xy = al_inverse_xy(al_window_tm(h.wnd), h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	if (left <= x && x <= right && top <= y && y <= bottom) {
	} else {
		return;
	}
	if (status == Status::Layout) {
		h.Target(this, null);
		return;
	} else {
	}
	if (x <= left + 20) {
		h.Target(this, TargetInfo::LowButton);
		return;
	} else {
	}
	if (right - 20 <= x) {
		h.Target(this, TargetInfo::HighButton);
		return;
	} else {
	}
	if (x <= left + 20 + pos) {
		h.Target(this, TargetInfo::LowArea);
		return;
	} else {
	}
	if (x <= left + 40 + pos) {
		h.Target(this, TargetInfo::SlideButton);
	} else {
		h.Target(this, TargetInfo::HighArea);
	}
}
end_body
member
public: void DamageLowButton();
body
{
	Damage(left, top, left + 20, bottom);
}
end_body
member
public: void DamageSlideButton();
body
{
	Damage();
}
end_body
member
public: void DamageHighButton();
body
{
	Damage(right - 20, top, right, bottom);
}
end_body
member
public: void Connect(ScrollGlyph sg);
body
{
	al_create_arc(scrolls, sg, "$scroll");
	Adjust(sg);
}
end_body
member
public: void Adjust(ScrollGlyph sg);
body
{
	if (sg.tm) {
	} else {
		sg.tm = al_unit_tm();
	}
	var integer dx1, dx2;
	dx1 = sg.left - sg.tm[0][0] * sg.range_left;
	dx2 = sg.right - sg.tm[0][0] * sg.range_right;
	if (dx2 >= dx1) {
		delta1 = delta2 = 0;
	} else {
		delta1 = 20 * max / (dx1 - dx2);
		delta2 = 0.8 * (sg.right - sg.left) * max / (dx1 - dx2);
	}
}
end_body
member
public: void Scroll();
body
{
	var list itr;
	itr = al_dst_itr(scrolls);
	var ScrollGlyph sg;
	loop {
		if (sg = al_next_a(itr, "$scroll")) {
		} else {
			break;
		}
		sg.HScroll(pos, max);
	}
}
end_body
member
public: list scrolls;
member
public: list GbCode(list pif);
body
{
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var AlHScrollBar pp;"));
	err = (err || GbCode(pif, "pp = new  AlHScrollBar;"));
	err = (err || GbCode(pif, "pp.Create(" + GbGeom() + ");"));
	err = (err || GbAttr(pif));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
end_class
end_class
class AlListBox
member
public: void Create(integer l, integer t, integer r, integer b);
body
{
	AlControl::Create(l, t, r, b);
	vbox = new VBoxGlyph;
	vbox.Create(0, 0, 0, 0);
	scroll = new FrameScrollGlyph;
	scroll.Resize(0, 0, 100, 100);
	scroll.Body(vbox);
	scroll.status = Status::Execute;
	vbar = new AlVScrollBar;
	vbar.Create(0, 0, 20, 300);
	vbar.status = Status::Execute;
	vbar.Connect(scroll);
	child = new FormGlyph;
	var TMGlyph scroll_info, vbar_info;
	scroll_info = child.Append(scroll, 0, 0);
	vbar_info = child.Append(vbar, 0, 0);
	child.Attach(scroll_info, FormGlyph::Left, 0, 0);
	child.Attach(scroll_info, FormGlyph::Top, 0, 0);
	child.Attach(scroll_info, FormGlyph::Right, 0, 20);
	child.Attach(scroll_info, FormGlyph::Bottom, 0, 0);
	child.Attach(vbar_info, FormGlyph::Left, 1, 20);
	child.Attach(vbar_info, FormGlyph::Top, 0, 0);
	child.Attach(vbar_info, FormGlyph::Right, 0, 0);
	child.Attach(vbar_info, FormGlyph::Bottom, 0, 0);
	child.Resize(l, t, r, b);
}
end_body
member
public: list for_combo_box;
member
public: void Resize(integer l, integer t, integer r, integer b);
body
{
	Glyph::Resize(l, t, r, b);
	child.Resize(l, t, r, b);
}
end_body
member
public: void Draw(window w);
body
{
	if (for_combo_box) {
	} else {
		if (al_is_damaged(w, al_window_tm(w), left, top, right + 1, bottom + 1)) {
		} else {
			return;
		}
		if (al_is_clipped(w, al_window_tm(w), left, top, right + 1, bottom + 1)) {
			return;
		} else {
		}
	}
	child.Draw(w);
}
end_body
member
public: void Pick(Hit h);
body
{
	if (Glyph::HitTest(h)) {
	} else {
		return;
	}
	if (status == Status::Layout) {
		h.Target(this, null);
		return;
	} else {
	}
	child.Pick(h);
}
end_body
member
public: VBoxGlyph vbox;
member
public: FrameScrollGlyph scroll;
member
public: AlVScrollBar vbar;
member
public: FormGlyph child;
member
public: integer Count();
body
{
	return vbox.Count();
}
end_body
member
public: void AddItem(integer index, string s);
body
{
	var LabelGlyph label;
	label = new StaticLabel;
	label.Create(0, 0, 500, 18, s);
	vbox.Insert(index, label);
	scroll.AllocationChanged(vbox);
}
end_body
member
public: void DeleteItem(integer index);
body
{
	vbox.Remove(index);
	scroll.AllocationChanged(vbox);
}
end_body
member
public: string GetItemText(integer index);
body
{
	var TMGlyph info;
	var LabelGlyph label;
	info = vbox.Component(index);
	if (info && info.child) {
		label = info.child;
		return label.text;
	} else {
		return null;
	}
}
end_body
member
public: integer CurrentIndex();
body
{
	var TMGlyph info;
	if (info = al_dst_node(vbox.selection, "$select")) {
	} else {
		return null;
	}
	return vbox.GlyphIndex(info);
}
end_body
member
public: void CurrentIndex(integer index);
body
{
	var TMGlyph info;
	if (info = vbox.Component(index)) {
	} else {
		return;
	}
	al_set_dst_node(vbox.selection, "$select", info);
}
end_body
member
public: void AppendItem(string s);
body
{
	AddItem(Count(), s);
}
end_body
member
public: void ClearAllItems();
body
{
	if (scroll.tm) {
		scroll.tm[1][2] = 0;
	} else {
	}
	vbar.pos = 0;
	var integer i;
	i = Count() - 1;
	loop {
		if (i < 0) {
			break;
		} else {
		}
		DeleteItem(i);
		i = i - 1;
	}
}
end_body
member
public: void public_var();
body
{
	vbox;
	child;
}
end_body
member
public: list GbCode(list pif);
body
{
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var AlListBox pp;"));
	err = (err || GbCode(pif, "pp = new  AlListBox;"));
	err = (err || GbCode(pif, "pp.Create(" + GbGeom() + ");"));
	err = (err || GbAttr(pif));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
end_class
class AlComboBox
member
public: void Create(integer l, integer t, integer r, integer b);
body
{
	AlControl::Create(l, t, r, t + 20);
	label = new LabelGlyph;
	label.Create(l, t, r - 20, t + 20, "");
	child = new AlListBox;
	child.for_combo_box = 1;
	child.Create(l + 20, t + 20, r, b);
	child.status = Status::Execute;
	al_create_arc(this, child.vbox, "$selector");
}
end_body
member
public: void Resize(integer l, integer t, integer r, integer b);
body
{
	Glyph::Resize(l, t, r, t + 20);
	label.Resize(l, t, r - 20, t + 20);
	child.Resize(l + 20, t + 20, r, b);
}
end_body
member
public: integer Height();
body
{
	return 20 + child.Height();
}
end_body
member
public: void Draw(window w);
body
{
	label.Draw(w);
	var integer color;
	if (al_get_sys_color(0) != 0x0) {
		color = 0x0;
	} else {
		color = 0xffffff;
	}
	al_push_pen(w, "Solid", 0, color);
	al_push_brush(w, "Null", 0x0, null);
	al_rectangle(w, left, top, right, bottom);
	al_pop_brush(w);
	al_pop_pen(w);
	AlButton::DrawBase(w, right - 20, top, right, top + 20, frame_color, face_color, highlight_color, shadow_color);
	al_push_pen(w, "Null", 0, 0x0);
	al_push_brush(w, "Solid", text_color, null);
	var list poly;
	poly = al_create_poly_poly();
	al_add_point_to_poly(poly, right - 15, bottom - 15);
	al_add_point_to_poly(poly, right - 5, bottom - 15);
	al_add_point_to_poly(poly, right - 10, bottom - 5);
	al_polygon(w, poly);
	al_pop_brush(w);
	al_pop_pen(w);
	if (dropdown) {
		child.Draw(w);
	} else {
	}
}
end_body
member
public: void Pick(Hit h);
body
{
	if (Event::IsMouseEvent((integer)h.event.head)) {
	} else {
		return;
	}
	var list xy;
	var integer x, y;
	xy = al_inverse_xy(al_window_tm(h.wnd), h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	if (top <= y && y <= top + 20) {
		if (status == Status::Layout && left <= x && x <= right) {
			h.Target(this, null);
			return;
		} else {
		}
		if (left <= x && x <= right - 20) {
			label.Pick(h);
			return;
		} else {
		}
		if (right - 20 <= x && x <= right) {
			h.Target(this, TargetInfo::DropDown);
			return;
		} else {
		}
	} else {
	}
	if (dropdown) {
		child.Pick(h);
	} else {
	}
}
end_body
member
public: LabelGlyph label;
member
public: AlListBox child;
member
public: integer dropdown;
member
public: list Execute(Hit h);
body
{
	var integer type, modif, info;
	type = h.event.head;
	modif = h.event.tail.tail.tail.tail.head;
	info = h.info;
	if (type == Event::LeftPress && modif != 0x2) {
		if (status == Status::Execute && info == TargetInfo::DropDown && _DropDown(h)) {
			status = Status::DropDown;
			return 1;
		} else {
		}
		if (status == Status::DropDown && _DropDown(h)) {
			status = Status::Execute;
			return 1;
		} else {
		}
	} else {
	}
	return Glyph::Execute(h);
}
end_body
member
public: list ExecuteParent(integer msg, Glyph g, Hit h);
body
{
	if (msg == Message::SelectItem && status == Status::DropDown && _SelectItem(h)) {
		status = Status::Execute;
		return 1;
	} else {
	}
	return null;
}
end_body
member
public: list _DropDown(Hit h);
body
{
	if (dropdown == null) {
		dropdown = 1;
		child.Damage();
	} else {
		dropdown = null;
		child.Damage();
		Damage();
	}
	return 1;
}
end_body
member
public: list _SelectItem(Hit h);
body
{
	dropdown = null;
	child.Damage();
	var TMGlyph info;
	var LabelGlyph lab;
	info = al_dst_node(child.vbox.selection, "$select");
	lab = info.child;
	label.text = lab.text;
	Damage();
	var list itr;
	itr = al_src_itr(this);
	var Glyph g1;
	loop {
		if (g1 = al_next_a(itr, "$selector")) {
		} else {
			break;
		}
		g1.ExecuteParent(Message::SelectItem, this, h);
	}
	return 1;
}
end_body
member
public: integer CurrentIndex();
body
{
	return child.CurrentIndex();
}
end_body
member
public: void public_var();
body
{
	label;
	child;
}
end_body
member
public: list GbCode(list pif);
body
{
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var AlComboBox pp;"));
	err = (err || GbCode(pif, "pp = new  AlComboBox;"));
	err = (err || GbCode(pif, "pp.Create(" + (string)left + ", " + (string)top + ", " + (string)right + ", " + (string)(bottom + child.Height()) + ");"));
	err = (err || GbAttr(pif));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
end_class
end_class
end_class
class AlDialog
member
public: static list InputName(integer x, integer y, string title, string name);
body
{
	var FrameLabel field;
	var AlButton ok, cancel;
	var FormGlyph form;
	var TMGlyph field_info, ok_info, cancel_info;
	field = new FrameLabel;
	field.Create(0, 0, 100, 20, name);
	ok = new AlButton;
	ok.Create(0, 0, 80, 20, "Ok");
	ok.status = Status::Execute;
	cancel = new AlButton;
	cancel.Create(0, 0, 80, 20, "Cancel");
	cancel.status = Status::Execute;
	form = new FormGlyph;
	form.Create();
	form.Resize(0, 0, 400, 400);
	form.status = Status::Execute;
	field_info = form.Append(field, 0, 0);
	ok_info = form.Append(ok, 0, 0);
	cancel_info = form.Append(cancel, 0, 0);
	form.Attach(field_info, FormGlyph::Left, 0, 20);
	form.Attach(field_info, FormGlyph::Top, 0, 30);
	form.Attach(field_info, FormGlyph::Right, 0, 20);
	form.Attach(field_info, FormGlyph::Bottom, 1, 50);
	form.Attach(ok_info, FormGlyph::Left, 0, 40);
	form.Attach(ok_info, FormGlyph::Top, 0, 70);
	form.Attach(ok_info, FormGlyph::Right, 1, 120);
	form.Attach(ok_info, FormGlyph::Bottom, 1, 90);
	form.Attach(cancel_info, FormGlyph::Left, 0, 140);
	form.Attach(cancel_info, FormGlyph::Top, 0, 70);
	form.Attach(cancel_info, FormGlyph::Right, 1, 220);
	form.Attach(cancel_info, FormGlyph::Bottom, 1, 90);
	var Window w;
	w = new Window;
	w.Create(form, (list)al_list3(0x200d, null, al_list4(x, y, 300, 150)));
	w.SetTitle(title);
	var AlDialogCtrl ctrl;
	ctrl = new AlDialogCtrl;
	ctrl.wnd = w.wnd;
	ok.SetCallback(ctrl, AlDialogCtrl::OkButton);
	cancel.SetCallback(ctrl, AlDialogCtrl::CancelButton);
	al_local_loop(ctrl.wnd);
	return al_list3(w, ctrl.ok, field);
}
end_body
member
public: static list SelectName(integer x, integer y, string title, list name_list);
body
{
	var AlComboBox combo;
	var AlButton ok, cancel;
	var FormGlyph form;
	var TMGlyph combo_info, ok_info, cancel_info;
	combo = new AlComboBox;
	combo.Create(0, 0, 100, 100);
	combo.status = Status::Execute;
	var list itr;
	itr = al_dst_itr(name_list);
	var string name;
	loop {
		if (name = al_next(itr)) {
		} else {
			break;
		}
		combo.child.AppendItem(name);
	}
	ok = new AlButton;
	ok.Create(0, 0, 80, 20, "Ok");
	ok.status = Status::Execute;
	cancel = new AlButton;
	cancel.Create(0, 0, 80, 20, "Cancel");
	cancel.status = Status::Execute;
	form = new FormGlyph;
	form.Create();
	form.Resize(0, 0, 400, 400);
	form.status = Status::Execute;
	ok_info = form.Append(ok, 0, 0);
	cancel_info = form.Append(cancel, 0, 0);
	combo_info = form.Append(combo, 0, 0);
	form.Attach(combo_info, FormGlyph::Left, 0, 20);
	form.Attach(combo_info, FormGlyph::Top, 0, 30);
	form.Attach(combo_info, FormGlyph::Right, 0, 20);
	form.Attach(combo_info, FormGlyph::Bottom, 0, 20);
	form.Attach(ok_info, FormGlyph::Left, 0, 40);
	form.Attach(ok_info, FormGlyph::Top, 0, 70);
	form.Attach(ok_info, FormGlyph::Right, 1, 120);
	form.Attach(ok_info, FormGlyph::Bottom, 1, 90);
	form.Attach(cancel_info, FormGlyph::Left, 0, 140);
	form.Attach(cancel_info, FormGlyph::Top, 0, 70);
	form.Attach(cancel_info, FormGlyph::Right, 1, 220);
	form.Attach(cancel_info, FormGlyph::Bottom, 1, 90);
	var Window w;
	w = new Window;
	w.Create(form, (list)al_list3(0x200d, null, al_list4(x, y, 300, 180)));
	w.SetTitle(title);
	var AlDialogCtrl ctrl;
	ctrl = new AlDialogCtrl;
	ctrl.wnd = w.wnd;
	ok.SetCallback(ctrl, AlDialogCtrl::OkButton);
	cancel.SetCallback(ctrl, AlDialogCtrl::CancelButton);
	al_local_loop(ctrl.wnd);
	return al_list3(w, ctrl.ok, combo);
}
end_body
member
public: static list ChooseName(integer x, integer y, string title, string text, string str1, string str2, string str3, string str4);
body
{
	var FormGlyph form;
	form = new FormGlyph;
	form.Create();
	form.Resize(0, 0, 400, 400);
	form.status = Status::Execute;
	var StaticLabel label;
	var AlButton btn1, btn2, btn3, btn4;
	var TMGlyph label_info;
	var TMGlyph btn1_info, btn2_info, btn3_info, btn4_info;
	label = new StaticLabel;
	label.Create(0, 0, 300, 20, text);
	label.status = Status::Execute;
	label_info = form.Append(label, 0, 0);
	form.Attach(label_info, FormGlyph::Left, 0, 20);
	form.Attach(label_info, FormGlyph::Top, 0, 10);
	form.Attach(label_info, FormGlyph::Right, 0, 20);
	form.Attach(label_info, FormGlyph::Bottom, 1, 40);
	if (str1 != "") {
		btn1 = new AlButton;
		btn1.Create(0, 0, 80, 20, str1);
		btn1.status = Status::Execute;
		btn1_info = form.Append(btn1, 0, 0);
		form.Attach(btn1_info, FormGlyph::Left, 0, 20);
		form.Attach(btn1_info, FormGlyph::Top, 0, 40);
		form.Attach(btn1_info, FormGlyph::Right, 1, 100);
		form.Attach(btn1_info, FormGlyph::Bottom, 1, 60);
	} else {
	}
	if (str2 != "") {
		btn2 = new AlButton;
		btn2.Create(0, 0, 80, 20, str2);
		btn2.status = Status::Execute;
		btn2_info = form.Append(btn2, 0, 0);
		form.Attach(btn2_info, FormGlyph::Left, 0, 120);
		form.Attach(btn2_info, FormGlyph::Top, 0, 40);
		form.Attach(btn2_info, FormGlyph::Right, 1, 200);
		form.Attach(btn2_info, FormGlyph::Bottom, 1, 60);
	} else {
	}
	if (str3 != "") {
		btn3 = new AlButton;
		btn3.Create(0, 0, 80, 20, str3);
		btn3.status = Status::Execute;
		btn3_info = form.Append(btn3, 0, 0);
		form.Attach(btn3_info, FormGlyph::Left, 0, 220);
		form.Attach(btn3_info, FormGlyph::Top, 0, 40);
		form.Attach(btn3_info, FormGlyph::Right, 1, 300);
		form.Attach(btn3_info, FormGlyph::Bottom, 1, 60);
	} else {
	}
	if (str4 != "") {
		btn4 = new AlButton;
		btn4.Create(0, 0, 80, 20, str4);
		btn4.status = Status::Execute;
		btn4_info = form.Append(btn4, 0, 0);
		form.Attach(btn4_info, FormGlyph::Left, 0, 320);
		form.Attach(btn4_info, FormGlyph::Top, 0, 40);
		form.Attach(btn4_info, FormGlyph::Right, 1, 400);
		form.Attach(btn4_info, FormGlyph::Bottom, 1, 60);
	} else {
	}
	var Window w;
	w = new Window;
	w.Create(form, (list)al_list3(0x200d, null, al_list4(x, y, 420, 100)));
	w.SetTitle(title);
	var AlDialogCtrl ctrl;
	ctrl = new AlDialogCtrl;
	ctrl.wnd = w.wnd;
	if (btn1) {
		ctrl.str1 = str1;
		btn1.SetCallback(ctrl, AlDialogCtrl::Button1);
	} else {
	}
	if (btn2) {
		ctrl.str2 = str2;
		btn2.SetCallback(ctrl, AlDialogCtrl::Button2);
	} else {
	}
	if (btn3) {
		ctrl.str3 = str3;
		btn3.SetCallback(ctrl, AlDialogCtrl::Button3);
	} else {
	}
	if (btn4) {
		ctrl.str4 = str4;
		btn4.SetCallback(ctrl, AlDialogCtrl::Button4);
	} else {
	}
	al_local_loop(ctrl.wnd);
	return al_list2(w, ctrl.choice);
}
end_body
member
public: list ShowInput(integer x, integer y, string title, string name);
body
{
	var list l;
	var Window w;
	var LabelGlyph lab;
	l = InputName(x, y, title, name);
	w = l.head;
	w.Destroy();
	if (l.tail.head) {
	} else {
		return null;
	}
	lab = l.tail.tail.head;
	text = lab.text;
	return 1;
}
end_body
member
public: list ShowSelect(integer x, integer y, string title, list name_list);
body
{
	var list l;
	var Window w;
	var AlComboBox combo;
	l = SelectName(x, y, title, name_list);
	w = l.head;
	w.Destroy();
	if (l.tail.head) {
	} else {
		return null;
	}
	combo = l.tail.tail.head;
	text = combo.label.text;
	return 1;
}
end_body
member
public: list ShowChoose(integer x, integer y, string title, string text, string str1, string str2, string str3, string str4);
body
{
	var list l;
	var Window w;
	l = ChooseName(x, y, title, text, str1, str2, str3, str4);
	w = l.head;
	w.Destroy();
	this.text = l.tail.head;
	return 1;
}
end_body
member
public: list ShowInput(string title, string name);
body
{
	return ShowInput(100, 100, title, name);
}
end_body
member
public: list ShowSelect(string title, list name_list);
body
{
	return ShowSelect(100, 100, title, name_list);
}
end_body
member
public: list ShowChoose(string title, string text, string str1, string str2, string str3, string str4);
body
{
	return ShowChoose(100, 100, title, text, str1, str2, str3, str4);
}
end_body
member
public: list text;
class AlDialogCtrl
member
public: void OkButton();
body
{
	ok = 1;
	al_exit_loop(wnd);
}
end_body
member
public: void CancelButton();
body
{
	ok = null;
	al_exit_loop(wnd);
}
end_body
member
public: list ok;
member
public: window wnd;
member
public: void Button1();
body
{
	choice = str1;
	al_exit_loop(wnd);
}
end_body
member
public: void Button2();
body
{
	choice = str2;
	al_exit_loop(wnd);
}
end_body
member
public: void Button3();
body
{
	choice = str3;
	al_exit_loop(wnd);
}
end_body
member
public: void Button4();
body
{
	choice = str4;
	al_exit_loop(wnd);
}
end_body
member
public: list str1;
member
public: list str2;
member
public: list str3;
member
public: list str4;
member
public: list choice;
end_class
end_class
class AlMenu
member
public: void Clear();
body
{
	menu = null;
}
end_body
member
public: void Append(string s, AlMenu sub, GUI obj, GUIfunc func);
body
{
	if (menu) {
	} else {
		menu = al_cons(null, null);
	}
	var list item;
	item = al_list4(s, sub, obj, func);
	al_create_arc(menu, item, null);
}
end_body
member
public: void Append(string s, AlMenu sub);
body
{
	Append(s, sub, (GUI)null, (GUIfunc)null);
}
end_body
member
public: void Append(string s, GUI obj, GUIfunc func);
body
{
	Append(s, (AlMenu)null, obj, func);
}
end_body
member
public: void Execute(window w, list event);
body
{
	if (menu) {
	} else {
		return;
	}
	var list item;
	if (item = al_menu_select(w, event, menu)) {
	} else {
		return;
	}
	var GUI obj;
	var GUIfunc func;
	obj = item.tail.tail.head;
	func = item.tail.tail.tail.head;
	if (obj && func) {
		obj.*func();
	} else {
	}
}
end_body
member
public: list menu;
end_class
end_class
$END_BODY
