guicore.alb
parallel.alb
syslib.alb
$END_LIB
TEXT
PrimitiveGlyph
class GpPrimitive
class GpClass
end_class
class GpObject
end_class
class GpFunc
end_class
class GpPort
end_class
end_class
TEXT
GraphEditor
class GpEditor
end_class
TEXT
GlyphEditor
class GUIbuilder
end_class
TEXT
Glyph
class GbGp
class GbGpPanel
end_class
class GbGpCtrl
end_class
class GbCtrl
end_class
class GpClassCtrl
end_class
class GpMemberCtrl
end_class
class GpBodyCtrl
end_class
class GpTranslator
end_class
end_class
TEXT
Glyph
class OcxGlyph
end_class
$END_CLASS
TEXT
PrimitiveGlyph
class GpPrimitive
member
public: void Create();
member
public: integer face_color;
member
public: integer highlight_color;
member
public: integer shadow_color;
member
public: integer frame_color;
member
public: void MakeSpaceIndex();
member
public: void ClearSpaceIndex();
class GpClass
member
public: void Create();
member
public: void Draw(window w);
member
public: list Execute(Hit h);
end_class
class GpObject
member
public: void Create();
member
public: void Draw(window w);
member
public: list HitTest(Hit h);
end_class
class GpFunc
member
public: void Create();
member
public: void Draw(window w);
member
public: list Execute(Hit h);
end_class
class GpPort
member
public: void Create();
member
public: void Draw(window w);
end_class
end_class
TEXT
GraphEditor
class GpEditor
member
public: static void Init();
member
public: static integer ClassNode;
member
public: static integer ObjectNode;
member
public: static integer VFuncNode;
member
public: static integer SFuncNode;
member
public: static integer SysFuncNode;
member
public: static integer MacroNode;
member
public: static integer ExtCtrlIn;
member
public: static integer ExtCtrlOut;
member
public: static integer ExtDataIn;
member
public: static integer ExtDataOut;
member
public: static integer ObjPort;
member
public: static integer CtrlIn;
member
public: static integer CtrlOut;
member
public: static integer DataIn;
member
public: static integer DataOut;
member
public: static integer SubClassArc;
member
public: static integer MemberVarArc;
member
public: static integer MemberFuncArc;
member
public: static integer DataArc;
member
public: static integer ControlArc;
member
public: list IsLeftPort(list elem);
member
public: list IsRightPort(list elem);
member
public: list IsArcSrc(list src);
member
public: list IsConnectableCtrl(list src, list dst);
member
public: list IsConnectableData(list src, list dst);
member
public: list Execute(Hit h);
member
public: static integer PutClass;
member
public: static integer PutObject;
member
public: static integer PutVFunc;
member
public: static integer PutSFunc;
member
public: static integer PutSysFunc;
member
public: static integer PutMacro;
member
public: static integer PutWizardNew;
member
public: static integer PutWizardWindow;
member
public: list _PutClass(Hit h);
member
public: list _PutObject(Hit h);
member
public: list _PutVFunc(Hit h);
member
public: list _PutSFunc(Hit h);
member
public: list _PutSysFunc(Hit h);
member
public: list _PutMacro(Hit h);
member
public: list _PutWizardNew(Hit h);
member
public: list _PutWizardWindow(Hit h);
member
public: list _BeginArc(Hit h, TMGlyph info);
member
public: list _EndArc(Hit h, TMGlyph info);
member
public: list CreateLabel(list elem, string s, integer x, integer y);
member
public: void DoMove(integer dx, integer dy);
member
public: void MovePort(list port, integer dx, integer dy);
member
public: list IsSelected(list elem);
member
public: void AllocationChanged(Glyph g);
member
public: void AdjustRootNode(list node);
member
public: integer AdjustLeftPort(list port, integer t, integer r);
member
public: integer AdjustRightPort(list port, integer t, integer l);
member
public: static integer PortWidth;
member
public: static integer PortHeight;
member
public: static integer PortPitch;
member
public: list CreatePort(integer kind, integer lab, string text, integer x, integer y);
member
public: void CreateExtPort(list node);
member
public: list _CreateExtPort(integer type, list port);
member
public: string SelectClass();
member
public: string SelectSubClass(string class_name);
member
public: integer SelectSysFunc();
member
public: static list Dst(list src_p);
member
public: static list Src(list dst_p, list obj, list arg);
member
public: static list Inside(list prt, list id_ls, list dst, list obj, list arg);
member
public: static list Outside(list prt, list id_ls, list dst, list obj, list arg);
member
public: static list Mark(list node);
member
public: static void Mark(list node, list info);
member
public: static list StartPort(list _fn);
member
public: static list Root(list prt);
member
public: static list IfTruePort(list node);
member
public: static list IfFalsePort(list node);
member
public: static list SeqPort(list node);
member
public: static list ParaPort(list node);
member
public: static list CtrlInPort(list node);
member
public: static list CtrlOutPort(list node);
member
public: static list DataInPort(list node);
member
public: static list DataOutPort(list node);
member
public: static list GetObjPort(list node);
member
public: static list IsExtCtrlIn(list prt);
member
public: static list IsExtCtrlOut(list prt);
member
public: static list IsExtDataIn(list prt);
member
public: static list IsExtDataOut(list prt);
member
public: static list IsCtrlIn(list prt);
member
public: static list IsCtrlOut(list prt);
member
public: static list IsDataIn(list prt);
member
public: static list IsDataOut(list prt);
member
public: static list IsObjPort(list prt);
member
public: static list IsNodePort(list prt);
member
public: static list IsExtPort(list prt);
member
public: static list IsClassNode(list node);
member
public: static list IsObjectNode(list node);
member
public: static list IsMacroNode(list node);
member
public: static list IsFuncNode(list node);
member
public: static list IsBranchNode(list node);
member
public: static list IsNewNode(list node);
member
public: static list IsParaNode(list node);
member
public: static list IsMultiCtrlIn(list node);
member
public: void ClearSpaceIndex();
member
public: void MakeSpaceIndex();
end_class
TEXT
GlyphEditor
class GUIbuilder
member
public: void Create(integer l, integer t, integer r, integer b);
member
public: void Resize(integer l, integer t, integer r, integer b);
member
public: void MoveControl(window w);
member
public: void Draw(window w);
member
public: void Pick(Hit h);
member
public: void Destroy();
member
public: list first_movectrl;
member
public: void Attach(TMGlyph info, integer what, integer opposite, integer offset);
member
public: list attachment;
member
public: void LayoutMode();
member
public: void ExecuteMode();
member
public: list Execute(Hit h);
member
public: list _InsertObject(Hit h);
member
public: list parts;
member
public: void ChangeName();
member
public: void ChangeXCoord();
member
public: void ChangeYCoord();
member
public: void ChangeAttrib();
member
public: void AlignHorizTop();
member
public: void AlignHorizCenter();
member
public: void AlignHorizBottom();
member
public: void AlignVertLeft();
member
public: void AlignVertCenter();
member
public: void AlignVertRight();
member
public: void AlignWidth();
member
public: void AlignHeight();
member
public: void AttachLeft();
member
public: void AttachTop();
member
public: void AttachRight();
member
public: void AttachBottom();
member
public: void AttachOppositeLeft();
member
public: void AttachOppositeTop();
member
public: void AttachOppositeRight();
member
public: void AttachOppositeBottom();
member
public: void DetachLeft();
member
public: void DetachTop();
member
public: void DetachRight();
member
public: void DetachBottom();
member
public: void ConnectScroll();
member
public: void Delete();
member
public: static list proj_info;
member
public: static string GetPath();
member
public: static string _GetPath();
member
public: static string GetEditorID();
member
public: static string GetOcxSubStgID();
member
public: window wnd;
member
public: void public_func();
member
public: list GenerateCode();
member
public: void SaveEditor(Glyph g);
member
public: static variant LoadPicture(string name);
member
public: AlMenu custom_menu;
member
public: list GbInit();
member
public: integer back_color;
member
public: integer border_width;
member
public: integer light_color;
member
public: integer shadow_color;
member
public: void public_var();
member
public: list GbCode(list pif);
member
public: static GUIbuilder CreateWindow(string name, list style, list parent, list geom);
member
public: static list CreateWindow2(string name, list style, list parent, list geom);
member
public: static GUIbuilder CreateWindow(string name);
member
public: static list CreateWindow2(string name);
member
public: void AfterFirstMoveControl();
member
public: void BeforeDestroy();
member
public: void Close();
end_class
TEXT
Glyph
class GbGp
member
public: static void Run();
member
public: static void AutoExec();
member
public: window wnd;
member
public: GpEditor editor;
member
public: void PutClass();
member
public: void PutObject();
member
public: void Copy();
member
public: void Paste();
member
public: void Delete();
class GbGpPanel
member
public: void Create();
member
public: FormGlyph CreateGb();
member
public: FormGlyph CreateGp();
member
public: void Resize(integer l, integer t, integer r, integer b);
member
public: void Draw(window w);
member
public: void Pick(Hit h);
member
public: list ExecuteParent(integer msg, Glyph g, Hit h);
member
public: FormGlyph child;
member
public: LabelGlyph proj_lab;
member
public: AlComboBox proj;
member
public: AlButton new_proj;
member
public: AlButton open_proj;
member
public: AlButton save_proj;
member
public: AlButton clear_proj;
member
public: AlButton exec_proj;
member
public: AlButton pkg_proj;
member
public: LabelGlyph gamen_kind_lab;
member
public: AlComboBox gamen_kind;
member
public: PatchGlyph gamen_select;
member
public: FormGlyph gb_select;
member
public: LabelGlyph gb_name_label;
member
public: LabelGlyph gb_name_field;
member
public: LabelGlyph gb_class_label;
member
public: LabelGlyph gb_class_field;
member
public: AlListBox gb_list;
member
public: AlButton new_gb;
member
public: AlButton open_gb;
member
public: AlButton delete_gb;
member
public: FormGlyph gp_select;
member
public: LabelGlyph gp_name_label;
member
public: LabelGlyph gp_name_field;
member
public: AlListBox gp_list;
member
public: AlButton new_gp;
member
public: AlButton open_gp;
member
public: AlButton delete_gp;
member
public: GbGpCtrl ctrl;
member
public: list projects;
member
public: void CreateClassList();
member
public: void _Append(string class_name);
member
public: list public_class;
member
public: static GbGpPanel inst;
end_class
class GbGpCtrl
member
public: void PanelProjNew();
member
public: void PanelProjOpen();
member
public: void _PanelProjOpen(string dir, string name);
member
public: void PanelProjSave();
member
public: void PanelProjClose();
member
public: void PanelProjExec();
member
public: void PanelProjPkg();
member
public: void PanelGbNew();
member
public: void PanelGbOpen();
member
public: void PanelGbDelete();
member
public: void PanelGpNew();
member
public: void PanelGpOpen();
member
public: void PanelGpDelete();
member
public: static GUIbuilder OpenGUIbuilder(string title, string class_name, list rect);
member
public: static GpEditor OpenGpClass(string title);
member
public: static GpEditor OpenGpMember(string title, string class_name);
member
public: static GpEditor OpenGpBody(string title, string class_name);
member
public: list GetProject(list projects, string proj_name);
member
public: list GetProject(list projects, string dir, string name);
member
public: void ListUpGbGp();
member
public: static list GetGamen(list proj_info, string gamen_name, string attr);
member
public: static list GetGbGamenByClass(list proj_info, string class_name);
member
public: void UpdateGbGamenName();
member
public: void UpdateGpGamenName();
member
public: static GbGpCtrl inst;
end_class
class GbCtrl
member
public: GUIbuilder editor;
member
public: void PutRectangle();
member
public: void PutEllipse();
member
public: void PutLine();
member
public: void PutArrowLine();
member
public: void PutPath();
member
public: void PutArrowPath();
member
public: void PutLabel();
member
public: void PutMLabel();
member
public: void PutFrameLabel();
member
public: void PutStatic();
member
public: void PutImage();
member
public: void PutButton();
member
public: void PutVScrollBar();
member
public: void PutHScrollBar();
member
public: void PutListBox();
member
public: void PutComboBox();
member
public: void PutPictEditor();
member
public: void PutGraphEditor();
member
public: void PutHierEditor();
member
public: void PutTableEditor();
member
public: void PutTextEditor();
member
public: void PutOcx();
member
public: void PutGUIbuilder();
member
public: void Raise();
member
public: void Lower();
member
public: void Delete();
member
public: void LayoutMode();
member
public: void ExecuteMode();
member
public: void AlignHorizTop();
member
public: void AlignHorizCenter();
member
public: void AlignHorizBottom();
member
public: void AlignVertLeft();
member
public: void AlignVertCenter();
member
public: void AlignVertRight();
member
public: void AlignWidth();
member
public: void AlignHeight();
member
public: void AttachLeft();
member
public: void AttachTop();
member
public: void AttachRight();
member
public: void AttachBottom();
member
public: void AttachOppositeLeft();
member
public: void AttachOppositeTop();
member
public: void AttachOppositeRight();
member
public: void AttachOppositeBottom();
member
public: void DetachLeft();
member
public: void DetachTop();
member
public: void DetachRight();
member
public: void DetachBottom();
member
public: void ConnectScroll();
member
public: void GenerateCode();
member
public: void ChangeName();
member
public: void ChangeXCoord();
member
public: void ChangeYCoord();
member
public: void ChangeAttrib();
member
public: void AppendCustom();
member
public: void UpdateCustom();
member
public: list pif;
member
public: void Insert(string s);
end_class
class GpClassCtrl
member
public: void NewClass();
member
public: void MemberVar();
member
public: list IsSaveClass(list save_cl, string class_name);
end_class
class GpMemberCtrl
member
public: void PutVFunc();
member
public: void PutSFunc();
member
public: void ChildPort();
member
public: void PortInsert();
member
public: void PortAppend();
member
public: void ConnectArc();
member
public: void RegistFunc();
member
public: void NormalTranslate();
member
public: void Level1Translate();
member
public: void Level2Translate();
member
public: void _Translate();
member
public: list debug;
member
public: list debug2;
member
public: void Interpret();
end_class
class GpBodyCtrl
member
public: void CopyObject();
member
public: void Constant();
member
public: void This();
member
public: void MemberVar();
member
public: void MemberFunc();
member
public: void PutSysFunc();
member
public: void PutMacro();
member
public: void ChildPort();
member
public: void PortInsert();
member
public: void PortAppend();
member
public: void ConnectArc();
member
public: void ViewLarge();
member
public: void ViewSmall();
member
public: void WizardNew();
member
public: void WizardWindow();
member
public: void WizardCallback();
end_class
class GpTranslator
member
public: list GenerateCode(list fn, string class_name, string func_name, list arg_dcl);
member
public: list MarkNext();
member
public: list MarkMain();
member
public: void MarkNode(list node);
member
public: list UnmarkNext();
member
public: list UnmarkMain();
member
public: list VarDclNext();
member
public: list VarDclMain();
member
public: list CodeBegin();
member
public: list CodeNext();
member
public: list CodeMain();
member
public: list CodeEnd();
member
public: list CodeBranch();
member
public: list CodePara();
member
public: list _func_node;
member
public: list pif;
member
public: list port;
member
public: list func_node;
member
public: integer id;
member
public: integer status;
member
public: integer prev_status;
member
public: list obj_id_tbl;
member
public: list port_stack;
member
public: list gui_stack;
member
public: integer err;
member
public: list LineInsert();
member
public: string ins_str;
member
public: list debug;
member
public: void TraceNode(string s, list node, string attr);
member
public: list debug2;
end_class
end_class
TEXT
Glyph
class OcxGlyph
member
public: void Create(string progID, integer l, integer t, integer r, integer b, list v, string subStgID);
member
public: void MoveControl(window w);
member
public: void Draw(window w);
member
public: void Destroy();
member
public: string ProgID();
member
public: list RuntimeVisible();
member
public: string SubStgID();
member
public: list IsCreated();
member
public: void BringWindowToTop(list flag);
member
public: list Execute(Hit h);
member
public: list _Edit(Hit h);
member
public: string Filename();
member
public: void Filename(string filename);
member
public: void Mode(list mode);
member
public: variant object();
member
public: void SetCallback(string eventName, GUI obj, GUIfunc func);
member
public: window Wnd();
member
public: list _ocx;
member
public: void public_func();
member
public: list GbCode(list pif);
member
public: RootGlyph root;
member
public: void PreLoad();
member
public: void PostLoad();
end_class
$END_MEMBER
TEXT
PrimitiveGlyph
class GpPrimitive
member
public: void Create();
body
{
	Glyph::Create();
	highlight_color = 0xffffff;
	shadow_color = 0x808080;
	frame_color = 0x0;
}
end_body
member
public: integer face_color;
member
public: integer highlight_color;
member
public: integer shadow_color;
member
public: integer frame_color;
member
public: void MakeSpaceIndex();
body
{
	var list data;
	if (data = al_dst_node(this, "$child_data")) {
	} else {
		return;
	}
	var Glyph g;
	g = data.tail.tail.tail.head;
	g.MakeSpaceIndex();
}
end_body
member
public: void ClearSpaceIndex();
body
{
	var list data;
	if (data = al_dst_node(this, "$child_data")) {
	} else {
		return;
	}
	var Glyph g;
	g = data.tail.tail.tail.head;
	g.ClearSpaceIndex();
}
end_body
class GpClass
member
public: void Create();
body
{
	GpPrimitive::Create();
	Glyph::Resize(0, 0, 20, 20);
	face_color = 0xffc0c0;
}
end_body
member
public: void Draw(window w);
body
{
	if (al_is_damaged(w, al_window_tm(w), left, top, right, bottom)) {
	} else {
		return;
	}
	AlButton::DrawBase(w, left, top, right, bottom, frame_color, face_color, highlight_color, shadow_color);
}
end_body
member
public: list Execute(Hit h);
body
{
	var integer type;
	var GpEditor parent;
	type = h.event.head;
	parent = h.parent;
	var list node, label;
	var TMGlyph node_info, label_info;
	var LabelGlyph lab;
	node_info = al_src_node(this, "child");
	node = al_src_node(node_info, "$geom");
	label = al_src_node(node, "$refer");
	label_info = al_dst_node(label, "$geom");
	lab = label_info.child;
	if (type == Event::LeftDoubleClick && parent.type == 1) {
		var GpEditor editor;
		editor = GbGpCtrl::OpenGpMember("Class " + lab.text, lab.text);
		al_set_dst_node(node, "$gp_macro", editor);
		var list gamen_data_root;
		if (gamen_data_root = al_dst_node(this, "$child_data")) {
			editor.labels = gamen_data_root.head;
			editor.arcs = gamen_data_root.tail.head;
			editor.nodes = gamen_data_root.tail.tail.head;
			editor.child = gamen_data_root.tail.tail.tail.head;
			editor.Damage();
		} else {
			gamen_data_root = al_list4(editor.labels, editor.arcs, editor.nodes, editor.child);
			al_create_arc(this, gamen_data_root, "$child_data");
		}
		return 1;
	} else {
	}
	return Glyph::Execute(h);
}
end_body
end_class
class GpObject
member
public: void Create();
body
{
	GpPrimitive::Create();
	Glyph::Resize(0, 0, 20, 20);
	face_color = 0xc0ffc0;
}
end_body
member
public: void Draw(window w);
body
{
	if (al_is_damaged(w, al_window_tm(w), left, top, right, bottom)) {
	} else {
		return;
	}
	al_push_pen(w, "Null", 0, 0x0);
	al_push_brush(w, "Solid", highlight_color, null);
	al_pie(w, left, top, right, bottom, 1000, -1000, -1000, 1000);
	al_pop_brush(w);
	al_push_brush(w, "Solid", shadow_color, null);
	al_pie(w, left, top, right, bottom, -1000, 1000, 1000, -1000);
	al_pop_brush(w);
	al_push_brush(w, "Solid", face_color, null);
	al_ellipse(w, left + 2, top + 2, right - 2, bottom - 2);
	al_pop_brush(w);
	al_pop_pen(w);
	al_push_pen(w, "Solid", 0, frame_color);
	al_push_brush(w, "Null", 0x0, null);
	al_ellipse(w, left, top, right, bottom);
	al_pop_brush(w);
	al_pop_pen(w);
}
end_body
member
public: list HitTest(Hit h);
body
{
	return EllipseGlyph::HitTest(h);
}
end_body
end_class
class GpFunc
member
public: void Create();
body
{
	GpPrimitive::Create();
	Glyph::Resize(0, 0, 50, 50);
	face_color = 0xffffc0;
}
end_body
member
public: void Draw(window w);
body
{
	if (al_is_damaged(w, al_window_tm(w), left, top, right, bottom)) {
	} else {
		return;
	}
	AlButton::DrawBase(w, left, top, right, bottom, frame_color, face_color, highlight_color, shadow_color);
}
end_body
member
public: list Execute(Hit h);
body
{
	var integer type;
	var GraphEditor parent;
	type = h.event.head;
	parent = h.parent;
	var list node, label;
	var TMGlyph node_info, label_info;
	var LabelGlyph lab;
	node_info = al_src_node(this, "child");
	node = al_src_node(node_info, "$geom");
	label = al_src_node(node, "$refer");
	label_info = al_dst_node(label, "$geom");
	lab = label_info.child;
	if (type == Event::LeftDoubleClick && (parent.type == 2 || parent.type == 3 && node.tail.head == GpEditor::MacroNode)) {
		var GpEditor editor;
		if (parent.type == 2) {
			editor = GbGpCtrl::OpenGpBody("Member " + lab.text, parent.class_name);
		} else {
			editor = GbGpCtrl::OpenGpBody("Macro " + lab.text, parent.class_name);
		}
		al_set_dst_node(node, "$gp_macro", editor);
		var list gamen_data_root;
		if (gamen_data_root = al_dst_node(this, "$child_data")) {
			editor.labels = gamen_data_root.head;
			editor.arcs = gamen_data_root.tail.head;
			editor.nodes = gamen_data_root.tail.tail.head;
			editor.child = gamen_data_root.tail.tail.tail.head;
			editor.Damage();
		} else {
			gamen_data_root = al_list4(editor.labels, editor.arcs, editor.nodes, editor.child);
			al_create_arc(this, gamen_data_root, "$child_data");
			editor.CreateExtPort(node);
		}
		return 1;
	} else {
	}
	return Glyph::Execute(h);
}
end_body
end_class
class GpPort
member
public: void Create();
body
{
	GpPrimitive::Create();
	Glyph::Resize(0, 0, 20, 20);
	face_color = 0xc0ffff;
}
end_body
member
public: void Draw(window w);
body
{
	if (al_is_damaged(w, al_window_tm(w), left, top, right, bottom)) {
	} else {
		return;
	}
	var list port;
	var TMGlyph info;
	if (info = al_src_node(this, "child")) {
	} else {
		return;
	}
	port = al_src_node(info, "$geom");
	if (port && port.head == 1) {
	} else {
		return;
	}
	var list t;
	t = port.tail.head;
	if (t == GpEditor::CtrlIn || t == GpEditor::DataIn || t == GpEditor::ExtCtrlOut || t == GpEditor::ExtDataOut) {
		al_push_pen(w, "Solid", 0, frame_color);
		al_push_brush(w, "Solid", face_color, null);
		al_rectangle(w, left, top, right, bottom);
		al_pop_brush(w);
		al_pop_pen(w);
		var list poly;
		al_push_pen(w, "Null", 0, 0x0);
		al_push_brush(w, "Solid", highlight_color, null);
		poly = al_create_poly_poly();
		al_add_point_to_poly(poly, left + 1, bottom - 1);
		al_add_point_to_poly(poly, left + 1, top + 1);
		al_add_point_to_poly(poly, right - 1, top + 1);
		al_add_point_to_poly(poly, right - 3, top + 3);
		al_add_point_to_poly(poly, left + 3, top + 3);
		al_add_point_to_poly(poly, left + 3, bottom - 3);
		al_add_point_to_poly(poly, left + 1, bottom - 1);
		al_polygon(w, poly);
		al_pop_brush(w);
		al_push_brush(w, "Solid", shadow_color, null);
		poly = al_create_poly_poly();
		al_add_point_to_poly(poly, right, bottom);
		al_add_point_to_poly(poly, left, bottom);
		al_add_point_to_poly(poly, left + 2, bottom - 2);
		al_add_point_to_poly(poly, right - 2, bottom - 2);
		al_add_point_to_poly(poly, right, bottom);
		al_polygon(w, poly);
		al_pop_brush(w);
		al_pop_pen(w);
	} else {
	}
	if (t == GpEditor::CtrlOut || t == GpEditor::DataOut || t == GpEditor::ExtCtrlIn || t == GpEditor::ExtDataIn) {
		al_push_pen(w, "Solid", 0, frame_color);
		al_push_brush(w, "Solid", face_color, null);
		al_rectangle(w, left, top, right, bottom);
		al_pop_brush(w);
		al_pop_pen(w);
		var list poly;
		al_push_pen(w, "Null", 0, 0x0);
		al_push_brush(w, "Solid", highlight_color, null);
		poly = al_create_poly_poly();
		al_add_point_to_poly(poly, left + 1, top + 1);
		al_add_point_to_poly(poly, right - 1, top + 1);
		al_add_point_to_poly(poly, right - 3, top + 3);
		al_add_point_to_poly(poly, left + 3, top + 3);
		al_add_point_to_poly(poly, left + 1, top + 1);
		al_polygon(w, poly);
		al_pop_brush(w);
		al_push_brush(w, "Solid", shadow_color, null);
		poly = al_create_poly_poly();
		al_add_point_to_poly(poly, right, top);
		al_add_point_to_poly(poly, right, bottom);
		al_add_point_to_poly(poly, left, bottom);
		al_add_point_to_poly(poly, left + 2, bottom - 2);
		al_add_point_to_poly(poly, right - 2, bottom - 2);
		al_add_point_to_poly(poly, right - 2, top + 2);
		al_add_point_to_poly(poly, right, top);
		al_polygon(w, poly);
		al_pop_brush(w);
		al_pop_pen(w);
	} else {
	}
	if (t == GpEditor::ObjPort) {
		al_push_pen(w, "Solid", 0, frame_color);
		al_push_brush(w, "Solid", face_color, null);
		al_rectangle(w, left, top, right, bottom);
		al_pop_brush(w);
		al_pop_pen(w);
		var list poly;
		al_push_pen(w, "Null", 0, 0x0);
		al_push_brush(w, "Solid", highlight_color, null);
		poly = al_create_poly_poly();
		al_add_point_to_poly(poly, left + 1, bottom - 1);
		al_add_point_to_poly(poly, left + 1, top + 1);
		al_add_point_to_poly(poly, left + 3, top + 3);
		al_add_point_to_poly(poly, left + 3, bottom - 3);
		al_add_point_to_poly(poly, left + 1, bottom - 1);
		al_polygon(w, poly);
		al_pop_brush(w);
		al_push_brush(w, "Solid", shadow_color, null);
		poly = al_create_poly_poly();
		al_add_point_to_poly(poly, right, top);
		al_add_point_to_poly(poly, right, bottom);
		al_add_point_to_poly(poly, left, bottom);
		al_add_point_to_poly(poly, left + 2, bottom - 2);
		al_add_point_to_poly(poly, right - 2, bottom - 2);
		al_add_point_to_poly(poly, right - 2, top + 2);
		al_add_point_to_poly(poly, right, top);
		al_polygon(w, poly);
		al_pop_brush(w);
		al_pop_pen(w);
	} else {
	}
}
end_body
end_class
end_class
TEXT
GraphEditor
class GpEditor
member
public: static void Init();
body
{
	ClassNode = 1;
	ObjectNode = 2;
	VFuncNode = 3;
	SFuncNode = 4;
	SysFuncNode = 5;
	MacroNode = 6;
	ExtCtrlIn = 10;
	ExtCtrlOut = 11;
	ExtDataIn = 12;
	ExtDataOut = 13;
	ObjPort = 14;
	CtrlIn = 15;
	CtrlOut = 16;
	DataIn = 17;
	DataOut = 18;
	SubClassArc = 20;
	MemberVarArc = 21;
	MemberFuncArc = 22;
	DataArc = 23;
	ControlArc = 24;
	PutClass = 100;
	PutObject = 101;
	PutVFunc = 102;
	PutSFunc = 103;
	PutSysFunc = 104;
	PutMacro = 105;
	PutWizardNew = 200;
	PutWizardWindow = 201;
	PortWidth = 12;
	PortHeight = 12;
	PortPitch = 2;
}
end_body
member
public: static integer ClassNode;
member
public: static integer ObjectNode;
member
public: static integer VFuncNode;
member
public: static integer SFuncNode;
member
public: static integer SysFuncNode;
member
public: static integer MacroNode;
member
public: static integer ExtCtrlIn;
member
public: static integer ExtCtrlOut;
member
public: static integer ExtDataIn;
member
public: static integer ExtDataOut;
member
public: static integer ObjPort;
member
public: static integer CtrlIn;
member
public: static integer CtrlOut;
member
public: static integer DataIn;
member
public: static integer DataOut;
member
public: static integer SubClassArc;
member
public: static integer MemberVarArc;
member
public: static integer MemberFuncArc;
member
public: static integer DataArc;
member
public: static integer ControlArc;
member
public: list IsLeftPort(list elem);
body
{
	var integer t;
	t = elem.tail.head;
	if (t == ExtCtrlOut) {
		return 1;
	} else {
	}
	if (t == ExtDataOut) {
		return 1;
	} else {
	}
	if (t == CtrlIn) {
		return 1;
	} else {
	}
	if (t == DataIn) {
		return 1;
	} else {
	}
	return null;
}
end_body
member
public: list IsRightPort(list elem);
body
{
	var integer t;
	t = elem.tail.head;
	if (t == ExtCtrlIn) {
		return 1;
	} else {
	}
	if (t == ExtDataIn) {
		return 1;
	} else {
	}
	if (t == CtrlOut) {
		return 1;
	} else {
	}
	if (t == DataOut) {
		return 1;
	} else {
	}
	return null;
}
end_body
member
public: list IsArcSrc(list src);
body
{
	var integer s;
	s = src.tail.head;
	if (s == ExtCtrlIn) {
		return 1;
	} else {
	}
	if (s == ExtDataIn) {
		return 1;
	} else {
	}
	if (s == CtrlOut) {
		return 1;
	} else {
	}
	if (s == DataOut) {
		return 1;
	} else {
	}
	if (s == ObjectNode) {
		return 1;
	} else {
	}
	if (s == ClassNode) {
		return 1;
	} else {
	}
	if (s == VFuncNode) {
		return 1;
	} else {
	}
	return null;
}
end_body
member
public: list IsConnectableCtrl(list src, list dst);
body
{
	var integer s, d;
	s = src.tail.head;
	d = dst.tail.head;
	if (s == ExtCtrlIn && d == CtrlIn) {
		return 1;
	} else {
	}
	if (s == CtrlOut && d == ExtCtrlOut) {
		return 1;
	} else {
	}
	if (s == CtrlOut && d == CtrlIn) {
		return 1;
	} else {
	}
	return null;
}
end_body
member
public: list IsConnectableData(list src, list dst);
body
{
	var integer s, d;
	s = src.tail.head;
	d = dst.tail.head;
	if (s == ExtDataIn && d == DataIn) {
		return 1;
	} else {
	}
	if (s == DataOut && d == ExtDataOut) {
		return 1;
	} else {
	}
	if (s == DataOut && d == DataIn) {
		return 1;
	} else {
	}
	if (s == ClassNode && d == DataIn) {
		return 1;
	} else {
	}
	if (s == ObjectNode && d == DataIn) {
		return 1;
	} else {
	}
	if (s == DataOut && d == ObjectNode) {
		return 1;
	} else {
	}
	if (s == ObjectNode && d == ObjPort) {
		return 1;
	} else {
	}
	if (s == ClassNode && d == ObjPort) {
		return 1;
	} else {
	}
	if (s == ExtDataIn && d == ObjPort) {
		return 1;
	} else {
	}
	if (s == VFuncNode && d == DataIn) {
		return 1;
	} else {
	}
	return null;
}
end_body
member
public: list Execute(Hit h);
body
{
	var integer type;
	type = h.event.head;
	if (type == Event::LeftPress) {
		if (status == PutClass && _PutClass(h)) {
			status = Status::Edit;
			return 1;
		} else {
		}
		if (status == PutObject && _PutObject(h)) {
			status = Status::Edit;
			return 1;
		} else {
		}
		if (status == PutVFunc && _PutVFunc(h)) {
			status = Status::Edit;
			return 1;
		} else {
		}
		if (status == PutSFunc && _PutSFunc(h)) {
			status = Status::Edit;
			return 1;
		} else {
		}
		if (status == PutSysFunc && _PutSysFunc(h)) {
			status = Status::Edit;
			return 1;
		} else {
		}
		if (status == PutMacro && _PutMacro(h)) {
			status = Status::Edit;
			return 1;
		} else {
		}
		if (status == PutWizardNew && _PutWizardNew(h)) {
			status = Status::Edit;
			return 1;
		} else {
		}
		if (status == PutWizardWindow && _PutWizardWindow(h)) {
			status = Status::Edit;
			return 1;
		} else {
		}
	} else {
	}
	return GraphEditor::Execute(h);
}
end_body
member
public: static integer PutClass;
member
public: static integer PutObject;
member
public: static integer PutVFunc;
member
public: static integer PutSFunc;
member
public: static integer PutSysFunc;
member
public: static integer PutMacro;
member
public: static integer PutWizardNew;
member
public: static integer PutWizardWindow;
member
public: list _PutClass(Hit h);
body
{
	al_message_text(h.wnd, "");
	var string base_class, class_name;
	var list s_node, label;
	s_node = GetSelectedNode();
	if (s_node && s_node.tail.head == ClassNode) {
		base_class = LabelText(s_node, "$gp_class");
		if (base_class) {
			class_name = SelectSubClass(base_class);
		} else {
			class_name = SelectClass();
		}
	} else {
		class_name = SelectClass();
	}
	if (class_name) {
	} else {
		return 1;
	}
	var list xy;
	var integer x, y;
	xy = al_inverse_xy(cache_tm, h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	var list node, label;
	var Glyph g;
	g = new GpClass;
	g.Create();
	node = CreateNode(g, x, y);
	node.tail = al_cons(ClassNode, null);
	var TMGlyph info;
	info = al_dst_node(node, "$geom");
	label = CreateLabel(node, class_name, info.left, info.bottom);
	al_create_arc(label, node, "$gp_class");
	if (s_node) {
	} else {
		return 1;
	}
	var list arc;
	var PathGlyph path;
	arc = CreateArc(s_node, node);
	arc.tail = al_cons(SubClassArc, null);
	info = al_dst_node(arc, "$geom");
	path = info.child;
	path.line_style = "Dot";
	return 1;
}
end_body
member
public: list _PutObject(Hit h);
body
{
	al_message_text(h.wnd, "");
	var string class_name;
	if (class_name = SelectClass()) {
	} else {
		return 1;
	}
	var list xy;
	var integer x, y;
	xy = al_inverse_xy(cache_tm, h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	var list node, label;
	var Glyph g;
	g = new GpObject;
	g.Create();
	node = CreateNode(g, x, y);
	node.tail = al_cons(ObjectNode, null);
	var TMGlyph info;
	info = al_dst_node(node, "$geom");
	label = CreateLabel(node, class_name, info.left, info.bottom);
	al_create_arc(label, node, "$gp_class");
	return 1;
}
end_body
member
public: list _PutVFunc(Hit h);
body
{
	var list xy;
	var integer x, y;
	xy = al_inverse_xy(cache_tm, h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	var list node, label;
	var Glyph g;
	g = new GpFunc;
	g.Create();
	node = CreateNode(g, x, y);
	node.tail = al_cons(VFuncNode, null);
	var TMGlyph info;
	info = al_dst_node(node, "$geom");
	label = CreateLabel(node, "***", info.left, info.top - 12);
	al_create_arc(label, node, "$gp_func");
	var list ci_port, di_port, co_port, do_port, obj_port;
	ci_port = CreatePort(CtrlIn, 1, "c-in", info.left, info.top);
	di_port = CreatePort(DataIn, 1, "d-in", info.left, info.top);
	co_port = CreatePort(CtrlOut, 1, "c-out", info.left, info.top);
	do_port = CreatePort(DataOut, 1, "d-out", info.left, info.top);
	obj_port = CreatePort(ObjPort, 2, "obj", info.left, info.top);
	al_create_arc(node, ci_port, "$gp_port");
	al_create_arc(node, di_port, "$gp_port");
	al_create_arc(node, co_port, "$gp_port");
	al_create_arc(node, do_port, "$gp_port");
	al_create_arc(node, obj_port, "$gp_port");
	AdjustRootNode(node);
	return 1;
}
end_body
member
public: list _PutSFunc(Hit h);
body
{
	var list xy;
	var integer x, y;
	xy = al_inverse_xy(cache_tm, h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	var list node, label;
	var Glyph g;
	g = new GpFunc;
	g.Create();
	node = CreateNode(g, x, y);
	node.tail = al_cons(SFuncNode, null);
	var TMGlyph info;
	info = al_dst_node(node, "$geom");
	label = CreateLabel(node, "***", info.left, info.top - 12);
	al_create_arc(label, node, "$gp_func");
	var list ci_port, di_port, co_port, do_port, obj_port;
	ci_port = CreatePort(CtrlIn, 1, "c-in", info.left, info.top);
	di_port = CreatePort(DataIn, 1, "d-in", info.left, info.top);
	co_port = CreatePort(CtrlOut, 1, "c-out", info.left, info.top);
	do_port = CreatePort(DataOut, 1, "d-out", info.left, info.top);
	obj_port = CreatePort(ObjPort, 2, "class", info.left, info.top);
	al_create_arc(node, ci_port, "$gp_port");
	al_create_arc(node, di_port, "$gp_port");
	al_create_arc(node, co_port, "$gp_port");
	al_create_arc(node, do_port, "$gp_port");
	al_create_arc(node, obj_port, "$gp_port");
	AdjustRootNode(node);
	return 1;
}
end_body
member
public: list _PutSysFunc(Hit h);
body
{
	var AlDialog dialog;
	dialog = new AlDialog;
	var list ls;
	var string sysfunc;
	ls = al_cons(null, null);
	al_create_arc(ls, "new", null);
	al_create_arc(ls, "branch", null);
	al_create_arc(ls, "parallel", null);
	if (dialog.ShowSelect("Select Method", ls)) {
		sysfunc = dialog.text;
	} else {
		return 1;
	}
	var list xy;
	var integer x, y;
	xy = al_inverse_xy(cache_tm, h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	var Glyph g;
	g = new GpFunc;
	g.Create();
	var list node, label;
	var TMGlyph info;
	if (sysfunc == "new") {
		node = CreateNode(g, x, y);
		node.tail = al_cons(SysFuncNode, null);
		info = al_dst_node(node, "$geom");
		label = CreateLabel(node, "new", info.left, info.top - 12);
		al_create_arc(label, node, "$gp_func");
		var list ci_port, co_port, do_port, obj_port;
		ci_port = CreatePort(CtrlIn, 1, "c-in", info.left, info.top);
		co_port = CreatePort(CtrlOut, 1, "c-out", info.left, info.top);
		do_port = CreatePort(DataOut, 1, "d-out", info.left, info.top);
		obj_port = CreatePort(ObjPort, 2, "class", info.left, info.top);
		al_create_arc(node, ci_port, "$gp_port");
		al_create_arc(node, co_port, "$gp_port");
		al_create_arc(node, do_port, "$gp_port");
		al_create_arc(node, obj_port, "$gp_port");
		AdjustRootNode(node);
		return 1;
	} else {
	}
	if (sysfunc == "branch") {
		node = CreateNode(g, x, y);
		node.tail = al_cons(SysFuncNode, null);
		info = al_dst_node(node, "$geom");
		label = CreateLabel(node, "branch", info.left, info.top - 12);
		al_create_arc(label, node, "$gp_func");
		var list ci_port, di_port, di_port2, co_port, t_port, f_port;
		ci_port = CreatePort(CtrlIn, 1, "c-in", info.left, info.top);
		di_port = CreatePort(DataIn, 1, "d-in", info.left, info.top);
		di_port2 = CreatePort(DataIn, 1, "cond", info.left, info.top);
		co_port = CreatePort(CtrlOut, 1, "c-out", info.left, info.top);
		t_port = CreatePort(CtrlOut, 1, "ifTrue", info.left, info.top);
		f_port = CreatePort(CtrlOut, 1, "ifFalse", info.left, info.top);
		al_create_arc(node, ci_port, "$gp_port");
		al_create_arc(node, di_port, "$gp_port");
		al_create_arc(di_port, di_port2, "$gp_port");
		al_create_arc(node, co_port, "$gp_port");
		al_create_arc(co_port, t_port, "$gp_port");
		al_create_arc(co_port, f_port, "$gp_port");
		AdjustRootNode(node);
		return 1;
	} else {
	}
	if (sysfunc == "parallel") {
		node = CreateNode(g, x, y);
		node.tail = al_cons(SysFuncNode, null);
		info = al_dst_node(node, "$geom");
		label = CreateLabel(node, "parallel", info.left, info.top - 12);
		al_create_arc(label, node, "$gp_func");
		var list ci_port, co_port, seq_port, para_port;
		ci_port = CreatePort(CtrlIn, 1, "c-in", info.left, info.top);
		co_port = CreatePort(CtrlOut, 1, "c-out", info.left, info.top);
		seq_port = CreatePort(CtrlOut, 1, "seq", info.left, info.top);
		para_port = CreatePort(CtrlOut, 1, "para", info.left, info.top);
		al_create_arc(node, ci_port, "$gp_port");
		al_create_arc(node, co_port, "$gp_port");
		al_create_arc(co_port, seq_port, "$gp_port");
		al_create_arc(co_port, para_port, "$gp_port");
		AdjustRootNode(node);
		return 1;
	} else {
	}
	return 1;
}
end_body
member
public: list _PutMacro(Hit h);
body
{
	var list xy;
	var integer x, y;
	xy = al_inverse_xy(cache_tm, h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	var list node, label;
	var Glyph g;
	g = new GpFunc;
	g.Create();
	node = CreateNode(g, x, y);
	node.tail = al_cons(MacroNode, null);
	var TMGlyph info;
	info = al_dst_node(node, "$geom");
	CreateLabel(node, "***", info.left, info.top - 18);
	var list ci_port, di_port, co_port, do_port;
	ci_port = CreatePort(CtrlIn, 1, "c-in", info.left, info.top);
	di_port = CreatePort(DataIn, 1, "d-in", info.left, info.top);
	co_port = CreatePort(CtrlOut, 1, "c-out", info.left, info.top);
	do_port = CreatePort(DataOut, 1, "d-out", info.left, info.top);
	al_create_arc(node, ci_port, "$gp_port");
	al_create_arc(node, di_port, "$gp_port");
	al_create_arc(node, co_port, "$gp_port");
	al_create_arc(node, do_port, "$gp_port");
	AdjustRootNode(node);
	return 1;
}
end_body
member
public: list _PutWizardNew(Hit h);
body
{
	al_message_text(h.wnd, "");
	var string class_name;
	if (class_name = SelectClass()) {
	} else {
		return 1;
	}
	var list xy;
	var integer x, y;
	xy = al_inverse_xy(cache_tm, h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	var integer class_x, class_y, func_x, func_y, obj_x, obj_y;
	class_x = x;
	class_y = y + 90;
	func_x = x;
	func_y = y;
	obj_x = x + 80;
	obj_y = y + 90;
	var list class_node, func_node, obj_node, label, arc;
	var Glyph g;
	var TMGlyph info;
	// Create Class Node
	g = new GpClass;
	g.Create();
	class_node = CreateNode(g, class_x, class_y);
	class_node.tail = al_cons(ClassNode, null);
	info = al_dst_node(class_node, "$geom");
	label = CreateLabel(class_node, class_name, info.left, info.bottom);
	al_create_arc(label, class_node, "$gp_class");
	// Create Function Node
	g = new GpFunc;
	g.Create();
	func_node = CreateNode(g, func_x, func_y);
	func_node.tail = al_cons(SysFuncNode, null);
	info = al_dst_node(func_node, "$geom");
	label = CreateLabel(func_node, "new", info.left, info.top - 12);
	al_create_arc(label, func_node, "$gp_func");
	var list ci_port, co_port, do_port, obj_port;
	ci_port = CreatePort(CtrlIn, 1, "c-in", info.left, info.top);
	co_port = CreatePort(CtrlOut, 1, "c-out", info.left, info.top);
	do_port = CreatePort(DataOut, 1, "d-out", info.left, info.top);
	obj_port = CreatePort(ObjPort, 2, "class", info.left, info.top);
	al_create_arc(func_node, ci_port, "$gp_port");
	al_create_arc(func_node, co_port, "$gp_port");
	al_create_arc(func_node, do_port, "$gp_port");
	al_create_arc(func_node, obj_port, "$gp_port");
	AdjustRootNode(func_node);
	// Create Object Node
	g = new GpObject;
	g.Create();
	obj_node = CreateNode(g, obj_x, obj_y);
	obj_node.tail = al_cons(ObjectNode, null);
	info = al_dst_node(obj_node, "$geom");
	label = CreateLabel(obj_node, class_name, info.left, info.bottom);
	al_create_arc(label, obj_node, "$gp_class");
	// Create Arc
	arc = CreateArc(class_node, obj_port);
	arc.tail = al_cons(MemberFuncArc, null);
	arc = CreateArc(do_port, obj_node);
	arc.tail = al_cons(DataArc, null);
}
end_body
member
public: list _PutWizardWindow(Hit h);
body
{
	al_message_text(h.wnd, "");
	var string class_name;
	if (class_name = SelectClass()) {
	} else {
		return 1;
	}
	var list xy;
	var integer x, y;
	xy = al_inverse_xy(cache_tm, h.event.tail.head, h.event.tail.tail.head);
	x = xy.head;
	y = xy.tail.head;
	var integer const_x, const_y, class_x, class_y, func_x, func_y, obj_x, obj_y;
	const_x = x - 40;
	const_y = y + 130;
	class_x = x;
	class_y = y + 110;
	func_x = x;
	func_y = y;
	obj_x = x + 80;
	obj_y = y + 110;
	var list const_node, class_node, func_node, obj_node, label, arc;
	var Glyph g;
	var TMGlyph info;
	// Create Constant Node
	g = new GpObject;
	g.Create();
	const_node = CreateNode(g, const_x, const_y);
	const_node.tail = al_cons(ObjectNode, null);
	info = al_dst_node(const_node, "$geom");
	label = CreateLabel(const_node, "string", info.left, info.bottom);
	al_create_arc(label, const_node, "$gp_class");
	label = CreateLabel(const_node, "\"" + class_name + "\"", info.left, info.bottom + 12);
	al_set_dst_node(label, "$const", const_node);
	// Create Class Node
	g = new GpClass;
	g.Create();
	class_node = CreateNode(g, class_x, class_y);
	class_node.tail = al_cons(ClassNode, null);
	info = al_dst_node(class_node, "$geom");
	label = CreateLabel(class_node, "GUIbuilder", info.left, info.bottom);
	al_create_arc(label, class_node, "$gp_class");
	// Create Function Node
	g = new GpFunc;
	g.Create();
	func_node = CreateNode(g, func_x, func_y);
	func_node.tail = al_cons(SFuncNode, null);
	info = al_dst_node(func_node, "$geom");
	label = CreateLabel(func_node, "CreateWindow", info.left, info.top - 12);
	al_create_arc(label, func_node, "$gp_func");
	var list ci_port, co_port, di_port, do_port, obj_port;
	var list name_port, port;
	ci_port = CreatePort(CtrlIn, 1, "c-in", info.left, info.top);
	co_port = CreatePort(CtrlOut, 1, "c-out", info.left, info.top);
	di_port = CreatePort(DataIn, 1, "d-in", info.left, info.top);
	do_port = CreatePort(DataOut, 1, "d-out", info.left, info.top);
	obj_port = CreatePort(ObjPort, 2, "class", info.left, info.top);
	al_create_arc(func_node, ci_port, "$gp_port");
	al_create_arc(func_node, co_port, "$gp_port");
	al_create_arc(func_node, di_port, "$gp_port");
	al_create_arc(func_node, do_port, "$gp_port");
	al_create_arc(func_node, obj_port, "$gp_port");
	name_port = CreatePort(DataIn, 1, "name", info.left, info.top);
	al_create_arc(di_port, name_port, "$gp_port");
	port = CreatePort(DataIn, 1, "style", info.left, info.top);
	al_create_arc(di_port, port, "$gp_port");
	port = CreatePort(DataIn, 1, "parent", info.left, info.top);
	al_create_arc(di_port, port, "$gp_port");
	port = CreatePort(DataIn, 1, "geom", info.left, info.top);
	al_create_arc(di_port, port, "$gp_port");
	AdjustRootNode(func_node);
	// Create Object Node
	g = new GpObject;
	g.Create();
	obj_node = CreateNode(g, obj_x, obj_y);
	obj_node.tail = al_cons(ObjectNode, null);
	info = al_dst_node(obj_node, "$geom");
	label = CreateLabel(obj_node, class_name, info.left, info.bottom);
	al_create_arc(label, obj_node, "$gp_class");
	// Create Arc
	arc = CreateArc(const_node, name_port);
	arc.tail = al_cons(DataArc, null);
	arc = CreateArc(class_node, obj_port);
	arc.tail = al_cons(MemberFuncArc, null);
	arc = CreateArc(do_port, obj_node);
	arc.tail = al_cons(DataArc, null);
}
end_body
member
public: list _BeginArc(Hit h, TMGlyph info);
body
{
	if (src_node = al_src_node(info, "$geom")) {
	} else {
		return null;
	}
	if (src_node.head == 1) {
	} else {
		return null;
	}
	if (IsArcSrc(src_node)) {
	} else {
		return null;
	}
	_x0 = h.event.tail.head;
	_y0 = h.event.tail.tail.head;
	_x1 = _x0;
	_y1 = _y0;
	// al_repair(h.wnd);
	DrawRBand(h.wnd, _x0, _y0, _x1, _y1);
	return 1;
}
end_body
member
public: list _EndArc(Hit h, TMGlyph info);
body
{
	if (dst_node = al_src_node(info, "$geom")) {
	} else {
		return null;
	}
	if (dst_node.head == 1) {
	} else {
		return null;
	}
	if (al_addr_eq(src_node, dst_node)) {
		return null;
	} else {
	}
	if (IsConnectableCtrl(src_node, dst_node) || IsConnectableData(src_node, dst_node)) {
	} else {
		return null;
	}
	DrawRBand(h.wnd, _x0, _y0, _x1, _y1);
	var list arc;
	arc = CreateArc(src_node, dst_node);
	if (IsConnectableCtrl(src_node, dst_node)) {
		var TMGlyph info;
		info = al_dst_node(arc, "$geom");
		var PathGlyph path;
		path = info.child;
		path.line_style = "Dot";
		arc.tail = al_cons(ControlArc, null);
	} else {
		arc.tail = al_cons(DataArc, null);
	}
	src_node = dst_node = null;
	_x0 = _y0 = _x1 = _y1 = null;
	al_message_text(h.wnd, "Arc Input");
	return 1;
}
end_body
member
public: list CreateLabel(list elem, string s, integer x, integer y);
body
{
	var list label;
	var TMGlyph info;
	var LabelGlyph lab;
	var list wh;
	var integer w, h;
	label = GraphEditor::CreateLabel(elem, s, x, y);
	info = al_dst_node(label, "$geom");
	lab = info.child;
	al_start_quick_draw(wnd);
	wh = al_text_width(wnd, s);
	al_end_quick_draw(wnd);
	w = wh.head + lab.left_margin * 2;
	h = wh.tail.head + lab.top_margin * 2;
	info.Resize(x, y, x + w, y + h);
	child.MakeSpaceIndex(info);
	info.child.Damage();
	info.child.KnobDamage();
	return label;
}
end_body
member
public: void DoMove(integer dx, integer dy);
body
{
	var list itr;
	itr = al_dst_itr(selection);
	var TMGlyph info;
	var list elem, elem2;
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		elem = al_src_node(info, "$geom");
		if (elem.head == 1 && al_addr_eq(elem, Root(elem))) {
			MovePort(elem, dx, dy);
		} else {
		}
		if (elem.head == 2) {
		} else {
		}
		if (elem.head == 3) {
			elem2 = al_dst_node(elem, "$refer");
			if (elem2.head == 1 && IsSelected(Root(elem2))) {
			} else {
				MoveLabel(elem, dx, dy);
			}
		} else {
		}
	}
}
end_body
member
public: void MovePort(list port, integer dx, integer dy);
body
{
	MoveNode(port, dx, dy);
	var list itr, port1;
	itr = al_dst_itr(port);
	loop {
		if (port1 = al_next_a(itr, "$gp_port")) {
		} else {
			break;
		}
		MovePort(port1, dx, dy);
	}
}
end_body
member
public: list IsSelected(list elem);
body
{
	var TMGlyph info;
	if (info = al_dst_node(elem, "$geom")) {
	} else {
		return null;
	}
	if (al_src_node(info, "$select")) {
		return 1;
	} else {
		return null;
	}
}
end_body
member
public: void AllocationChanged(Glyph g);
body
{
	var TMGlyph info;
	if (info = child.allo_chg_glyph) {
	} else {
		return;
	}
	var list elem;
	elem = al_src_node(info, "$geom");
	if (elem && elem.head == 1) {
	} else {
		return;
	}
	var list t;
	t = elem.tail.head;
	if (t == VFuncNode || t == SFuncNode || t == SysFuncNode || t == MacroNode) {
		AdjustRootNode(elem);
	} else {
	}
}
end_body
member
public: void AdjustRootNode(list node);
body
{
	var TMGlyph info;
	info = al_dst_node(node, "$geom");
	var integer b, b1;
	b = info.top + PortPitch;
	var list itr, port;
	itr = al_dst_itr(node);
	loop {
		if (port = al_next_a(itr, "$gp_port")) {
		} else {
			break;
		}
		if (port.tail.head != CtrlIn) {
			continue;
		} else {
		}
		b = AdjustLeftPort(port, b, info.left + 2) + PortPitch;
		break;
	}
	itr = al_dst_itr(node);
	loop {
		if (port = al_next_a(itr, "$gp_port")) {
		} else {
			break;
		}
		if (port.tail.head != DataIn) {
			continue;
		} else {
		}
		b = AdjustLeftPort(port, b, info.left + 2);
		break;
	}
	b1 = b;
	b = info.top + PortPitch;
	itr = al_dst_itr(node);
	loop {
		if (port = al_next_a(itr, "$gp_port")) {
		} else {
			break;
		}
		if (port.tail.head != CtrlOut) {
			continue;
		} else {
		}
		b = AdjustRightPort(port, b, info.right - 2) + PortPitch;
		break;
	}
	itr = al_dst_itr(node);
	loop {
		if (port = al_next_a(itr, "$gp_port")) {
		} else {
			break;
		}
		if (port.tail.head != DataOut) {
			continue;
		} else {
		}
		b = AdjustRightPort(port, b, info.right - 2);
		break;
	}
	b1 = al_max(b, b1);
	if (b1 > info.bottom) {
		info.Damage();
		info.Resize(info.left, info.top, info.right, b1);
		info.Damage();
	} else {
	}
	itr = al_dst_itr(node);
	loop {
		if (port = al_next_a(itr, "$gp_port")) {
		} else {
			break;
		}
		if (port.tail.head != ObjPort) {
			continue;
		} else {
		}
		var TMGlyph info2;
		info2 = al_dst_node(port, "$geom");
		info2.Damage();
		info2.Resize(info2.left, info2.top, info2.left + PortWidth, info2.top + PortHeight);
		var integer dx, dy;
		dx = (info.left + info.right) / 2 - PortWidth / 2 - info2.left;
		dy = info.bottom - info2.top - 2;
		MovePort(port, dx, dy);
	}
}
end_body
member
public: integer AdjustLeftPort(list port, integer t, integer r);
body
{
	var integer l, b;
	l = r - PortWidth;
	b = t + PortHeight;
	var list itr, port2;
	itr = al_dst_itr(port);
	loop {
		if (port2 = al_next_a(itr, "$gp_port")) {
		} else {
			break;
		}
		b = AdjustLeftPort(port2, b, l + 2) + PortPitch;
	}
	var list label;
	var TMGlyph info;
	if (label = al_src_node(port, "$refer")) {
		info = al_dst_node(label, "$geom");
		info.Damage();
		info.Move(r - info.left, t - info.top);
		child.MakeSpaceIndex(info);
		info.Damage();
	} else {
	}
	info = al_dst_node(port, "$geom");
	info.child.Damage();
	info.child.KnobDamage();
	info.Resize(l, t, r, b);
	child.MakeSpaceIndex(info);
	info.child.Damage();
	info.child.KnobDamage();
	AdjustNode(port);
	return b;
}
end_body
member
public: integer AdjustRightPort(list port, integer t, integer l);
body
{
	var integer r, b;
	r = l + PortWidth;
	b = t + PortHeight;
	var list itr, port2;
	itr = al_dst_itr(port);
	loop {
		if (port2 = al_next_a(itr, "$gp_port")) {
		} else {
			break;
		}
		b = AdjustRightPort(port2, b, r - 2) + PortPitch;
	}
	var list label;
	var TMGlyph info;
	if (label = al_src_node(port, "$refer")) {
		info = al_dst_node(label, "$geom");
		info.Damage();
		info.Move(r - info.left, t - info.top);
		child.MakeSpaceIndex(info);
		info.Damage();
	} else {
	}
	info = al_dst_node(port, "$geom");
	info.child.Damage();
	info.child.KnobDamage();
	info.Resize(l, t, r, b);
	child.MakeSpaceIndex(info);
	info.child.Damage();
	info.child.KnobDamage();
	AdjustNode(port);
	return b;
}
end_body
member
public: static integer PortWidth;
member
public: static integer PortHeight;
member
public: static integer PortPitch;
member
public: list CreatePort(integer kind, integer lab, string text, integer x, integer y);
body
{
	var GpPort g;
	g = new GpPort;
	g.Create();
	var TMGlyph info;
	info = child.Append(g, x, y);
	var list port, label;
	port = al_list2(1, kind);
	al_create_arc(nodes, port, null);
	al_create_arc(port, info, "$geom");
	if (lab == 1) {
		label = CreateLabel(port, text, info.right, info.top);
		al_create_arc(label, port, "$port_id");
	} else {
	}
	if (lab == 2) {
		label = CreateLabel(port, text, info.left, info.top - 12);
		al_create_arc(label, port, "$port_id");
	} else {
	}
	return port;
}
end_body
member
public: void CreateExtPort(list node);
body
{
	var list parent;
	parent = al_src_node(this, "$gp_macro");
	var list itr, port, port2;
	var integer t;
	itr = al_dst_itr(node);
	loop {
		if (port = al_next_a(itr, "$gp_port")) {
		} else {
			break;
		}
		t = port.tail.head;
		if (t == CtrlIn) {
			port2 = _CreateExtPort(ExtCtrlIn, port);
			al_create_arc(parent, port2, "$gp_ext_port");
			AdjustRightPort(port2, 20, 20);
		} else {
		}
		if (t == DataIn) {
			port2 = _CreateExtPort(ExtDataIn, port);
			al_create_arc(parent, port2, "$gp_ext_port");
			AdjustRightPort(port2, 250, 20);
		} else {
		}
		if (t == CtrlOut) {
			port2 = _CreateExtPort(ExtCtrlOut, port);
			al_create_arc(parent, port2, "$gp_ext_port");
			AdjustLeftPort(port2, 20, 350);
		} else {
		}
		if (t == DataOut) {
			port2 = _CreateExtPort(ExtDataOut, port);
			al_create_arc(parent, port2, "$gp_ext_port");
			AdjustLeftPort(port2, 250, 350);
		} else {
		}
	}
	Damage();
}
end_body
member
public: list _CreateExtPort(integer type, list port);
body
{
	var list port2, label;
	var TMGlyph label_info;
	var LabelGlyph lab;
	label = al_src_node(port, "$refer");
	if (label_info = al_dst_node(label, "$geom")) {
		lab = label_info.child;
		port2 = CreatePort(type, 1, lab.text, 0, 0);
	} else {
		port2 = CreatePort(type, 0, "", 0, 0);
	}
	var list itr, port3, port4;
	itr = al_dst_itr(port);
	loop {
		if (port3 = al_next_a(itr, "$gp_port")) {
		} else {
			break;
		}
		port4 = _CreateExtPort(type, port3);
		al_create_arc(port2, port4, "$gp_port");
	}
	return port2;
}
end_body
member
public: string SelectClass();
body
{
	var GbGpPanel panel;
	var LabelGlyph label;
	var string proj_name;
	var list itr, proj_info;
	if (panel = GbGpPanel::inst) {
	} else {
		return null;
	}
	label = panel.proj.label;
	proj_name = label.text;
	itr = al_dst_itr(panel.projects);
	loop {
		if (proj_info = al_next(itr)) {
		} else {
			return null;
		}
		if (proj_info.head == proj_name) {
			break;
		} else {
		}
	}
	var AlDialog dialog;
	dialog = new AlDialog;
	if (dialog.ShowSelect("Select ClassName(1)", (list)al_dst_node(panel, "public_class"))) {
		var string text;
		text = dialog.text;
		if (text == "") {
			text = null;
		} else {
		}
		return text;
	} else {
	}
	dialog = new AlDialog;
	if (dialog.ShowSelect("Select ClassName(2)", proj_info.tail.tail.tail.tail.head)) {
		var string text;
		text = dialog.text;
		if (text == "") {
			text = null;
		} else {
		}
		return text;
	} else {
	}
	return null;
}
end_body
member
public: string SelectSubClass(string class_name);
body
{
	var list base_class, sub_class, class_list, itr;
	base_class = al_gp("runtime_class", class_name, null, null, null);
	class_list = al_cons(null, null);
	itr = al_dst_itr(base_class);
	loop {
		if (sub_class = al_next_a(itr, "$subclass")) {
		} else {
			break;
		}
		al_create_arc(class_list, sub_class.head, null);
	}
	var AlDialog dialog;
	dialog = new AlDialog;
	if (dialog.ShowSelect("Select Derived Class", class_list)) {
		return dialog.text;
	} else {
		return null;
	}
}
end_body
member
public: integer SelectSysFunc();
member
public: static list Dst(list src_p);
body
{
	var list arc, dst_p, node;
	if (arc = al_src_node(src_p, "$src")) {
	} else {
		return null;
	}
	if (dst_p = al_dst_node(arc, "$dst")) {
	} else {
		return null;
	}
	if (IsCtrlIn(dst_p) || IsDataIn(dst_p)) {
		node = Root(dst_p);
		if (IsMacroNode(node)) {
		} else {
			return dst_p;
		}
		return Inside(dst_p, null, (list)1, null, null);
	} else {
	}
	if (IsExtCtrlOut(dst_p) || IsExtDataOut(dst_p)) {
		return Outside(dst_p, null, (list)1, null, null);
	} else {
	}
	if (IsObjectNode(dst_p)) {
		return dst_p;
	} else {
	}
	return null;
}
end_body
member
public: static list Src(list dst_p, list obj, list arg);
body
{
	var list itr, arc, src_p, node;
	itr = al_src_itr(dst_p);
	loop {
		if (arc = al_next_a(itr, "$dst")) {
		} else {
			return null;
		}
		if (obj) {
			if (arc.tail.head != MemberVarArc) {
				arc = null;
			} else {
			}
		} else {
			if (arc.tail.head == MemberVarArc) {
				arc = null;
			} else {
			}
		}
		if (arc) {
			break;
		} else {
		}
	}
	if (src_p = al_dst_node(arc, "$src")) {
	} else {
		return null;
	}
	if (IsCtrlOut(src_p) || IsDataOut(src_p)) {
		node = Root(src_p);
		if (IsMacroNode(node)) {
		} else {
			return src_p;
		}
		return Inside(src_p, null, null, obj, arg);
	} else {
	}
	if (IsExtCtrlIn(src_p) || IsExtDataIn(src_p)) {
		return Outside(src_p, null, null, obj, arg);
	} else {
	}
	if (arg == null) {
		if (IsObjectNode(src_p) || IsClassNode(src_p) || IsFuncNode(src_p)) {
			return src_p;
		} else {
		}
	} else {
	}
	return null;
}
end_body
member
public: static list Inside(list prt, list id_ls, list dst, list obj, list arg);
body
{
	var list prt2, node, in_prt, prt_id, itr;
	loop {
		if (prt_id = LabelText(prt, "$port_id")) {
		} else {
			al_print("Inside: No port number.\n");
			return null;
		}
		id_ls = al_cons(prt_id, id_ls);
		prt2 = al_src_node(prt, "$gp_port");
		if (prt2) {
			if (IsNodePort(prt2) || IsExtPort(prt2)) {
			} else {
				break;
			}
		} else {
			break;
		}
		prt = prt2;
	}
	node = Root(prt);
	itr = al_dst_itr(node);
	loop {
		if (in_prt = al_next_a(itr, "$gp_ext_port")) {
		} else {
			al_print("\n");
			return null;
		}
		if (dst) {
			if (IsCtrlIn(prt) && IsExtCtrlIn(in_prt)) {
				break;
			} else {
			}
			if (IsDataIn(prt) && IsExtDataIn(in_prt)) {
				break;
			} else {
			}
		} else {
			if (IsCtrlOut(prt) && IsExtCtrlIn(in_prt)) {
				break;
			} else {
			}
			if (IsDataOut(prt) && IsExtDataOut(in_prt)) {
				break;
			} else {
			}
		}
	}
	prt_id = LabelText(in_prt, "$port_id");
	if (prt_id == id_ls.head) {
		id_ls = id_ls.tail;
	} else {
		al_print("Inside: No consistency between ports.\n");
		return null;
	}
	loop {
		if (id_ls) {
		} else {
			if (dst) {
				return Dst(in_prt);
			} else {
				return Src(in_prt, obj, arg);
			}
		}
		itr = al_dst_itr(in_prt);
		loop {
			if (prt2 = al_next_a(itr, "$gp_port")) {
			} else {
				break;
			}
			prt_id = LabelText(prt2, "$port_id");
			if (prt_id == id_ls.head) {
				id_ls = id_ls.tail;
				break;
			} else {
			}
		}
		if (prt2) {
			in_prt = prt2;
			continue;
		} else {
		}
		if (dst) {
			prt2 = Dst(in_prt);
		} else {
			prt2 = Src(in_prt, obj, arg);
		}
		if (prt2) {
			node = Root(prt2);
			if (IsMacroNode(node)) {
				if (IsNodePort(prt2)) {
					return Inside(prt2, id_ls, dst, obj, arg);
				} else {
					al_print("Inside: Connection of macro arc is illegal.\n");
					return null;
				}
			} else {
				if (IsExtPort(prt2)) {
					var list n;
					n = al_src_node(prt2, "$gp_ext_port");
					if (n && IsMacroNode(n)) {
						return Outside(prt2, id_ls, dst, obj, arg);
					} else {
						return prt2;
					}
				} else {
					return null;
					al_print("Inside: Connection of macro arc is illegal.\n");
				}
			}
		} else {
			al_print("Inside: not found the corresponding port.\n");
			return null;
		}
	}
}
end_body
member
public: static list Outside(list prt, list id_ls, list dst, list obj, list arg);
body
{
	var list arg_prt, prt1, prt2, node, out_prt, prt_id, itr;
	arg_prt = prt1 = prt;
	loop {
		if (prt_id = LabelText(prt, "$port_id")) {
		} else {
			al_print("Outside: No port id.\n");
			return null;
		}
		id_ls = al_cons(prt_id, id_ls);
		prt2 = al_src_node(prt, "$gp_port");
		if (prt2) {
			if (IsNodePort(prt2) || IsExtPort(prt2)) {
			} else {
				break;
			}
		} else {
			break;
		}
		prt = prt2;
	}
	if (node = al_src_node(prt, "$gp_ext_port")) {
	} else {
		al_print("Outside: Not found the parent of macro.\n");
		return null;
	}
	if (arg) {
		if (IsMacroNode(node)) {
		} else {
			return arg_prt;
		}
	} else {
	}
	itr = al_dst_itr(node);
	loop {
		if (out_prt = al_next_a(itr, "$gp_port")) {
		} else {
			al_print("Outside: No definition of macro.\n");
			return null;
		}
		if (dst) {
			if (IsExtCtrlOut(prt) && IsCtrlOut(out_prt)) {
				break;
			} else {
			}
			if (IsExtDataOut(prt) && IsDataOut(out_prt)) {
				break;
			} else {
			}
		} else {
			if (IsExtCtrlIn(prt) && IsCtrlIn(out_prt)) {
				break;
			} else {
			}
			if (IsExtDataIn(prt) && IsDataIn(out_prt)) {
				break;
			} else {
			}
		}
	}
	prt_id = LabelText(out_prt, "$port_id");
	if (prt_id == id_ls.head) {
		id_ls = id_ls.tail;
	} else {
		al_print("Outside: No consistency between ports.\n");
		return null;
	}
	loop {
		if (id_ls) {
		} else {
			if (dst) {
				return Dst(out_prt);
			} else {
				return Src(out_prt, obj, arg);
			}
		}
		itr = al_dst_itr(out_prt);
		loop {
			if (prt2 = al_next_a(itr, "$gp_port")) {
			} else {
				break;
			}
			prt_id = LabelText(prt2, "$port_id");
			if (prt_id == id_ls.head) {
				id_ls = id_ls.tail;
				break;
			} else {
			}
		}
		if (prt2) {
			out_prt = prt2;
			continue;
		} else {
		}
		if (dst) {
			prt2 = Dst(out_prt);
		} else {
			prt2 = Src(out_prt, obj, arg);
		}
		if (prt2) {
			node = Root(prt2);
			if (IsMacroNode(node)) {
				if (IsNodePort(prt2)) {
					return Inside(prt2, id_ls, dst, obj, arg);
				} else {
					al_print("Outside: Connection of arc is illegal.\n");
					return null;
				}
			} else {
				if (IsExtPort(prt2)) {
					var list n;
					n = al_src_node(prt2, "$gp_ext_port");
					if (n && IsMacroNode(n)) {
						return Outside(prt2, id_ls, dst, obj, arg);
					} else {
						return prt2;
					}
				} else {
					al_print("Outside: Connection of macro arc is illegal.\n");
					return null;
				}
			}
		} else {
			al_print("Outside: Not found the corresponding port.\n");
			return null;
		}
	}
}
end_body
member
public: static list Mark(list node);
body
{
	return al_dst_node(node, "$gp_mark");
}
end_body
member
public: static void Mark(list node, list info);
body
{
	al_set_dst_node(node, "$gp_mark", info);
}
end_body
member
public: static list StartPort(list _fn);
body
{
	var list itr, p;
	itr = al_dst_itr(_fn);
	loop {
		if (p = al_next_a(itr, "$gp_ext_port")) {
		} else {
			return null;
		}
		if (IsExtCtrlIn(p)) {
			return p;
		} else {
		}
	}
}
end_body
member
public: static list Root(list prt);
body
{
	var list prt2;
	loop {
		if (prt2 = al_src_node(prt, "$gp_port")) {
		} else {
			return prt;
		}
		prt = prt2;
	}
}
end_body
member
public: static list IfTruePort(list node);
body
{
	var list itr, p, p2;
	var string text;
	p = CtrlOutPort(node);
	itr = al_dst_itr(p);
	loop {
		if (p2 = al_next_a(itr, "$gp_port")) {
		} else {
			return null;
		}
		text = LabelText(p2, "$port_id");
		if (text == "ifTrue") {
			return p2;
		} else {
		}
	}
}
end_body
member
public: static list IfFalsePort(list node);
body
{
	var list itr, p, p2;
	var string text;
	p = CtrlOutPort(node);
	itr = al_dst_itr(p);
	loop {
		if (p2 = al_next_a(itr, "$gp_port")) {
		} else {
			return null;
		}
		text = LabelText(p2, "$port_id");
		if (text == "ifFalse") {
			return p2;
		} else {
		}
	}
}
end_body
member
public: static list SeqPort(list node);
body
{
	var list itr, p, p2;
	var string text;
	p = CtrlOutPort(node);
	itr = al_dst_itr(p);
	loop {
		if (p2 = al_next_a(itr, "$gp_port")) {
		} else {
			return null;
		}
		text = LabelText(p2, "$port_id");
		if (text == "seq") {
			return p2;
		} else {
		}
	}
}
end_body
member
public: static list ParaPort(list node);
body
{
	var list itr, p, p2;
	var string text;
	p = CtrlOutPort(node);
	itr = al_dst_itr(p);
	loop {
		if (p2 = al_next_a(itr, "$gp_port")) {
		} else {
			return null;
		}
		text = LabelText(p2, "$port_id");
		if (text == "para") {
			return p2;
		} else {
		}
	}
}
end_body
member
public: static list CtrlInPort(list node);
body
{
	var list itr, p;
	itr = al_dst_itr(node);
	loop {
		if (p = al_next_a(itr, "$gp_port")) {
		} else {
			return null;
		}
		if (IsCtrlIn(p)) {
			return p;
		} else {
		}
	}
}
end_body
member
public: static list CtrlOutPort(list node);
body
{
	var list itr, p;
	itr = al_dst_itr(node);
	loop {
		if (p = al_next_a(itr, "$gp_port")) {
		} else {
			return null;
		}
		if (IsCtrlOut(p)) {
			return p;
		} else {
		}
	}
}
end_body
member
public: static list DataInPort(list node);
body
{
	var list itr, p;
	itr = al_dst_itr(node);
	loop {
		if (p = al_next_a(itr, "$gp_port")) {
		} else {
			return null;
		}
		if (IsDataIn(p)) {
			return p;
		} else {
		}
	}
}
end_body
member
public: static list DataOutPort(list node);
body
{
	var list itr, p;
	itr = al_dst_itr(node);
	loop {
		if (p = al_next_a(itr, "$gp_port")) {
		} else {
			return null;
		}
		if (IsDataOut(p)) {
			return p;
		} else {
		}
	}
}
end_body
member
public: static list GetObjPort(list node);
body
{
	var list itr, p;
	itr = al_dst_itr(node);
	loop {
		if (p = al_next_a(itr, "$gp_port")) {
		} else {
			return null;
		}
		if (IsObjPort(p)) {
			return p;
		} else {
		}
	}
}
end_body
member
public: static list IsExtCtrlIn(list prt);
body
{
	return prt.tail.head == ExtCtrlIn;
}
end_body
member
public: static list IsExtCtrlOut(list prt);
body
{
	return prt.tail.head == ExtCtrlOut;
}
end_body
member
public: static list IsExtDataIn(list prt);
body
{
	return prt.tail.head == ExtDataIn;
}
end_body
member
public: static list IsExtDataOut(list prt);
body
{
	return prt.tail.head == ExtDataOut;
}
end_body
member
public: static list IsCtrlIn(list prt);
body
{
	return prt.tail.head == CtrlIn;
}
end_body
member
public: static list IsCtrlOut(list prt);
body
{
	return prt.tail.head == CtrlOut;
}
end_body
member
public: static list IsDataIn(list prt);
body
{
	return prt.tail.head == DataIn;
}
end_body
member
public: static list IsDataOut(list prt);
body
{
	return prt.tail.head == DataOut;
}
end_body
member
public: static list IsObjPort(list prt);
body
{
	return prt.tail.head == ObjPort;
}
end_body
member
public: static list IsNodePort(list prt);
body
{
	return IsCtrlIn(prt) || IsDataIn(prt) || IsCtrlOut(prt) || IsDataOut(prt);
}
end_body
member
public: static list IsExtPort(list prt);
body
{
	return IsExtCtrlIn(prt) || IsExtDataIn(prt) || IsExtCtrlOut(prt) || IsExtDataOut(prt);
}
end_body
member
public: static list IsClassNode(list node);
body
{
	return node.tail.head == ClassNode;
}
end_body
member
public: static list IsObjectNode(list node);
body
{
	return node.tail.head == ObjectNode;
}
end_body
member
public: static list IsMacroNode(list node);
body
{
	return node.tail.head == MacroNode;
}
end_body
member
public: static list IsFuncNode(list node);
body
{
	var integer t;
	t = node.tail.head;
	return t == VFuncNode || t == SFuncNode || t == SysFuncNode;
}
end_body
member
public: static list IsBranchNode(list node);
body
{
	var string text;
	text = LabelText(node, "$gp_func");
	return text == "branch";
}
end_body
member
public: static list IsNewNode(list node);
body
{
	var string text;
	text = LabelText(node, "$gp_func");
	return text == "new";
}
end_body
member
public: static list IsParaNode(list node);
body
{
	var string text;
	text = LabelText(node, "$gp_func");
	return text == "parallel";
}
end_body
member
public: static list IsMultiCtrlIn(list node);
body
{
	var list port;
	if (port = CtrlInPort(node)) {
	} else {
		return null;
	}
	var integer count;
	count = 0;
	var list itr;
	itr = al_src_itr(port);
	loop {
		if (al_next_a(itr, "$dst")) {
			count = count + 1;
		} else {
			return count >= 2;
		}
	}
}
end_body
member
public: void ClearSpaceIndex();
body
{
	Editor::ClearSpaceIndex();
	var list itr, info, node, gamen_data_root;
	var Glyph g;
	itr = al_dst_itr(this);
	loop {
		if (info = al_next_a(itr, "child")) {
		} else {
			break;
		}
		node = al_src_node(info, "$geom");
		if (node && node.head == 1) {
		} else {
			continue;
		}
		if (gamen_data_root = al_dst_node(node, "$child_data")) {
		} else {
			continue;
		}
		g = gamen_data_root.tail.tail.tail.head;
		g.ClearSpaceIndex();
	}
}
end_body
member
public: void MakeSpaceIndex();
body
{
	Editor::MakeSpaceIndex();
	var list itr, info, node, gamen_data_root;
	var Glyph g;
	itr = al_dst_itr(this);
	loop {
		if (info = al_next_a(itr, "child")) {
		} else {
			break;
		}
		node = al_src_node(info, "$geom");
		if (node && node.head == 1) {
		} else {
			continue;
		}
		if (gamen_data_root = al_dst_node(node, "$child_data")) {
		} else {
			continue;
		}
		g = gamen_data_root.tail.tail.tail.head;
		g.MakeSpaceIndex();
	}
}
end_body
end_class
TEXT
GlyphEditor
class GUIbuilder
member
public: void Create(integer l, integer t, integer r, integer b);
body
{
	GlyphEditor::Create(l, t, r, b);
	parts = al_cons(null, null);
	back_color = 0xffffff;
	border_width = 1;
	light_color = 0x0;
	shadow_color = 0x0;
	attachment = al_cons(null, null);
	first_movectrl = 1;
}
end_body
member
public: void Resize(integer l, integer t, integer r, integer b);
body
{
	left = l;
	top = t;
	right = r;
	bottom = b;
	if (child) {
		child.left = l;
		child.top = t;
		child.right = r;
		child.bottom = b;
	} else {
	}
	var list itr, attach;
	var TMGlyph info;
	var integer what, opposite, offset, val;
	var matrix tm1;
	itr = al_dst_itr(attachment);
	loop {
		if (attach = al_next(itr)) {
		} else {
			break;
		}
		info = attach.head;
		what = attach.tail.head;
		opposite = attach.tail.tail.head;
		offset = attach.tail.tail.tail.head;
		if (what == FormGlyph::Left) {
			if (opposite == 0) {
				val = l + offset - info.left;
			} else {
				val = r - offset - info.left;
			}
			tm1 = al_translate_tm(val, 0);
			if (info.tm) {
				info.SetTM(tm1 * info.tm);
			} else {
				info.SetTM(tm1);
			}
			info.child.AllocationChanged(info.child);
		} else {
		}
		if (what == FormGlyph::Top) {
			if (opposite == 0) {
				val = t + offset - info.top;
			} else {
				val = b - offset - info.top;
			}
			tm1 = al_translate_tm(0, val);
			if (info.tm) {
				info.SetTM(tm1 * info.tm);
			} else {
				info.SetTM(tm1);
			}
			info.child.AllocationChanged(info.child);
		} else {
		}
	}
	itr = al_dst_itr(attachment);
	loop {
		if (attach = al_next(itr)) {
		} else {
			break;
		}
		info = attach.head;
		what = attach.tail.head;
		opposite = attach.tail.tail.head;
		offset = attach.tail.tail.tail.head;
		if (what == FormGlyph::Right) {
			if (opposite == 0) {
				val = r - offset - info.right;
			} else {
				val = l + offset - info.right;
			}
			info.child.right = info.child.right + val;
			info.child.AllocationChanged(info.child);
		} else {
		}
		if (what == FormGlyph::Bottom) {
			if (opposite == 0) {
				val = b - offset - info.bottom;
			} else {
				val = t + offset - info.bottom;
			}
			info.child.bottom = info.child.bottom + val;
			info.child.AllocationChanged(info.child);
		} else {
		}
	}
	itr = al_dst_itr(this.child);
	loop {
		if (info = al_next_a(itr, "child")) {
		} else {
			break;
		}
		info.Resize(info.left, info.top, info.right, info.bottom);
	}
}
end_body
member
public: void MoveControl(window w);
body
{
	Editor::MoveControl(w);
	if (first_movectrl) {
		first_movectrl = null;
		AfterFirstMoveControl();
	} else {
	}
}
end_body
member
public: void Draw(window w);
body
{
	al_push_pen(w, "Null", 0, 0);
	var integer color;
	if (al_get_sys_color(0) != 0) {
		color = back_color;
	} else {
		if (back_color != 0xffffff) {
			color = back_color;
		} else {
			color = 0x0;
		}
	}
	al_push_brush(w, "Solid", color, null);
	al_rectangle(w, left, top, right, bottom);
	al_pop_brush(w);
	al_pop_pen(w);
	GlyphEditor::Draw(w);
	if (border_width > 0) {
		var list poly;
		al_push_pen(w, "Solid", border_width, light_color);
		al_push_brush(w, "Solid", light_color, null);
		poly = al_create_poly_poly();
		al_pop_brush(w);
		al_add_point_to_poly(poly, left, top);
		al_add_point_to_poly(poly, right - 1, top);
		al_add_point_to_poly(poly, right - border_width, top + border_width - 1);
		al_add_point_to_poly(poly, left + border_width - 1, top + border_width - 1);
		al_polygon(w, poly);
		poly = al_create_poly_poly();
		al_add_point_to_poly(poly, left, top);
		al_add_point_to_poly(poly, left + border_width - 1, top + border_width - 1);
		al_add_point_to_poly(poly, left + border_width - 1, bottom - border_width);
		al_add_point_to_poly(poly, left, bottom - 1);
		al_polygon(w, poly);
		al_pop_pen(w);
		al_push_pen(w, "Solid", border_width, shadow_color);
		al_push_brush(w, "Solid", shadow_color, null);
		poly = al_create_poly_poly();
		al_add_point_to_poly(poly, right - 1, bottom - 1);
		al_add_point_to_poly(poly, left, bottom - 1);
		al_add_point_to_poly(poly, left + border_width - 1, bottom - border_width);
		al_add_point_to_poly(poly, right - border_width, bottom - border_width);
		al_polygon(w, poly);
		poly = al_create_poly_poly();
		al_add_point_to_poly(poly, right - 1, bottom - 1);
		al_add_point_to_poly(poly, right - border_width, bottom - border_width);
		al_add_point_to_poly(poly, right - border_width, top + border_width - 1);
		al_add_point_to_poly(poly, right - 1, top);
		al_polygon(w, poly);
		al_pop_brush(w);
		al_pop_pen(w);
	} else {
	}
}
end_body
member
public: void Pick(Hit h);
body
{
	if (Glyph::HitTest(h)) {
	} else {
		return;
	}
	if (status == Status::Layout) {
		Glyph::Pick(h);
		return;
	} else {
	}
	GlyphEditor::Pick(h);
}
end_body
member
public: void Destroy();
body
{
	BeforeDestroy();
	Editor::Destroy();
}
end_body
member
public: list first_movectrl;
member
public: void Attach(TMGlyph info, integer what, integer opposite, integer offset);
body
{
	var list itr, attach;
	itr = al_dst_itr(attachment);
	loop {
		if (attach = al_next_a(itr, null)) {
		} else {
			break;
		}
		if (al_addr_eq(attach.head, info) && attach.tail.head == what) {
			al_remove(itr);
			break;
		} else {
		}
	}
	if (opposite == -1) {
		return;
	} else {
	}
	attach = al_list4(info, what, opposite, offset);
	al_create_arc(attachment, attach, null);
}
end_body
member
public: list attachment;
member
public: void LayoutMode();
body
{
	var list itr;
	var TMGlyph info;
	var Glyph g;
	itr = al_dst_itr(child);
	loop {
		if (info = al_next_a(itr, "child")) {
		} else {
			break;
		}
		g = info.child;
		if (al_is_derived(g, runtime OcxGlyph)) {
			var OcxGlyph o;
			o = g;
			o.Mode(null);
		} else {
			g.status = Status::Layout;
		}
	}
	status = Status::Edit;
}
end_body
member
public: void ExecuteMode();
body
{
	var list itr;
	var TMGlyph info;
	var Glyph g;
	itr = al_dst_itr(child);
	loop {
		if (info = al_next_a(itr, "child")) {
		} else {
			break;
		}
		g = info.child;
		if (al_is_derived(g, runtime OcxGlyph)) {
			var OcxGlyph o;
			o = g;
			o.Mode((list)1);
		} else {
			g.status = Status::Execute;
		}
	}
	status = Status::Execute;
}
end_body
member
public: list Execute(Hit h);
body
{
	var integer type;
	type = h.event.head;
	if (status == Status::Execute && type == Event::LeftPress) {
		return null;
	} else {
		return GlyphEditor::Execute(h);
	}
}
end_body
member
public: list _InsertObject(Hit h);
body
{
	var string cls_name, type, name;
	cls_name = al_gp("class_name_of", this, null, null, null);
	type = al_gp("class_name_of", insert_object, null, null, null);
	loop {
		var AlDialog dialog;
		dialog = new AlDialog;
		if (dialog.ShowInput("Input Name", "")) {
		} else {
			insert_object = null;
			return 1;
		}
		name = dialog.text;
		if (al_gp("regist_var", cls_name, type, name, null)) {
			al_print("Can't use this name. (");
			al_print(cls_name);
			al_print("::");
			al_print(name);
			al_print(")\n");
		} else {
			break;
		}
	}
	al_set_dst_node(this, name, insert_object);
	al_set_dst_node(this.parts, name, insert_object);
	return GlyphEditor::_InsertObject(h);
}
end_body
member
public: list parts;
member
public: void ChangeName();
body
{
	var TMGlyph info;
	if (info = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	var list itr2, itr3;
	itr2 = al_src_itr(info.child);
	itr3 = al_src_itr(info.child);
	loop {
		if (al_addr_eq(al_next(itr2), this)) {
			break;
		} else {
		}
	}
	loop {
		if (al_addr_eq(al_next(itr3), this.parts)) {
			break;
		} else {
		}
	}
	var string cls_name, type;
	cls_name = al_gp("class_name_of", this, null, null, null);
	type = al_gp("class_name_of", info.child, null, null, null);
	loop {
		var string name, new_name;
		name = al_arc_a(itr2);
		var AlDialog dialog;
		dialog = new AlDialog;
		if (dialog.ShowInput("parts name", name)) {
		} else {
			return;
		}
		new_name = dialog.text;
		if (new_name == "") {
			al_print("Please input parts name.\n");
			continue;
		} else {
		}
		if (new_name == name) {
			return;
		} else {
		}
		if (al_gp("regist_var", cls_name, type, new_name, null)) {
			al_print("Can't use this name. (");
			al_print(cls_name);
			al_print("::");
			al_print(new_name);
			al_print(")\n");
		} else {
		}
		al_gp("unregist_var", cls_name, name, null, null);
		al_set_arc_a(itr2, new_name);
		al_set_arc_a(itr3, new_name);
		break;
	}
}
end_body
member
public: void ChangeXCoord();
body
{
	var TMGlyph info;
	if (info = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	var AlDialog dialog;
	dialog = new AlDialog;
	if (dialog.ShowInput("X-Coordinate", (string)info.tm[0][2])) {
	} else {
		return;
	}
	info.child.Damage();
	info.child.KnobDamage();
	info.tm[0][2] = (integer)dialog.text;
	info.SetTM(info.tm);
	var SpIdxGlyph parent;
	parent = al_src_node(info, "child");
	parent.MakeSpaceIndex(info);
	info.child.Damage();
	info.child.KnobDamage();
}
end_body
member
public: void ChangeYCoord();
body
{
	var TMGlyph info;
	if (info = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	var AlDialog dialog;
	dialog = new AlDialog;
	if (dialog.ShowInput("Y-Coordinate", (string)info.tm[1][2])) {
	} else {
		return;
	}
	info.child.Damage();
	info.child.KnobDamage();
	info.tm[1][2] = (integer)dialog.text;
	info.SetTM(info.tm);
	var SpIdxGlyph parent;
	parent = al_src_node(info, "child");
	parent.MakeSpaceIndex(info);
	info.child.Damage();
	info.child.KnobDamage();
}
end_body
member
public: void ChangeAttrib();
body
{
	var TMGlyph info;
	if (info = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	var Glyph g;
	g = info.child;
	var list rc;
	var string cls_name;
	cls_name = al_gp("class_name_of", g, null, null, null);
	rc = al_gp("runtime_class", cls_name, null, null, null);
	var string m_str, property;
	var list m_ls, itr;
	m_ls = al_gp("var_list", cls_name, null, null, null);
	var AlDialog dialog;
	dialog = new AlDialog;
	if (dialog.ShowSelect("Select attribute name", m_ls)) {
	} else {
		return;
	}
	m_str = dialog.text;
	if (m_str == "") {
		return;
	} else {
	}
	var list var_dcl, var_dcl2;
	if (var_dcl = al_dst_node(m_str, null)) {
	} else {
		al_print("can't find var_dcl.\n");
		return;
	}
	var list itr;
	loop {
		itr = al_dst_itr(rc);
		loop {
			if (var_dcl2 = al_next(itr)) {
			} else {
				break;
			}
			if (al_addr_eq(var_dcl2, var_dcl)) {
				break;
			} else {
			}
		}
		if (var_dcl2) {
			break;
		} else {
		}
		if (rc = al_src_node(rc, "$subclass")) {
		} else {
			al_print("can't find var_dcl.\n");
			return;
		}
	}
	property = al_arc_a(itr);
	var integer type;
	var list value;
	value = al_dst_node(g, property);
	if (al_is_type(value, "string")) {
		type = 1;
	} else {
	}
	if (al_is_type(value, "integer")) {
		type = 2;
		value = (string)value;
	} else {
	}
	if (al_is_type(value, "real")) {
		type = 3;
		value = (string)value;
	} else {
	}
	if (type) {
	} else {
		al_print("attribute types which can be setted are only integer, real, and string.\n");
		return;
	}
	dialog = new AlDialog;
	if (dialog.ShowInput(property, (string)value)) {
	} else {
		return;
	}
	value = dialog.text;
	if (type == 2) {
		value = (integer)value;
	} else {
	}
	if (type == 3) {
		value = (real)value;
	} else {
	}
	info.child.Damage();
	info.child.KnobDamage();
	var list obj;
	if (obj = al_dst_node(g, property)) {
		al_remove_from(g, obj, property);
	} else {
	}
	al_create_arc(g, value, property);
	g.Resize(g);
	g.AllocationChanged(g);
	info.child.Damage();
	info.child.KnobDamage();
}
end_body
member
public: void AlignHorizTop();
body
{
	var integer pos;
	pos = 9.999999999999772e+29;
	var list itr;
	var TMGlyph info;
	itr = al_dst_itr(selection);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		pos = (integer)al_min(pos, info.top);
	}
	itr = al_dst_itr(selection);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		info.Damage();
		info.KnobDamage();
		info.Move(0, pos - info.top);
		info.Damage();
		info.KnobDamage();
		child.MakeSpaceIndex(info);
	}
}
end_body
member
public: void AlignHorizCenter();
body
{
	var integer n, sum, pos;
	n = sum = 0;
	var list itr;
	var TMGlyph info;
	itr = al_dst_itr(selection);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		sum = sum + (info.top + info.bottom) / 2;
		n = n + 1;
	}
	if (n == 0) {
		return;
	} else {
	}
	pos = (integer)(sum / n);
	itr = al_dst_itr(selection);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		info.Damage();
		info.KnobDamage();
		info.Move(0, pos - (info.top + info.bottom) / 2);
		info.Damage();
		info.KnobDamage();
		child.MakeSpaceIndex(info);
	}
}
end_body
member
public: void AlignHorizBottom();
body
{
	var integer pos;
	pos = -1.e+30;
	var list itr;
	var TMGlyph info;
	itr = al_dst_itr(selection);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		pos = (integer)al_max(pos, info.bottom);
	}
	itr = al_dst_itr(selection);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		info.Damage();
		info.KnobDamage();
		info.Move(0, pos - info.bottom);
		info.Damage();
		info.KnobDamage();
		child.MakeSpaceIndex(info);
	}
}
end_body
member
public: void AlignVertLeft();
body
{
	var integer pos;
	pos = 9.999999999999772e+29;
	var list itr;
	var TMGlyph info;
	itr = al_dst_itr(selection);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		pos = (integer)al_min(pos, info.left);
	}
	itr = al_dst_itr(selection);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		info.Damage();
		info.KnobDamage();
		info.Move(pos - info.left, 0);
		info.Damage();
		info.KnobDamage();
		child.MakeSpaceIndex(info);
	}
}
end_body
member
public: void AlignVertCenter();
body
{
	var integer n, sum, pos;
	n = sum = 0;
	var list itr;
	var TMGlyph info;
	itr = al_dst_itr(selection);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		sum = sum + (info.left + info.right) / 2;
		n = n + 1;
	}
	if (n == 0) {
		return;
	} else {
	}
	pos = (integer)(sum / n);
	itr = al_dst_itr(selection);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		info.Damage();
		info.KnobDamage();
		info.Move(pos - (info.left + info.right) / 2, 0);
		info.Damage();
		info.KnobDamage();
		child.MakeSpaceIndex(info);
	}
}
end_body
member
public: void AlignVertRight();
body
{
	var integer pos;
	pos = -1.e+30;
	var list itr;
	var TMGlyph info;
	itr = al_dst_itr(selection);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		pos = (integer)al_max(pos, info.right);
	}
	itr = al_dst_itr(selection);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		info.Damage();
		info.KnobDamage();
		info.Move(pos - info.right, 0);
		info.Damage();
		info.KnobDamage();
		child.MakeSpaceIndex(info);
	}
}
end_body
member
public: void AlignWidth();
body
{
	var list sel, itr;
	var TMGlyph info, info1;
	var integer n, pos;
	n = 0;
	sel = al_cons(null, null);
	loop {
		if (al_dst_node(selection, "$select")) {
		} else {
			break;
		}
		itr = al_dst_itr(selection);
		pos = 9.999999999999772e+29;
		loop {
			if (info = al_next_a(itr, "$select")) {
			} else {
				break;
			}
			if (info.left < pos) {
				info1 = info;
				pos = info.left;
			} else {
			}
		}
		al_remove_from(selection, info1, "$select");
		al_create_arc(sel, info1, "$select");
		n = n + 1;
	}
	selection = sel;
	if (n <= 2) {
		return;
	} else {
	}
	var integer p_left, p_right, p_width, width;
	itr = al_dst_itr(selection);
	info = al_next_a(itr, "$select");
	p_left = pos = info.left;
	p_width = info.Width();
	loop {
		if (info = al_next_a(itr, "$select")) {
			p_right = info.right;
			p_width = p_width + info.Width();
		} else {
			break;
		}
	}
	width = (integer)((p_right - p_left - p_width) / (n - 1));
	itr = al_dst_itr(selection);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		info.Damage();
		info.KnobDamage();
		info.Move(pos - info.left, 0);
		info.Damage();
		info.KnobDamage();
		child.MakeSpaceIndex(info);
		pos = pos + info.Width() + width;
	}
}
end_body
member
public: void AlignHeight();
body
{
	var list sel, itr;
	var TMGlyph info, info1;
	var integer n, pos;
	n = 0;
	sel = al_cons(null, null);
	loop {
		if (al_dst_node(selection, "$select")) {
		} else {
			break;
		}
		itr = al_dst_itr(selection);
		pos = 9.999999999999772e+29;
		loop {
			if (info = al_next_a(itr, "$select")) {
			} else {
				break;
			}
			if (info.top < pos) {
				info1 = info;
				pos = info.top;
			} else {
			}
		}
		al_remove_from(selection, info1, "$select");
		al_create_arc(sel, info1, "$select");
		n = n + 1;
	}
	selection = sel;
	if (n <= 2) {
		return;
	} else {
	}
	var integer p_top, p_bottom, p_height, height;
	itr = al_dst_itr(selection);
	info = al_next_a(itr, "$select");
	p_top = pos = info.top;
	p_height = info.Height();
	loop {
		if (info = al_next_a(itr, "$select")) {
			p_bottom = info.bottom;
			p_height = p_height + info.Height();
		} else {
			break;
		}
	}
	height = (integer)((p_bottom - p_top - p_height) / (n - 1));
	itr = al_dst_itr(selection);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		info.Damage();
		info.KnobDamage();
		info.Move(0, pos - info.top);
		info.Damage();
		info.KnobDamage();
		child.MakeSpaceIndex(info);
		pos = pos + info.Height() + height;
	}
}
end_body
member
public: void AttachLeft();
body
{
	var TMGlyph info;
	if (info = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	var AlDialog dialog;
	dialog = new AlDialog;
	var integer offset;
	if (dialog.ShowInput("Input offset", "0")) {
	} else {
		return;
	}
	offset = (integer)dialog.text;
	Attach(info, FormGlyph::Left, 0, offset);
	Resize(left, top, right, bottom);
	Damage();
}
end_body
member
public: void AttachTop();
body
{
	var TMGlyph info;
	if (info = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	var AlDialog dialog;
	dialog = new AlDialog;
	var integer offset;
	if (dialog.ShowInput("Input offset", "0")) {
	} else {
		return;
	}
	offset = (integer)dialog.text;
	Attach(info, FormGlyph::Top, 0, offset);
	Resize(left, top, right, bottom);
	Damage();
}
end_body
member
public: void AttachRight();
body
{
	var TMGlyph info;
	if (info = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	var AlDialog dialog;
	dialog = new AlDialog;
	var integer offset;
	if (dialog.ShowInput("Input offset", "0")) {
	} else {
		return;
	}
	offset = (integer)dialog.text;
	Attach(info, FormGlyph::Right, 0, offset);
	Resize(left, top, right, bottom);
	Damage();
}
end_body
member
public: void AttachBottom();
body
{
	var TMGlyph info;
	if (info = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	var AlDialog dialog;
	dialog = new AlDialog;
	var integer offset;
	if (dialog.ShowInput("Input offset", "0")) {
	} else {
		return;
	}
	offset = (integer)dialog.text;
	Attach(info, FormGlyph::Bottom, 0, offset);
	Resize(left, top, right, bottom);
	Damage();
}
end_body
member
public: void AttachOppositeLeft();
body
{
	var TMGlyph info;
	if (info = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	var AlDialog dialog;
	dialog = new AlDialog;
	var integer offset;
	if (dialog.ShowInput("Input offset", "20")) {
	} else {
		return;
	}
	offset = (integer)dialog.text;
	Attach(info, FormGlyph::Left, 1, offset);
	Resize(left, top, right, bottom);
	Damage();
}
end_body
member
public: void AttachOppositeTop();
body
{
	var TMGlyph info;
	if (info = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	var AlDialog dialog;
	dialog = new AlDialog;
	var integer offset;
	if (dialog.ShowInput("Input offset", "20")) {
	} else {
		return;
	}
	offset = (integer)dialog.text;
	Attach(info, FormGlyph::Top, 1, offset);
	Resize(left, top, right, bottom);
	Damage();
}
end_body
member
public: void AttachOppositeRight();
body
{
	var TMGlyph info;
	if (info = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	var AlDialog dialog;
	dialog = new AlDialog;
	var integer offset;
	if (dialog.ShowInput("Input offset", "20")) {
	} else {
		return;
	}
	offset = (integer)dialog.text;
	Attach(info, FormGlyph::Right, 1, offset);
	Resize(left, top, right, bottom);
	Damage();
}
end_body
member
public: void AttachOppositeBottom();
body
{
	var TMGlyph info;
	if (info = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	var AlDialog dialog;
	dialog = new AlDialog;
	var integer offset;
	if (dialog.ShowInput("Input offset", "20")) {
	} else {
		return;
	}
	offset = (integer)dialog.text;
	Attach(info, FormGlyph::Bottom, 1, offset);
	Resize(left, top, right, bottom);
	Damage();
}
end_body
member
public: void DetachLeft();
body
{
	var TMGlyph info;
	if (info = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	Attach(info, FormGlyph::Left, -1, 0);
}
end_body
member
public: void DetachTop();
body
{
	var TMGlyph info;
	if (info = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	Attach(info, FormGlyph::Top, -1, 0);
}
end_body
member
public: void DetachRight();
body
{
	var TMGlyph info;
	if (info = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	Attach(info, FormGlyph::Right, -1, 0);
}
end_body
member
public: void DetachBottom();
body
{
	var TMGlyph info;
	if (info = al_dst_node(selection, "$select")) {
	} else {
		return;
	}
	Attach(info, FormGlyph::Bottom, -1, 0);
}
end_body
member
public: void ConnectScroll();
body
{
	var list itr;
	var TMGlyph info, scroll_info, sbar_info;
	var Glyph g;
	var ScrollGlyph scroll;
	var AlScrollBar sbar;
	itr = al_dst_itr(selection);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		if (g = info.child) {
		} else {
			continue;
		}
		if (al_is_derived(g, runtime ScrollGlyph)) {
			scroll_info = info;
			scroll = g;
			continue;
		} else {
		}
		if (al_is_derived(g, runtime AlScrollBar)) {
			sbar_info = info;
			sbar = g;
			continue;
		} else {
		}
	}
	if (scroll && sbar) {
	} else {
		al_print("Do it after selection of ScrollGlyph and ScrollBar.\n");
		return;
	}
	sbar.Connect(scroll);
	var list attach, itr2;
	itr = al_dst_itr(attachment);
	loop {
		if (attach = al_next_a(itr, null)) {
		} else {
			break;
		}
		if (al_addr_eq(attach.head, scroll_info) && al_addr_eq(attach.tail.tail.head, sbar_info)) {
			return;
		} else {
		}
	}
	// obtain member variable name
	var string scroll_name, sbar_name;
	itr2 = al_src_itr(scroll_info.child);
	loop {
		if (al_addr_eq(al_next(itr2), this)) {
			break;
		} else {
		}
	}
	scroll_name = al_arc_a(itr2);
	itr2 = al_src_itr(sbar_info.child);
	loop {
		if (al_addr_eq(al_next(itr2), this)) {
			break;
		} else {
		}
	}
	sbar_name = al_arc_a(itr2);
	attach = al_list4(sbar_info, FormGlyph::ConnectScroll, sbar_name, scroll_name);
	al_create_arc(attachment, attach, null);
}
end_body
member
public: void Delete();
body
{
	var list itr, itr2;
	var list attach;
	itr = al_dst_itr(selection);
	var TMGlyph info;
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		itr2 = al_src_itr(info.child);
		loop {
			if (al_addr_eq(al_next(itr2), this)) {
				break;
			} else {
			}
		}
		var string cls_name, name;
		cls_name = al_gp("class_name_of", this, null, null, null);
		name = al_arc_a(itr2);
		al_gp("unregist_var", cls_name, name, null, null);
		al_set_dst_node(this, name, null);
		al_set_dst_node(this.parts, name, null);
		info.child.Destroy();
		info.child.Damage();
		info.child.KnobDamage();
		child.Remove(info);
		itr2 = al_dst_itr(attachment);
		loop {
			if (attach = al_next(itr2)) {
			} else {
				break;
			}
			if (al_addr_eq(attach.head, info)) {
			} else {
				continue;
			}
			al_remove(itr2);
		}
		al_remove(itr);
	}
}
end_body
member
public: static list proj_info;
member
public: static string GetPath();
body
{
	var string dir;
	if (proj_info) {
		dir = _GetPath();
		dir = dir + "/data_dir";
		if (al_file_manip("does_exist", dir, null)) {
		} else {
			al_file_manip("mk_dir", dir, null);
		}
		return dir;
	} else {
		al_print("GetPath(): can't find proj_info.\n");
		return ".";
	}
}
end_body
member
public: static string _GetPath();
body
{
	return proj_info.tail.head;
}
end_body
member
public: static string GetEditorID();
body
{
	var string path;
	path = GetPath() + "/editor.seq";
	var file f;
	var integer id;
	if (al_file_manip("does_exist", path, null)) {
		f = al_file_open(path, "r");
		id = al_file_read(f, "integer");
		f = null;
	} else {
		id = 1;
	}
	f = al_file_open(path, "w");
	al_file_write(f, "integer", id + 1);
	f = null;
	return "ed" + (string)id + ".dat";
}
end_body
member
public: static string GetOcxSubStgID();
body
{
	var string path;
	path = GetPath() + "/ocx.seq";
	var file f;
	var integer id;
	if (al_file_manip("does_exist", path, null)) {
		f = al_file_open(path, "r");
		id = al_file_read(f, "integer");
		f = null;
	} else {
		id = 1;
	}
	f = al_file_open(path, "w");
	al_file_write(f, "integer", id + 1);
	f = null;
	return "X" + (string)id;
}
end_body
member
public: window wnd;
member
public: void public_func();
body
{
	CreateWindow((string)null, null, null, null);
	CreateWindow2((string)null, null, null, null);
	CreateWindow((string)null);
	CreateWindow2((string)null);
}
end_body
member
public: list GenerateCode();
body
{
	SaveEditor(this);
	var list pif;
	var string cls_name;
	cls_name = al_gp("class_name_of", this, null, null, null);
	pif = al_gp("pif_create", cls_name, null, "GbInit", null);
	al_gp("pif_clear", pif, null, null, null);
	var list itr, itr2;
	var TMGlyph info;
	var integer x, y;
	var Glyph g;
	var list attach;
	var integer what, opposite, offset;
	var string str;
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "Create(0, 0, 1500, 1500);"));
	err = (err || GbCode(pif, "var Glyph p;"));
	err = (err || GbCode(pif, "var TMGlyph info;"));
	itr = al_dst_itr(child);
	loop {
		if (info = al_next_a(itr, "child")) {
		} else {
			break;
		}
		g = info.child;
		err = (err || g.GbCode(pif));
		if (info.tm) {
			x = info.tm[0][2];
			y = info.tm[1][2];
		} else {
			x = y = 0;
		}
		err = (err || GbCode(pif, "p.status = Status::Execute;"));
		// obtain member variable name
		itr2 = al_src_itr(info.child);
		loop {
			if (al_addr_eq(al_next(itr2), this)) {
				break;
			} else {
			}
		}
		err = (err || GbCode(pif, al_arc_a(itr2) + " = p;"));
		err = (err || GbCode(pif, "info = child.Append(p, " + (string)x + ", " + (string)y + ");"));
		itr2 = al_dst_itr(attachment);
		loop {
			if (attach = al_next(itr2)) {
			} else {
				break;
			}
			if (al_addr_eq(attach.head, info)) {
			} else {
				continue;
			}
			what = attach.tail.head;
			opposite = attach.tail.tail.head;
			offset = attach.tail.tail.tail.head;
			if (what == FormGlyph::Left) {
				str = "Attach(info, FormGlyph::Left, " + (string)opposite + ", " + (string)offset + ");";
				err = (err || GbCode(pif, str));
			} else {
			}
			if (what == FormGlyph::Top) {
				str = "Attach(info, FormGlyph::Top, " + (string)opposite + ", " + (string)offset + ");";
				err = (err || GbCode(pif, str));
			} else {
			}
			if (what == FormGlyph::Right) {
				str = "Attach(info, FormGlyph::Right, " + (string)opposite + ", " + (string)offset + ");";
				err = (err || GbCode(pif, str));
			} else {
			}
			if (what == FormGlyph::Bottom) {
				str = "Attach(info, FormGlyph::Bottom, " + (string)opposite + ", " + (string)offset + ");";
				err = (err || GbCode(pif, str));
			} else {
			}
		}
	}
	itr2 = al_dst_itr(attachment);
	var string sbar_name, scroll_name;
	loop {
		if (attach = al_next(itr2)) {
		} else {
			break;
		}
		if (attach.tail.head == FormGlyph::ConnectScroll) {
		} else {
			continue;
		}
		sbar_name = attach.tail.tail.head;
		scroll_name = attach.tail.tail.tail.head;
		err = (err || GbCode(pif, sbar_name + ".Connect(" + scroll_name + ");"));
	}
	err = (err || GbCode(pif, "MakeSpaceIndex();"));
	var list rect;
	rect = al_get_window_rect(wnd, 0);
	err = (err || GbCode(pif, "return al_list4(" + (string)rect.head + ", " + (string)rect.tail.head + ", " + (string)rect.tail.tail.head + ", " + (string)rect.tail.tail.tail.head + ");"));
	err = (err || GbCode(pif, "}"));
	al_gp("pif_destroy", pif, null, null, null);
	return err;
}
end_body
member
public: void SaveEditor(Glyph g);
body
{
	var list itr;
	itr = al_dst_itr(g);
	var Glyph g1;
	loop {
		if (g1 = al_next_a(itr, "child")) {
		} else {
			break;
		}
		if (al_is_derived(g1, runtime Editor)) {
			var Editor ed;
			ed = g1;
			var string file_name;
			if (file_name = al_dst_node(ed, "$editor_id")) {
				var file f;
				if (f = al_file_open(GetPath() + "/" + file_name, "w")) {
					ed.Save(f);
					f = null;
				} else {
				}
			} else {
			}
		} else {
		}
		SaveEditor(g1);
	}
}
end_body
member
public: static variant LoadPicture(string name);
body
{
	return al_ocx("Picture", GetPath(), name, null);
}
end_body
member
public: AlMenu custom_menu;
member
public: list GbInit();
body
{
}
end_body
member
public: integer back_color;
member
public: integer border_width;
member
public: integer light_color;
member
public: integer shadow_color;
member
public: void public_var();
body
{
	back_color;
	border_width;
	light_color;
	shadow_color;
}
end_body
member
public: list GbCode(list pif);
body
{
	var list err;
	var string cls_name;
	cls_name = al_gp("class_name_of", this, null, null, null);
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var " + cls_name + " pp;"));
	err = (err || GbCode(pif, "pp = new " + cls_name + ";"));
	err = (err || GbCode(pif, "pp.GbInit();"));
	err = (err || GbCode(pif, "pp.Resize(" + GbGeom() + ");"));
	err = (err || GbCode(pif, "pp.back_color = " + (string)back_color + ";"));
	err = (err || GbCode(pif, "pp.border_width = " + (string)border_width + ";"));
	err = (err || GbCode(pif, "pp.light_color = " + (string)light_color + ";"));
	err = (err || GbCode(pif, "pp.shadow_color = " + (string)shadow_color + ";"));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
	return err;
}
end_body
member
public: static GUIbuilder CreateWindow(string name, list style, list parent, list geom);
body
{
	var GUIbuilder gb;
	al_gp("vtbl", null, null, null, null);
	if (gb = al_gp("new", name, null, null, null)) {
	} else {
		return null;
	}
	gb.GbInit();
	if (gb.left && gb.top && gb.right && gb.bottom) {
	} else {
		al_print("Screen source codes not generated.\n");
		return null;
	}
	var Window w;
	w = new Window;
	w.Create(gb, (list)al_list3(style, parent, geom));
	gb.wnd = w.wnd;
	return gb;
}
end_body
member
public: static list CreateWindow2(string name, list style, list parent, list geom);
body
{
	var GUIbuilder gb;
	al_gp("vtbl", null, null, null, null);
	if (gb = al_gp("new", name, null, null, null)) {
	} else {
		return null;
	}
	gb.GbInit();
	if (gb.left && gb.top && gb.right && gb.bottom) {
	} else {
		al_print("Screen source codes not generated.\n");
		return null;
	}
	var Window w;
	w = new Window;
	w.Create(gb, (list)al_list3(style, parent, geom));
	gb.wnd = w.wnd;
	return al_list2(gb, w.wnd);
}
end_body
member
public: static GUIbuilder CreateWindow(string name);
body
{
	var list geom;
	var GUIbuilder gb;
	al_gp("vtbl", null, null, null, null);
	if (gb = al_gp("new", name, null, null, null)) {
	} else {
		return null;
	}
	geom = gb.GbInit();
	if (gb.left && gb.top && gb.right && gb.bottom) {
	} else {
		al_print("Screen source codes not generated.\n");
		return null;
	}
	var Window w;
	w = new Window;
	w.Create(gb, (list)al_list3(null, null, geom));
	gb.wnd = w.wnd;
	return gb;
}
end_body
member
public: static list CreateWindow2(string name);
body
{
	var list geom;
	var GUIbuilder gb;
	al_gp("vtbl", null, null, null, null);
	if (gb = al_gp("new", name, null, null, null)) {
	} else {
		return null;
	}
	geom = gb.GbInit();
	if (gb.left && gb.top && gb.right && gb.bottom) {
	} else {
		al_print("Screen source codes not generated.\n");
		return null;
	}
	var Window w;
	w = new Window;
	w.Create(gb, (list)al_list3(null, null, geom));
	gb.wnd = w.wnd;
	return al_list2(gb, w.wnd);
}
end_body
member
public: void AfterFirstMoveControl();
member
public: void BeforeDestroy();
body
{
}
end_body
member
public: void Close();
body
{
}
end_body
end_class
TEXT
Glyph
class GbGp
member
public: static void Run();
body
{
	Initialize();
	GpEditor::Init();
	var GbGpPanel panel;
	GbGpPanel::inst = panel = new GbGpPanel;
	panel.Create();
	panel.left = panel.top = 0;
	panel.right = panel.bottom = 200;
	var Window wnd;
	wnd = new Window;
	var list geom;
	geom = al_list4(20, 20, 300, 360);
	wnd.Create(panel, (list)al_list3(0x1, null, geom));
	wnd.SetTitle("Control Panel");
}
end_body
member
public: static void AutoExec();
body
{
	Run();
	var string cmd_line, dir, name;
	var file f;
	if (cmd_line = al_misc("get_cmd_line", null, null)) {
	} else {
		return;
	}
	f = al_file_open(cmd_line, "sr");
	if (al_file_match_str(f, "dir")) {
		dir = al_file_read(f, "string");
	} else {
		dir = ".";
	}
	al_file_manip("chg_dir", dir, null);
	if (al_file_match_str(f, "file")) {
		name = al_file_read(f, "string");
	} else {
	}
	if (name) {
		GbGpCtrl::inst._PanelProjOpen(dir, name);
		GbGpCtrl::inst.PanelProjExec();
	} else {
		return;
	}
}
end_body
member
public: window wnd;
member
public: GpEditor editor;
member
public: void PutClass();
body
{
	editor.status = GpEditor::PutClass;
	al_message_text(wnd, "Please click where putting an object.");
}
end_body
member
public: void PutObject();
body
{
	editor.status = GpEditor::PutObject;
	al_message_text(wnd, "Please click where putting an object.");
}
end_body
member
public: void Copy();
body
{
	editor.Copy();
}
end_body
member
public: void Paste();
body
{
	editor.Paste();
}
end_body
member
public: void Delete();
body
{
	editor.Delete();
}
end_body
class GbGpPanel
member
public: void Create();
body
{
	if (ctrl) {
	} else {
		GbGpCtrl::inst = ctrl = new GbGpCtrl;
	}
	var TMGlyph proj_info, new_proj_info, open_proj_info, save_proj_info, clear_proj_info;
	var TMGlyph exec_proj_info, pkg_proj_info;
	var TMGlyph proj_lab_info, gamen_kind_lab_info;
	var TMGlyph gamen_kind_info, gamen_select_info;
	child = new FormGlyph;
	proj_lab = new LabelGlyph;
	proj = new AlComboBox;
	new_proj = new AlButton;
	open_proj = new AlButton;
	save_proj = new AlButton;
	clear_proj = new AlButton;
	exec_proj = new AlButton;
	pkg_proj = new AlButton;
	gamen_kind_lab = new StaticLabel;
	gamen_kind = new AlComboBox;
	gamen_select = new PatchGlyph;
	proj_lab.Create(0, 0, 100, 80, "Project");
	proj.Create(0, 0, 150, 150);
	proj.status = Status::Execute;
	new_proj.Create(0, 0, 80, 20, "New");
	new_proj.status = Status::Execute;
	open_proj.Create(0, 0, 80, 20, "Open");
	open_proj.status = Status::Execute;
	save_proj.Create(0, 0, 80, 20, "Save");
	save_proj.status = Status::Execute;
	clear_proj.Create(0, 0, 80, 20, "Close");
	clear_proj.status = Status::Execute;
	exec_proj.Create(0, 0, 80, 20, "Execute");
	exec_proj.status = Status::Execute;
	pkg_proj.Create(0, 0, 80, 20, "Package");
	pkg_proj.status = Status::Execute;
	gamen_kind_lab.Create(0, 0, 100, 80, "Kind");
	gamen_kind.Create(0, 0, 100, 80);
	gamen_kind.status = Status::Execute;
	gamen_kind.child.AddItem(0, "GUI Screen");
	gamen_kind.child.AddItem(1, "Program Screen");
	gamen_select.Resize(0, 0, 200, 200);
	proj_lab_info = child.Append(proj_lab, 0, 0);
	new_proj_info = child.Append(new_proj, 0, 0);
	open_proj_info = child.Append(open_proj, 0, 0);
	save_proj_info = child.Append(save_proj, 0, 0);
	clear_proj_info = child.Append(clear_proj, 0, 0);
	exec_proj_info = child.Append(exec_proj, 0, 0);
	pkg_proj_info = child.Append(pkg_proj, 0, 0);
	gamen_kind_lab_info = child.Append(gamen_kind_lab, 0, 0);
	gamen_select_info = child.Append(gamen_select, 0, 0);
	gamen_kind_info = child.Append(gamen_kind, 0, 0);
	proj_info = child.Append(proj, 0, 0);
	child.Attach(proj_lab_info, FormGlyph::Left, 0, 10);
	child.Attach(proj_lab_info, FormGlyph::Top, 0, 10);
	child.Attach(proj_lab_info, FormGlyph::Right, 1, 110);
	child.Attach(proj_lab_info, FormGlyph::Bottom, 1, 30);
	child.Attach(proj_info, FormGlyph::Left, 0, 120);
	child.Attach(proj_info, FormGlyph::Top, 0, 10);
	child.Attach(proj_info, FormGlyph::Right, 0, 10);
	child.Attach(proj_info, FormGlyph::Bottom, 1, 155);
	child.Attach(new_proj_info, FormGlyph::Left, 0, 10);
	child.Attach(new_proj_info, FormGlyph::Top, 0, 40);
	child.Attach(new_proj_info, FormGlyph::Right, 1, 70);
	child.Attach(new_proj_info, FormGlyph::Bottom, 1, 60);
	child.Attach(open_proj_info, FormGlyph::Left, 0, 80);
	child.Attach(open_proj_info, FormGlyph::Top, 0, 40);
	child.Attach(open_proj_info, FormGlyph::Right, 1, 140);
	child.Attach(open_proj_info, FormGlyph::Bottom, 1, 60);
	child.Attach(save_proj_info, FormGlyph::Left, 0, 150);
	child.Attach(save_proj_info, FormGlyph::Top, 0, 40);
	child.Attach(save_proj_info, FormGlyph::Right, 1, 210);
	child.Attach(save_proj_info, FormGlyph::Bottom, 1, 60);
	child.Attach(clear_proj_info, FormGlyph::Left, 0, 220);
	child.Attach(clear_proj_info, FormGlyph::Top, 0, 40);
	child.Attach(clear_proj_info, FormGlyph::Right, 1, 280);
	child.Attach(clear_proj_info, FormGlyph::Bottom, 1, 60);
	child.Attach(exec_proj_info, FormGlyph::Left, 0, 10);
	child.Attach(exec_proj_info, FormGlyph::Top, 0, 70);
	child.Attach(exec_proj_info, FormGlyph::Right, 1, 70);
	child.Attach(exec_proj_info, FormGlyph::Bottom, 1, 90);
	child.Attach(pkg_proj_info, FormGlyph::Left, 0, 80);
	child.Attach(pkg_proj_info, FormGlyph::Top, 0, 70);
	child.Attach(pkg_proj_info, FormGlyph::Right, 1, 140);
	child.Attach(pkg_proj_info, FormGlyph::Bottom, 1, 90);
	child.Attach(gamen_kind_lab_info, FormGlyph::Left, 0, 10);
	child.Attach(gamen_kind_lab_info, FormGlyph::Top, 0, 100);
	child.Attach(gamen_kind_lab_info, FormGlyph::Right, 1, 70);
	child.Attach(gamen_kind_lab_info, FormGlyph::Bottom, 1, 120);
	child.Attach(gamen_kind_info, FormGlyph::Left, 0, 80);
	child.Attach(gamen_kind_info, FormGlyph::Top, 0, 100);
	child.Attach(gamen_kind_info, FormGlyph::Right, 0, 10);
	child.Attach(gamen_kind_info, FormGlyph::Bottom, 1, 210);
	child.Attach(gamen_select_info, FormGlyph::Left, 0, 10);
	child.Attach(gamen_select_info, FormGlyph::Top, 0, 130);
	child.Attach(gamen_select_info, FormGlyph::Right, 0, 10);
	child.Attach(gamen_select_info, FormGlyph::Bottom, 0, 10);
	gb_select = CreateGb();
	gp_select = CreateGp();
	gamen_select.Append(gb_select, 0, 0);
	gamen_select.Append(gp_select, 0, 0);
	al_create_arc(this, proj, "$selector");
	al_create_arc(this, gamen_kind, "$selector");
	al_create_arc(this, gb_list.vbox, "$selector");
	al_create_arc(this, gp_list.vbox, "$selector");
	new_proj.SetCallback(ctrl, GbGpCtrl::PanelProjNew);
	open_proj.SetCallback(ctrl, GbGpCtrl::PanelProjOpen);
	save_proj.SetCallback(ctrl, GbGpCtrl::PanelProjSave);
	clear_proj.SetCallback(ctrl, GbGpCtrl::PanelProjClose);
	exec_proj.SetCallback(ctrl, GbGpCtrl::PanelProjExec);
	pkg_proj.SetCallback(ctrl, GbGpCtrl::PanelProjPkg);
	projects = al_cons(null, null);
	CreateClassList();
}
end_body
member
public: FormGlyph CreateGb();
body
{
	var TMGlyph gb_name_label_info, gb_name_field_info;
	var TMGlyph gb_class_label_info, gb_class_field_info;
	var TMGlyph gb_list_info, new_gb_info, open_gb_info, delete_gb_info;
	gb_select = new FormGlyph;
	gb_name_label = new StaticLabel;
	gb_name_field = new FrameLabel;
	gb_class_label = new StaticLabel;
	gb_class_field = new FrameLabel;
	gb_list = new AlListBox;
	new_gb = new AlButton;
	open_gb = new AlButton;
	delete_gb = new AlButton;
	gb_name_label.Create(0, 0, 80, 20, "Name");
	gb_name_field.Create(0, 0, 100, 20, "");
	gb_class_label.Create(0, 0, 80, 20, "Class");
	gb_class_field.Create(0, 0, 100, 20, "");
	gb_list.Create(0, 0, 150, 150);
	gb_list.status = Status::Execute;
	new_gb.Create(0, 0, 80, 20, "New");
	new_gb.status = Status::Execute;
	open_gb.Create(0, 0, 80, 20, "Open");
	open_gb.status = Status::Execute;
	delete_gb.Create(0, 0, 80, 20, "Delete");
	delete_gb.status = Status::Execute;
	gb_name_label_info = gb_select.Append(gb_name_label, 0, 0);
	gb_name_field_info = gb_select.Append(gb_name_field, 0, 0);
	gb_class_label_info = gb_select.Append(gb_class_label, 0, 0);
	gb_class_field_info = gb_select.Append(gb_class_field, 0, 0);
	gb_list_info = gb_select.Append(gb_list, 0, 0);
	new_gb_info = gb_select.Append(new_gb, 0, 0);
	open_gb_info = gb_select.Append(open_gb, 0, 0);
	delete_gb_info = gb_select.Append(delete_gb, 0, 0);
	gb_select.Attach(gb_name_label_info, FormGlyph::Left, 0, 10);
	gb_select.Attach(gb_name_label_info, FormGlyph::Top, 0, 10);
	gb_select.Attach(gb_name_label_info, FormGlyph::Right, 1, 80);
	gb_select.Attach(gb_name_label_info, FormGlyph::Bottom, 1, 30);
	gb_select.Attach(gb_name_field_info, FormGlyph::Left, 0, 80);
	gb_select.Attach(gb_name_field_info, FormGlyph::Top, 0, 10);
	gb_select.Attach(gb_name_field_info, FormGlyph::Right, 0, 20);
	gb_select.Attach(gb_name_field_info, FormGlyph::Bottom, 1, 30);
	gb_select.Attach(gb_class_label_info, FormGlyph::Left, 0, 10);
	gb_select.Attach(gb_class_label_info, FormGlyph::Top, 0, 40);
	gb_select.Attach(gb_class_label_info, FormGlyph::Right, 1, 80);
	gb_select.Attach(gb_class_label_info, FormGlyph::Bottom, 1, 60);
	gb_select.Attach(gb_class_field_info, FormGlyph::Left, 0, 80);
	gb_select.Attach(gb_class_field_info, FormGlyph::Top, 0, 40);
	gb_select.Attach(gb_class_field_info, FormGlyph::Right, 0, 20);
	gb_select.Attach(gb_class_field_info, FormGlyph::Bottom, 1, 60);
	gb_select.Attach(new_gb_info, FormGlyph::Left, 0, 10);
	gb_select.Attach(new_gb_info, FormGlyph::Top, 1, 30);
	gb_select.Attach(new_gb_info, FormGlyph::Right, 1, 90);
	gb_select.Attach(new_gb_info, FormGlyph::Bottom, 0, 10);
	gb_select.Attach(open_gb_info, FormGlyph::Left, 0, 100);
	gb_select.Attach(open_gb_info, FormGlyph::Top, 1, 30);
	gb_select.Attach(open_gb_info, FormGlyph::Right, 1, 180);
	gb_select.Attach(open_gb_info, FormGlyph::Bottom, 0, 10);
	gb_select.Attach(delete_gb_info, FormGlyph::Left, 0, 190);
	gb_select.Attach(delete_gb_info, FormGlyph::Top, 1, 30);
	gb_select.Attach(delete_gb_info, FormGlyph::Right, 1, 270);
	gb_select.Attach(delete_gb_info, FormGlyph::Bottom, 0, 10);
	gb_select.Attach(gb_list_info, FormGlyph::Left, 0, 10);
	gb_select.Attach(gb_list_info, FormGlyph::Top, 0, 70);
	gb_select.Attach(gb_list_info, FormGlyph::Right, 0, 10);
	gb_select.Attach(gb_list_info, FormGlyph::Bottom, 0, 40);
	gb_select.Resize(0, 0, 300, 300);
	new_gb.SetCallback(ctrl, GbGpCtrl::PanelGbNew);
	open_gb.SetCallback(ctrl, GbGpCtrl::PanelGbOpen);
	delete_gb.SetCallback(ctrl, GbGpCtrl::PanelGbDelete);
	return gb_select;
}
end_body
member
public: FormGlyph CreateGp();
body
{
	var TMGlyph gp_name_label_info, gp_name_field_info;
	var TMGlyph gp_list_info, new_gp_info, open_gp_info, delete_gp_info;
	gp_select = new FormGlyph;
	gp_name_label = new StaticLabel;
	gp_name_field = new FrameLabel;
	gp_list = new AlListBox;
	new_gp = new AlButton;
	open_gp = new AlButton;
	delete_gp = new AlButton;
	gp_name_label.Create(0, 0, 80, 20, "Name");
	gp_name_field.Create(0, 0, 100, 20, "");
	gp_list.Create(0, 0, 150, 150);
	gp_list.status = Status::Execute;
	new_gp.Create(0, 0, 80, 20, "New");
	new_gp.status = Status::Execute;
	open_gp.Create(0, 0, 80, 20, "Open");
	open_gp.status = Status::Execute;
	delete_gp.Create(0, 0, 80, 20, "Delete");
	delete_gp.status = Status::Execute;
	gp_name_label_info = gp_select.Append(gp_name_label, 0, 0);
	gp_name_field_info = gp_select.Append(gp_name_field, 0, 0);
	gp_list_info = gp_select.Append(gp_list, 0, 0);
	new_gp_info = gp_select.Append(new_gp, 0, 0);
	open_gp_info = gp_select.Append(open_gp, 0, 0);
	delete_gp_info = gp_select.Append(delete_gp, 0, 0);
	gp_select.Attach(gp_name_label_info, FormGlyph::Left, 0, 10);
	gp_select.Attach(gp_name_label_info, FormGlyph::Top, 0, 10);
	gp_select.Attach(gp_name_label_info, FormGlyph::Right, 1, 80);
	gp_select.Attach(gp_name_label_info, FormGlyph::Bottom, 1, 30);
	gp_select.Attach(gp_name_field_info, FormGlyph::Left, 0, 80);
	gp_select.Attach(gp_name_field_info, FormGlyph::Top, 0, 10);
	gp_select.Attach(gp_name_field_info, FormGlyph::Right, 0, 20);
	gp_select.Attach(gp_name_field_info, FormGlyph::Bottom, 1, 30);
	gp_select.Attach(new_gp_info, FormGlyph::Left, 0, 10);
	gp_select.Attach(new_gp_info, FormGlyph::Top, 1, 30);
	gp_select.Attach(new_gp_info, FormGlyph::Right, 1, 90);
	gp_select.Attach(new_gp_info, FormGlyph::Bottom, 0, 10);
	gp_select.Attach(open_gp_info, FormGlyph::Left, 0, 100);
	gp_select.Attach(open_gp_info, FormGlyph::Top, 1, 30);
	gp_select.Attach(open_gp_info, FormGlyph::Right, 1, 180);
	gp_select.Attach(open_gp_info, FormGlyph::Bottom, 0, 10);
	gp_select.Attach(delete_gp_info, FormGlyph::Left, 0, 190);
	gp_select.Attach(delete_gp_info, FormGlyph::Top, 1, 30);
	gp_select.Attach(delete_gp_info, FormGlyph::Right, 1, 270);
	gp_select.Attach(delete_gp_info, FormGlyph::Bottom, 0, 10);
	gp_select.Attach(gp_list_info, FormGlyph::Left, 0, 10);
	gp_select.Attach(gp_list_info, FormGlyph::Top, 0, 40);
	gp_select.Attach(gp_list_info, FormGlyph::Right, 0, 10);
	gp_select.Attach(gp_list_info, FormGlyph::Bottom, 0, 40);
	gp_select.Resize(0, 0, 300, 300);
	new_gp.SetCallback(ctrl, GbGpCtrl::PanelGpNew);
	open_gp.SetCallback(ctrl, GbGpCtrl::PanelGpOpen);
	delete_gp.SetCallback(ctrl, GbGpCtrl::PanelGpDelete);
	return gp_select;
}
end_body
member
public: void Resize(integer l, integer t, integer r, integer b);
body
{
	Glyph::Resize(l, t, r, b);
	child.Resize(l, t, r, b);
}
end_body
member
public: void Draw(window w);
body
{
	child.Draw(w);
}
end_body
member
public: void Pick(Hit h);
body
{
	child.Pick(h);
}
end_body
member
public: list ExecuteParent(integer msg, Glyph g, Hit h);
body
{
	var integer index;
	if (msg == Message::SelectItem) {
		if (al_addr_eq(g, proj)) {
			ctrl.ListUpGbGp();
			return 1;
		} else {
		}
		if (al_addr_eq(g, gamen_kind)) {
			index = gamen_kind.CurrentIndex();
			gamen_select.CurrentIndex(index);
			return 1;
		} else {
		}
		if (al_addr_eq(g, gb_list.vbox)) {
			ctrl.UpdateGbGamenName();
			return 1;
		} else {
		}
		if (al_addr_eq(g, gp_list.vbox)) {
			ctrl.UpdateGpGamenName();
			return 1;
		} else {
		}
	} else {
	}
	return null;
}
end_body
member
public: FormGlyph child;
member
public: LabelGlyph proj_lab;
member
public: AlComboBox proj;
member
public: AlButton new_proj;
member
public: AlButton open_proj;
member
public: AlButton save_proj;
member
public: AlButton clear_proj;
member
public: AlButton exec_proj;
member
public: AlButton pkg_proj;
member
public: LabelGlyph gamen_kind_lab;
member
public: AlComboBox gamen_kind;
member
public: PatchGlyph gamen_select;
member
public: FormGlyph gb_select;
member
public: LabelGlyph gb_name_label;
member
public: LabelGlyph gb_name_field;
member
public: LabelGlyph gb_class_label;
member
public: LabelGlyph gb_class_field;
member
public: AlListBox gb_list;
member
public: AlButton new_gb;
member
public: AlButton open_gb;
member
public: AlButton delete_gb;
member
public: FormGlyph gp_select;
member
public: LabelGlyph gp_name_label;
member
public: LabelGlyph gp_name_field;
member
public: AlListBox gp_list;
member
public: AlButton new_gp;
member
public: AlButton open_gp;
member
public: AlButton delete_gp;
member
public: GbGpCtrl ctrl;
member
public: list projects;
member
public: void CreateClassList();
body
{
	_Append("integer");
	_Append("real");
	_Append("string");
	_Append("list");
	_Append("matrix");
	_Append("file");
	_Append("window");
	_Append("AlObject");
	_Append("Window");
	_Append("GUI");
	_Append("ScrollGlyph");
	_Append("FormGlyph");
	_Append("HBoxGlyph");
	_Append("VBoxGlyph");
	_Append("LineGlyph");
	_Append("RectangleGlyph");
	_Append("EllipseGlyph");
	_Append("PieGlyph");
	_Append("LabelGlyph");
	_Append("PathGlyph");
	_Append("GlyphEditor");
	_Append("GraphEditor");
	_Append("TableEditor");
	_Append("HierEditor");
	_Append("GUIbuilder");
	_Append("AlButton");
	_Append("AlVScrollBar");
	_Append("AlHScrollBar");
	_Append("AlListBox");
	_Append("AlComboBox");
	_Append("OcxGlyph");
	_Append("Integer");
	_Append("Real");
	_Append("String");
	_Append("List");
	_Append("Graph");
	_Append("Channel");
}
end_body
member
public: void _Append(string class_name);
body
{
	if (public_class) {
	} else {
		public_class = al_cons(null, null);
	}
	al_create_arc(public_class, class_name, null);
}
end_body
member
public: list public_class;
member
public: static GbGpPanel inst;
end_class
class GbGpCtrl
member
public: void PanelProjNew();
body
{
	var GbGpPanel panel;
	if (panel = GbGpPanel::inst) {
	} else {
		return;
	}
	var string proj_name;
	proj_name = panel.proj.label.text;
	if (proj_name == "") {
		al_print("Not found the project name.\n");
		return;
	} else {
	}
	var list proj_info;
	if (proj_info = GetProject(panel.projects, proj_name)) {
		al_print("Already exists the same name project.\n");
		return;
	} else {
	}
	var list dir_name;
	var string dir, name;
	dir_name = al_get_write_filename("GbGp Files (*.gpr)|*.gpr||", null);
	if (dir_name) {
	} else {
		return;
	}
	dir = dir_name.head;
	name = dir_name.tail.head;
	if (proj_info = GetProject(panel.projects, dir, name)) {
		al_print("The project whose filename is the same exists.\n");
		return;
	} else {
	}
	var file f;
	f = al_file_open(dir + "/" + name, "w");
	if (f) {
	} else {
		al_print("Can't open ");
		al_print(name);
		al_print(".\n");
		return;
	}
	proj_info = al_list5(proj_name, dir, name, al_cons(null, null), al_cons(null, null));
	al_create_arc(panel.projects, proj_info, null);
	al_create_arc(proj_info, al_cons(null, null), "$gb");
	al_create_arc(proj_info, al_cons(null, null), "$gp");
	panel.proj.child.AppendItem(proj_name);
	panel.proj.child.CurrentIndex(panel.proj.child.Count() - 1);
	al_file_write(f, "string", "End\n");
	al_file_write(f, "graph", proj_info);
	GUIbuilder::proj_info = proj_info;
}
end_body
member
public: void PanelProjOpen();
body
{
	var GbGpPanel panel;
	if (panel = GbGpPanel::inst) {
	} else {
		return;
	}
	var list dir_name;
	var string dir, name;
	dir_name = al_get_read_filename("GbGp Files (*.gpr)|*.gpr||", null);
	if (dir_name) {
	} else {
		return;
	}
	dir = dir_name.head;
	name = dir_name.tail.head;
	var list proj_info;
	if (proj_info = GetProject(panel.projects, dir, name)) {
		al_print("Already opend.\n");
		return;
	} else {
	}
	GbGpCtrl::_PanelProjOpen(dir, name);
}
end_body
member
public: void _PanelProjOpen(string dir, string name);
body
{
	var GbGpPanel panel;
	if (panel = GbGpPanel::inst) {
	} else {
		return;
	}
	var list proj_info;
	var file f;
	if (f = al_file_open(dir + "/" + name, "r")) {
	} else {
		al_print("Can't open ");
		al_print(name);
		al_print(".\n");
		return;
	}
	var string tag;
	loop {
		tag = al_file_read(f, "string");
		if (tag == "Class") {
			al_file_read(f, "class");
			continue;
		} else {
		}
		if (tag == "Member") {
			al_file_read(f, "member");
			continue;
		} else {
		}
		if (tag == "Body") {
			al_file_read(f, "body");
			continue;
		} else {
		}
		break;
	}
	al_gp("vtbl", null, null, null, null);
	if (proj_info = al_file_read(f, "graph")) {
	} else {
		al_print("There are errors in the file.\n");
		return;
	}
	proj_info.tail.head = dir;
	proj_info.tail.tail.head = name;
	var string proj_name;
	proj_name = proj_info.head;
	var list proj_info1;
	if (proj_info1 = GetProject(panel.projects, proj_name)) {
		al_print("Already exists the same name project.\n");
		return;
	} else {
	}
	var list itr, gbgp_info;
	var Glyph g;
	itr = al_dst_itr(al_dst_node(proj_info, "$gb"));
	loop {
		if (gbgp_info = al_next(itr)) {
		} else {
			break;
		}
		g = gbgp_info.tail.head.tail.tail.head;
		g.MakeSpaceIndex();
	}
	itr = al_dst_itr(al_dst_node(proj_info, "$gp"));
	loop {
		if (gbgp_info = al_next(itr)) {
		} else {
			break;
		}
		g = gbgp_info.tail.head.tail.tail.tail.head;
		g.MakeSpaceIndex();
	}
	al_create_arc(panel.projects, proj_info, null);
	panel.proj.child.AppendItem(proj_name);
	panel.proj.child.CurrentIndex(panel.proj.child.Count() - 1);
	panel.proj.label.text = proj_name;
	panel.proj.Damage();
	GUIbuilder::proj_info = proj_info;
	ListUpGbGp();
}
end_body
member
public: void PanelProjSave();
body
{
	var GbGpPanel panel;
	if (panel = GbGpPanel::inst) {
	} else {
		return;
	}
	var string proj_name;
	proj_name = panel.proj.label.text;
	if (proj_name == "") {
		al_print("Not found the project.\n");
		return;
	} else {
	}
	var list proj_info;
	if (proj_info = GetProject(panel.projects, proj_name)) {
	} else {
		al_print("This name project does not exists.\n");
		return;
	}
	var string dir, name;
	dir = proj_info.tail.head;
	name = proj_info.tail.tail.head;
	var file f;
	if (f = al_file_open(dir + "/" + name, "w")) {
	} else {
		al_print("Can't open ");
		al_print(name);
		al_print(".\n");
		return;
	}
	var list itr, cl;
	itr = al_dst_itr(proj_info.tail.tail.tail.head);
	loop {
		if (cl = al_next(itr)) {
		} else {
			break;
		}
		if (al_gp("runtime_class", cl, null, null, null)) {
		} else {
			al_remove(itr);
			continue;
		}
		al_file_write(f, "string", "Class\n");
		al_file_write(f, "class", cl);
	}
	itr = al_dst_itr(proj_info.tail.tail.tail.head);
	loop {
		if (cl = al_next(itr)) {
		} else {
			break;
		}
		al_file_write(f, "string", "Member\n");
		al_file_write(f, "member", cl);
	}
	itr = al_dst_itr(proj_info.tail.tail.tail.head);
	loop {
		if (cl = al_next(itr)) {
		} else {
			break;
		}
		al_file_write(f, "string", "Body\n");
		al_file_write(f, "body", cl);
	}
	al_file_write(f, "string", "End\n");
	var list gbgp_info;
	var Glyph g;
	itr = al_dst_itr(al_dst_node(proj_info, "$gb"));
	loop {
		if (gbgp_info = al_next(itr)) {
		} else {
			break;
		}
		g = gbgp_info.tail.head.tail.tail.head;
		g.ClearSpaceIndex();
	}
	itr = al_dst_itr(al_dst_node(proj_info, "$gp"));
	loop {
		if (gbgp_info = al_next(itr)) {
		} else {
			break;
		}
		g = gbgp_info.tail.head.tail.tail.tail.head;
		g.ClearSpaceIndex();
	}
	al_file_write(f, "graph", proj_info);
	itr = al_dst_itr(al_dst_node(proj_info, "$gb"));
	loop {
		if (gbgp_info = al_next(itr)) {
		} else {
			break;
		}
		g = gbgp_info.tail.head.tail.tail.head;
		g.MakeSpaceIndex();
	}
	itr = al_dst_itr(al_dst_node(proj_info, "$gp"));
	loop {
		if (gbgp_info = al_next(itr)) {
		} else {
			break;
		}
		g = gbgp_info.tail.head.tail.tail.tail.head;
		g.MakeSpaceIndex();
	}
}
end_body
member
public: void PanelProjClose();
body
{
	var GbGpPanel panel;
	if (panel = GbGpPanel::inst) {
	} else {
		al_print("can't find panel.\n");
		return;
	}
	var AlComboBox cmb;
	cmb = panel.proj;
	var string proj_name;
	proj_name = cmb.label.text;
	if (proj_name == "") {
		al_print("Not found the project name.\n");
		return;
	} else {
	}
	var list proj_info;
	if (proj_info = GetProject(panel.projects, proj_name)) {
	} else {
		al_print("This name project does not exists.\n");
		return;
	}
	var list itr, cl;
	itr = al_dst_itr(proj_info.tail.tail.tail.head);
	loop {
		if (cl = al_next(itr)) {
		} else {
			break;
		}
		al_gp("unregist_class", cl, 1, null, null);
	}
	al_gp("vtbl", null, null, null, null);
	al_gc(null);
	al_remove_from(panel.projects, proj_info, null);
	cmb.child.DeleteItem(cmb.child.CurrentIndex());
	cmb.label.text = "";
	cmb.Damage();
	panel.gamen_kind.label.text = "";
	panel.gamen_kind.label.Damage();
	panel.gamen_kind.child.vbox.selection = al_cons(null, null);
	panel.gb_name_field.text = "";
	panel.gb_name_field.Damage();
	panel.gb_class_field.text = "";
	panel.gb_class_field.Damage();
	panel.gb_list.ClearAllItems();
	panel.gb_list.Damage();
	panel.gp_name_field.text = "";
	panel.gp_name_field.Damage();
	panel.gp_list.ClearAllItems();
	panel.gp_list.Damage();
}
end_body
member
public: void PanelProjExec();
body
{
	var list class_func;
	var string class_name, func_name;
	if (class_func = al_dst_node(GUIbuilder::proj_info, "$exec")) {
	} else {
		al_print("Execution target is not setted.\n");
		return;
	}
	class_name = class_func.head;
	func_name = class_func.tail.head;
	al_gp("run", class_name, null, func_name, null);
}
end_body
member
public: void PanelProjPkg();
body
{
}
end_body
member
public: void PanelGbNew();
body
{
	var GbGpPanel panel;
	if (panel = GbGpPanel::inst) {
	} else {
		return;
	}
	var string proj_name;
	proj_name = panel.proj.label.text;
	if (proj_name == "") {
		al_print("Not found the project name.\n");
		return;
	} else {
	}
	var list proj_info;
	if (proj_info = GetProject(panel.projects, proj_name)) {
	} else {
		al_print("This name project does not exists.\n");
		return;
	}
	var string gamen_name, class_name;
	gamen_name = panel.gb_name_field.text;
	if (gamen_name == "") {
		al_print("Not found the screen name.\n");
		return;
	} else {
	}
	class_name = panel.gb_class_field.text;
	if (class_name == "") {
		al_print("Not found the class name.\n");
		return;
	} else {
	}
	if (GetGamen(proj_info, gamen_name, "$gb")) {
		al_print("The same name screen already exists.\n");
		return;
	} else {
	}
	if (al_gp("runtime_class", class_name, null, null, null)) {
		al_print("The same class name already exists.\n");
		return;
	} else {
	}
	var list save_cl, cl;
	save_cl = proj_info.tail.tail.tail.head;
	cl = proj_info.tail.tail.tail.tail.head;
	al_gp("regist_class", "GUIbuilder", class_name, null, null);
	al_gp("regist_vfunc", class_name, "list", "GbInit", null);
	al_create_arc(save_cl, class_name, null);
	al_create_arc(cl, class_name, null);
	var list rect_ref;
	var GUIbuilder editor;
	editor = OpenGUIbuilder(gamen_name, class_name, null);
	var list gamen_data_root;
	gamen_data_root = al_list3(editor.attachment, editor.parts, editor.child);
	var list gb, gb_info;
	gb = al_dst_node(proj_info, "$gb");
	gb_info = al_list3(gamen_name, gamen_data_root, class_name);
	al_create_arc(gb, gb_info, null);
	panel.gb_list.AppendItem(gamen_name);
	panel.gb_list.Damage();
	var list rect, rect_ref;
	al_create_arc(gb_info, rect_ref = al_list4(10, 10, 400, 400), "$wnd_rect");
	al_create_arc(editor, rect_ref, "$wnd_rect_ref");
}
end_body
member
public: void PanelGbOpen();
body
{
	var GbGpPanel panel;
	if (panel = GbGpPanel::inst) {
	} else {
		return;
	}
	var string proj_name;
	proj_name = panel.proj.label.text;
	if (proj_name == "") {
		al_print("Not found the project name.\n");
		return;
	} else {
	}
	var list proj_info;
	if (proj_info = GetProject(panel.projects, proj_name)) {
	} else {
		al_print("This name project does not exists.\n");
		return;
	}
	var string gamen_name, class_name;
	gamen_name = panel.gb_name_field.text;
	if (gamen_name == "") {
		al_print("Not found the screen name.\n");
		return;
	} else {
	}
	class_name = panel.gb_class_field.text;
	if (class_name == "") {
		al_print("Not found the class name.\n");
		return;
	} else {
	}
	var list gb_info;
	if (gb_info = GetGamen(proj_info, gamen_name, "$gb")) {
	} else {
		al_print("This screen name is not registered.\n");
		return;
	}
	if (gb_info.tail.tail.head == class_name) {
	} else {
		al_print("Class names are different between the same name screens.\n");
		return;
	}
	var list rect, rect_ref;
	if (rect = al_dst_node(gb_info, "$wnd_rect")) {
		rect_ref = rect;
	} else {
		al_create_arc(gb_info, rect_ref = al_cons(null, null), "$wnd_rect");
	}
	var GUIbuilder editor;
	editor = OpenGUIbuilder(gamen_name, class_name, rect);
	al_create_arc(editor, rect_ref, "$wnd_rect_ref");
	var list gamen_data_root;
	gamen_data_root = gb_info.tail.head;
	editor.attachment = gamen_data_root.head;
	editor.parts = gamen_data_root.tail.head;
	editor.child = gamen_data_root.tail.tail.head;
	var list itr;
	var Glyph g;
	var string name;
	itr = al_dst_itr(editor.parts);
	loop {
		if (g = al_next(itr)) {
		} else {
			break;
		}
		name = al_arc_a(itr);
		al_set_dst_node(editor, name, g);
	}
	editor.Damage();
}
end_body
member
public: void PanelGbDelete();
body
{
	var GbGpPanel panel;
	if (panel = GbGpPanel::inst) {
	} else {
		return;
	}
	var string proj_name;
	proj_name = panel.proj.label.text;
	if (proj_name == "") {
		al_print("Not found the project name.\n");
		return;
	} else {
	}
	var list proj_info;
	if (proj_info = GetProject(panel.projects, proj_name)) {
	} else {
		al_print("This name project does not exists.\n");
		return;
	}
	var string gamen_name, class_name;
	gamen_name = panel.gb_name_field.text;
	if (gamen_name == "") {
		al_print("Not found the screen name.\n");
		return;
	} else {
	}
	class_name = panel.gb_class_field.text;
	if (class_name == "") {
		al_print("Not found the class name.\n");
		return;
	} else {
	}
	var list gb_info;
	if (gb_info = GetGamen(proj_info, gamen_name, "$gb")) {
	} else {
		al_print("This screen name is not registered.\n");
		return;
	}
	if (gb_info.tail.tail.head == class_name) {
	} else {
		al_print("The class names are different between the same name screens.\n");
		return;
	}
	var list gb;
	if (gb = al_dst_node(proj_info, "$gb")) {
	} else {
		al_print("can't find 'gb'\n");
		return;
	}
	al_remove_from(gb, gb_info, null);
	panel.gb_name_field.text = "";
	panel.gb_name_field.Damage();
	panel.gb_class_field.text = "";
	panel.gb_class_field.Damage();
	ListUpGbGp();
}
end_body
member
public: void PanelGpNew();
body
{
	var GbGpPanel panel;
	if (panel = GbGpPanel::inst) {
	} else {
		return;
	}
	var string proj_name;
	proj_name = panel.proj.label.text;
	if (proj_name == "") {
		al_print("Not found the project name.\n");
		return;
	} else {
	}
	var list proj_info;
	if (proj_info = GetProject(panel.projects, proj_name)) {
	} else {
		al_print("This name project does not exists.\n");
		return;
	}
	var string gamen_name;
	gamen_name = panel.gp_name_field.text;
	if (gamen_name == "") {
		al_print("Not found the screen name.\n");
		return;
	} else {
	}
	if (GetGamen(proj_info, gamen_name, "$gp")) {
		al_print("The same name screen already exists.\n");
		return;
	} else {
	}
	var GpEditor editor;
	editor = OpenGpClass(gamen_name);
	var list gamen_data_root;
	gamen_data_root = al_list4(editor.labels, editor.arcs, editor.nodes, editor.child);
	var list gp, gp_info;
	gp = al_dst_node(proj_info, "$gp");
	gp_info = al_list3(gamen_name, gamen_data_root, "");
	al_create_arc(gp, gp_info, null);
	panel.gp_list.AppendItem(gamen_name);
	panel.gp_list.Damage();
}
end_body
member
public: void PanelGpOpen();
body
{
	var GbGpPanel panel;
	if (panel = GbGpPanel::inst) {
	} else {
		return;
	}
	var string proj_name;
	proj_name = panel.proj.label.text;
	if (proj_name == "") {
		al_print("Not found the project name.\n");
		return;
	} else {
	}
	var list proj_info;
	if (proj_info = GetProject(panel.projects, proj_name)) {
	} else {
		al_print("This name project does not exists.\n");
		return;
	}
	var string gamen_name;
	gamen_name = panel.gp_name_field.text;
	if (gamen_name == "") {
		al_print("Not found the screen name.\n");
		return;
	} else {
	}
	var list gp_info;
	if (gp_info = GetGamen(proj_info, gamen_name, "$gp")) {
	} else {
		al_print("This name screen is not registered.\n");
		return;
	}
	var GpEditor editor;
	editor = OpenGpClass(gamen_name);
	var list gamen_data_root;
	gamen_data_root = gp_info.tail.head;
	editor.labels = gamen_data_root.head;
	editor.arcs = gamen_data_root.tail.head;
	editor.nodes = gamen_data_root.tail.tail.head;
	editor.child = gamen_data_root.tail.tail.tail.head;
	editor.Damage();
}
end_body
member
public: void PanelGpDelete();
body
{
	var GbGpPanel panel;
	if (panel = GbGpPanel::inst) {
	} else {
		return;
	}
	var string proj_name;
	proj_name = panel.proj.label.text;
	if (proj_name == "") {
		al_print("Not found the project name.\n");
		return;
	} else {
	}
	var list proj_info;
	if (proj_info = GetProject(panel.projects, proj_name)) {
	} else {
		al_print("This name project does not exists.\n");
		return;
	}
	var string gamen_name;
	gamen_name = panel.gp_name_field.text;
	if (gamen_name == "") {
		al_print("Not found the screen name.\n");
		return;
	} else {
	}
	var list gp_info;
	if (gp_info = GetGamen(proj_info, gamen_name, "$gp")) {
	} else {
		al_print("This screen name is not registered.\n");
		return;
	}
	var list gp;
	if (gp = al_dst_node(proj_info, "$gp")) {
	} else {
		al_print("can't find 'gp'\n");
		return;
	}
	al_remove_from(gp, gp_info, null);
	panel.gp_name_field.text = "";
	panel.gp_name_field.Damage();
	ListUpGbGp();
}
end_body
member
public: static GUIbuilder OpenGUIbuilder(string title, string class_name, list rect);
body
{
	al_gp("vtbl", null, null, null, null);
	var GUIbuilder editor;
	editor = al_gp("new", class_name, null, null, null);
	editor.Create(0, 0, 1200, 1200);
	var GbCtrl ctrl;
	ctrl = new GbCtrl;
	ctrl.editor = editor;
	var AlMenu menu, edit_menu, mode_menu, align_menu;
	var AlMenu attach_menu, attach_menu1, attach_menu2, attach_menu3;
	var AlMenu place_menu, place_menu1, place_menu2, place_menu3;
	menu = new AlMenu;
	place_menu = new AlMenu;
	place_menu1 = new AlMenu;
	place_menu2 = new AlMenu;
	place_menu3 = new AlMenu;
	edit_menu = new AlMenu;
	mode_menu = new AlMenu;
	align_menu = new AlMenu;
	attach_menu = new AlMenu;
	attach_menu1 = new AlMenu;
	attach_menu2 = new AlMenu;
	attach_menu3 = new AlMenu;
	editor.custom_menu = new AlMenu;
	place_menu1.Append("Rectangle", (AlMenu)null, ctrl, GbCtrl::PutRectangle);
	place_menu1.Append("Ellipse", (AlMenu)null, ctrl, GbCtrl::PutEllipse);
	place_menu1.Append("Line", (AlMenu)null, ctrl, GbCtrl::PutLine);
	place_menu1.Append("ArrowLine", (AlMenu)null, ctrl, GbCtrl::PutArrowLine);
	place_menu1.Append("Path", (AlMenu)null, ctrl, GbCtrl::PutPath);
	place_menu1.Append("ArrowPath", (AlMenu)null, ctrl, GbCtrl::PutArrowPath);
	place_menu1.Append("Label", (AlMenu)null, ctrl, GbCtrl::PutLabel);
	place_menu1.Append("FoldedLabel", (AlMenu)null, ctrl, GbCtrl::PutMLabel);
	place_menu1.Append("FrameLabel", (AlMenu)null, ctrl, GbCtrl::PutFrameLabel);
	place_menu1.Append("StaticLabel", (AlMenu)null, ctrl, GbCtrl::PutStatic);
	place_menu1.Append("Image", (AlMenu)null, ctrl, GbCtrl::PutImage);
	place_menu2.Append("Button", (AlMenu)null, ctrl, GbCtrl::PutButton);
	place_menu2.Append("VerticalScrollBar", (AlMenu)null, ctrl, GbCtrl::PutVScrollBar);
	place_menu2.Append("HorizontalScrollBar", (AlMenu)null, ctrl, GbCtrl::PutHScrollBar);
	place_menu2.Append("ListBox", (AlMenu)null, ctrl, GbCtrl::PutListBox);
	place_menu2.Append("ComboBox", (AlMenu)null, ctrl, GbCtrl::PutComboBox);
	place_menu3.Append("PictureEditor", (AlMenu)null, ctrl, GbCtrl::PutPictEditor);
	place_menu3.Append("GraphEditor", (AlMenu)null, ctrl, GbCtrl::PutGraphEditor);
	place_menu3.Append("HierEditor", (AlMenu)null, ctrl, GbCtrl::PutHierEditor);
	place_menu3.Append("TableEditor", (AlMenu)null, ctrl, GbCtrl::PutTableEditor);
	place_menu3.Append("TextEditor", (AlMenu)null, ctrl, GbCtrl::PutTextEditor);
	place_menu.Append("Picture", place_menu1, (GUI)null, (GUIfunc)null);
	place_menu.Append("Control", place_menu2, (GUI)null, (GUIfunc)null);
	place_menu.Append("Editor", place_menu3, (GUI)null, (GUIfunc)null);
	place_menu.Append("OCX", (AlMenu)null, ctrl, GbCtrl::PutOcx);
	place_menu.Append("SubGUIScreen", (AlMenu)null, ctrl, GbCtrl::PutGUIbuilder);
	place_menu.Append("Custom", editor.custom_menu, (GUI)null, (GUIfunc)null);
	edit_menu.Append("Raise", (AlMenu)null, ctrl, GbCtrl::Raise);
	edit_menu.Append("Lower", (AlMenu)null, ctrl, GbCtrl::Lower);
	edit_menu.Append("Delete", (AlMenu)null, ctrl, GbCtrl::Delete);
	mode_menu.Append("Layout", (AlMenu)null, ctrl, GbCtrl::LayoutMode);
	mode_menu.Append("Execute", (AlMenu)null, ctrl, GbCtrl::ExecuteMode);
	align_menu.Append("Horizontal Top", (AlMenu)null, ctrl, GbCtrl::AlignHorizTop);
	align_menu.Append("Horizontal Center", (AlMenu)null, ctrl, GbCtrl::AlignHorizCenter);
	align_menu.Append("Horizontal Bottom", (AlMenu)null, ctrl, GbCtrl::AlignHorizBottom);
	align_menu.Append("Vertical Left", (AlMenu)null, ctrl, GbCtrl::AlignVertLeft);
	align_menu.Append("Vertical Center", (AlMenu)null, ctrl, GbCtrl::AlignVertCenter);
	align_menu.Append("Vertical Right", (AlMenu)null, ctrl, GbCtrl::AlignVertRight);
	align_menu.Append("Horizontal equally", (AlMenu)null, ctrl, GbCtrl::AlignWidth);
	align_menu.Append("Vertical equally", (AlMenu)null, ctrl, GbCtrl::AlignHeight);
	attach_menu1.Append("Left", (AlMenu)null, ctrl, GbCtrl::AttachLeft);
	attach_menu1.Append("Top", (AlMenu)null, ctrl, GbCtrl::AttachTop);
	attach_menu1.Append("Right", (AlMenu)null, ctrl, GbCtrl::AttachRight);
	attach_menu1.Append("Bottom", (AlMenu)null, ctrl, GbCtrl::AttachBottom);
	attach_menu2.Append("Left", (AlMenu)null, ctrl, GbCtrl::AttachOppositeLeft);
	attach_menu2.Append("Top", (AlMenu)null, ctrl, GbCtrl::AttachOppositeTop);
	attach_menu2.Append("Right", (AlMenu)null, ctrl, GbCtrl::AttachOppositeRight);
	attach_menu2.Append("Bottom", (AlMenu)null, ctrl, GbCtrl::AttachOppositeBottom);
	attach_menu3.Append("Left", (AlMenu)null, ctrl, GbCtrl::DetachLeft);
	attach_menu3.Append("Top", (AlMenu)null, ctrl, GbCtrl::DetachTop);
	attach_menu3.Append("Right", (AlMenu)null, ctrl, GbCtrl::DetachRight);
	attach_menu3.Append("Bottom", (AlMenu)null, ctrl, GbCtrl::DetachBottom);
	attach_menu.Append("Add/Change", attach_menu1, (GUI)null, (GUIfunc)null);
	attach_menu.Append("Opposite Add/Change", attach_menu2, (GUI)null, (GUIfunc)null);
	attach_menu.Append("Delete", attach_menu3, (GUI)null, (GUIfunc)null);
	menu.Append("Place", place_menu, (GUI)null, (GUIfunc)null);
	menu.Append("Source Generation", (AlMenu)null, ctrl, GbCtrl::GenerateCode);
	menu.Append("Edit", edit_menu, (GUI)null, (GUIfunc)null);
	menu.Append("Name", (AlMenu)null, ctrl, GbCtrl::ChangeName);
	menu.Append("X-Coordinate", (AlMenu)null, ctrl, GbCtrl::ChangeXCoord);
	menu.Append("Y-Coordinate", (AlMenu)null, ctrl, GbCtrl::ChangeYCoord);
	menu.Append("Attribute", (AlMenu)null, ctrl, GbCtrl::ChangeAttrib);
	menu.Append("Arrangement", align_menu, (GUI)null, (GUIfunc)null);
	menu.Append("Attachment", attach_menu, (GUI)null, (GUIfunc)null);
	menu.Append("Scroll Connect", (AlMenu)null, ctrl, GbCtrl::ConnectScroll);
	menu.Append("Mode", mode_menu, (GUI)null, (GUIfunc)null);
	menu.Append("Add Custom", (AlMenu)null, ctrl, GbCtrl::AppendCustom);
	var RightMenuGlyph menu_gl;
	menu_gl = new RightMenuGlyph;
	menu_gl.Resize(0, 0, 200, 200);
	menu_gl.Body(editor);
	menu_gl.menu = menu;
	var Window w;
	w = new Window;
	w.Create(menu_gl, null);
	w.SetTitle(title);
	if (rect) {
		w.SetRect(rect);
	} else {
	}
	editor.wnd = w.wnd;
	var string custom;
	if (custom = al_dst_node(GUIbuilder::proj_info, "$custom")) {
		var GbCtrl ctrl2;
		ctrl2 = al_gp("new", custom, null, null, null);
		ctrl2.editor = editor;
		ctrl2.UpdateCustom();
	} else {
	}
	return editor;
}
end_body
member
public: static GpEditor OpenGpClass(string title);
body
{
	var GpEditor editor;
	editor = new GpEditor;
	editor.Create(0, 0, 6000, 6000);
	editor.type = 1;
	var GpClassCtrl ctrl;
	ctrl = new GpClassCtrl;
	ctrl.editor = editor;
	var AlMenu menu, node_menu, edit_menu;
	menu = new AlMenu;
	node_menu = new AlMenu;
	edit_menu = new AlMenu;
	node_menu.Append("Existing Class", (AlMenu)null, ctrl, GbGp::PutClass);
	node_menu.Append("New Class", (AlMenu)null, ctrl, GpClassCtrl::NewClass);
	node_menu.Append("New Varibale", (AlMenu)null, ctrl, GpClassCtrl::MemberVar);
	edit_menu.Append("Delete", (AlMenu)null, ctrl, GbGp::Delete);
	menu.Append("Node", node_menu, (GUI)null, (GUIfunc)null);
	menu.Append("Edit", edit_menu, (GUI)null, (GUIfunc)null);
	var FormGlyph form;
	form = FormGlyph::FormWithScroll(menu, editor);
	form.status = Status::Execute;
	var Window w;
	w = new Window;
	w.Create(form, null);
	w.SetTitle(title);
	editor.wnd = ctrl.wnd = w.wnd;
	return editor;
}
end_body
member
public: static GpEditor OpenGpMember(string title, string class_name);
body
{
	var GpEditor editor;
	editor = new GpEditor;
	editor.Create(0, 0, 8000, 8000);
	editor.type = 2;
	editor.class_name = class_name;
	var GpMemberCtrl ctrl;
	ctrl = new GpMemberCtrl;
	ctrl.editor = editor;
	var AlMenu menu, node_menu, edit_menu, trans_menu;
	menu = new AlMenu;
	node_menu = new AlMenu;
	edit_menu = new AlMenu;
	trans_menu = new AlMenu;
	node_menu.Append("Object", (AlMenu)null, ctrl, GbGp::PutObject);
	node_menu.Append("New virtual function", (AlMenu)null, ctrl, GpMemberCtrl::PutVFunc);
	node_menu.Append("New static function", (AlMenu)null, ctrl, GpMemberCtrl::PutSFunc);
	node_menu.Append("Child Port", (AlMenu)null, ctrl, GpMemberCtrl::ChildPort);
	node_menu.Append("Insert Port", (AlMenu)null, ctrl, GpMemberCtrl::PortInsert);
	node_menu.Append("Append Port", (AlMenu)null, ctrl, GpMemberCtrl::PortAppend);
	edit_menu.Append("Delete", (AlMenu)null, ctrl, GbGp::Delete);
	trans_menu.Append("Normal", (AlMenu)null, ctrl, GpMemberCtrl::NormalTranslate);
	trans_menu.Append("Debug Level 1", (AlMenu)null, ctrl, GpMemberCtrl::Level1Translate);
	trans_menu.Append("Debug Level 2", (AlMenu)null, ctrl, GpMemberCtrl::Level2Translate);
	menu.Append("Node", node_menu, (GUI)null, (GUIfunc)null);
	menu.Append("Arc", (AlMenu)null, ctrl, GpMemberCtrl::ConnectArc);
	menu.Append("Edit", edit_menu, (GUI)null, (GUIfunc)null);
	menu.Append("Register Function", (AlMenu)null, ctrl, GpMemberCtrl::RegistFunc);
	menu.Append("Source Generation", trans_menu, (GUI)null, (GUIfunc)null);
	menu.Append("Use for Execution", (AlMenu)null, ctrl, GpMemberCtrl::Interpret);
	var FormGlyph form;
	form = FormGlyph::FormWithScroll(menu, editor);
	form.status = Status::Execute;
	var Window w;
	w = new Window;
	w.Create(form, null);
	w.SetTitle(title);
	editor.wnd = ctrl.wnd = w.wnd;
	return editor;
}
end_body
member
public: static GpEditor OpenGpBody(string title, string class_name);
body
{
	var GpEditor editor;
	editor = new GpEditor;
	editor.Create(0, 0, 10000, 10000);
	editor.type = 3;
	editor.class_name = class_name;
	var GpBodyCtrl ctrl;
	ctrl = new GpBodyCtrl;
	ctrl.editor = editor;
	var AlMenu menu, node_menu, view_menu, edit_menu, wizard_menu;
	var AlMenu object_menu, port_menu;
	menu = new AlMenu;
	node_menu = new AlMenu;
	object_menu = new AlMenu;
	port_menu = new AlMenu;
	view_menu = new AlMenu;
	edit_menu = new AlMenu;
	wizard_menu = new AlMenu;
	object_menu.Append("New", (AlMenu)null, ctrl, GbGp::PutObject);
	object_menu.Append("Other Self", (AlMenu)null, ctrl, GpBodyCtrl::CopyObject);
	object_menu.Append("Constant", (AlMenu)null, ctrl, GpBodyCtrl::Constant);
	object_menu.Append("this", (AlMenu)null, ctrl, GpBodyCtrl::This);
	port_menu.Append("Child Port", (AlMenu)null, ctrl, GpBodyCtrl::ChildPort);
	port_menu.Append("Insert", (AlMenu)null, ctrl, GpBodyCtrl::PortInsert);
	port_menu.Append("Append", (AlMenu)null, ctrl, GpBodyCtrl::PortAppend);
	node_menu.Append("Class", (AlMenu)null, ctrl, GbGp::PutClass);
	node_menu.Append("Object", object_menu, (GUI)null, (GUIfunc)null);
	node_menu.Append("Member Variable", (AlMenu)null, ctrl, GpBodyCtrl::MemberVar);
	node_menu.Append("Member Function", (AlMenu)null, ctrl, GpBodyCtrl::MemberFunc);
	node_menu.Append("System Function", (AlMenu)null, ctrl, GpBodyCtrl::PutSysFunc);
	node_menu.Append("Macro", (AlMenu)null, ctrl, GpBodyCtrl::PutMacro);
	node_menu.Append("Port", port_menu, (GUI)null, (GUIfunc)null);
	view_menu.Append("Zoom out", (AlMenu)null, ctrl, GpBodyCtrl::ViewLarge);
	view_menu.Append("Zoom in", (AlMenu)null, ctrl, GpBodyCtrl::ViewSmall);
	edit_menu.Append("Copy", (AlMenu)null, ctrl, GbGp::Copy);
	edit_menu.Append("Paste", (AlMenu)null, ctrl, GbGp::Paste);
	edit_menu.Append("Delete", (AlMenu)null, ctrl, GbGp::Delete);
	wizard_menu.Append("new", (AlMenu)null, ctrl, GpBodyCtrl::WizardNew);
	wizard_menu.Append("Window", (AlMenu)null, ctrl, GpBodyCtrl::WizardWindow);
	wizard_menu.Append("Callback", (AlMenu)null, ctrl, GpBodyCtrl::WizardCallback);
	menu.Append("Node", node_menu, (GUI)null, (GUIfunc)null);
	menu.Append("Arc", (AlMenu)null, ctrl, GpBodyCtrl::ConnectArc);
	menu.Append("Edit", edit_menu, (GUI)null, (GUIfunc)null);
	menu.Append("View", view_menu, (GUI)null, (GUIfunc)null);
	menu.Append("Wizard", wizard_menu, (GUI)null, (GUIfunc)null);
	var FormGlyph form;
	form = FormGlyph::FormWithScroll(menu, editor);
	form.status = Status::Execute;
	var Window w;
	w = new Window;
	w.Create(form, null);
	w.SetTitle(title);
	editor.wnd = ctrl.wnd = w.wnd;
	return editor;
}
end_body
member
public: list GetProject(list projects, string proj_name);
body
{
	var list itr, proj_info;
	itr = al_dst_itr(projects);
	loop {
		if (proj_info = al_next(itr)) {
		} else {
			return null;
		}
		if (proj_info.head == proj_name) {
			return proj_info;
		} else {
		}
	}
}
end_body
member
public: list GetProject(list projects, string dir, string name);
body
{
	var list itr, proj_info;
	itr = al_dst_itr(projects);
	loop {
		if (proj_info = al_next(itr)) {
		} else {
			return null;
		}
		if (proj_info.tail.head == dir && proj_info.tail.tail.head == name) {
			return proj_info;
		} else {
		}
	}
}
end_body
member
public: void ListUpGbGp();
body
{
	var GbGpPanel panel;
	if (panel = GbGpPanel::inst) {
	} else {
		return;
	}
	var string proj_name;
	proj_name = panel.proj.label.text;
	var list proj_info;
	if (proj_info = GetProject(panel.projects, proj_name)) {
	} else {
		al_print("Not found the project name.\n");
		return;
	}
	GUIbuilder::proj_info = proj_info;
	var list itr, gb, gb_info, gp, gp_info;
	var string s;
	panel.gb_list.ClearAllItems();
	panel.gp_list.ClearAllItems();
	gb = al_dst_node(proj_info, "$gb");
	itr = al_dst_itr(gb);
	loop {
		if (gb_info = al_next(itr)) {
		} else {
			break;
		}
		s = gb_info.head;
		panel.gb_list.AppendItem(s);
	}
	gp = al_dst_node(proj_info, "$gp");
	itr = al_dst_itr(gp);
	loop {
		if (gp_info = al_next(itr)) {
		} else {
			break;
		}
		s = gp_info.head;
		panel.gp_list.AppendItem(s);
	}
	panel.gb_list.Damage();
	panel.gp_list.Damage();
}
end_body
member
public: static list GetGamen(list proj_info, string gamen_name, string attr);
body
{
	var list itr, gb, gb_info;
	gb = al_dst_node(proj_info, attr);
	itr = al_dst_itr(gb);
	loop {
		if (gb_info = al_next(itr)) {
		} else {
			return null;
		}
		if (gb_info.head == gamen_name) {
			return gb_info;
		} else {
		}
	}
}
end_body
member
public: static list GetGbGamenByClass(list proj_info, string class_name);
body
{
	var list itr, gb, gb_info;
	gb = al_dst_node(proj_info, "$gb");
	itr = al_dst_itr(gb);
	loop {
		if (gb_info = al_next(itr)) {
		} else {
			return null;
		}
		if (gb_info.tail.tail.head == class_name) {
			return gb_info;
		} else {
		}
	}
}
end_body
member
public: void UpdateGbGamenName();
body
{
	var GbGpPanel panel;
	if (panel = GbGpPanel::inst) {
	} else {
		return;
	}
	var string proj_name;
	proj_name = panel.proj.label.text;
	if (proj_name == "") {
		al_print("Not found the project name.\n");
		return;
	} else {
	}
	var list proj_info;
	proj_info = GetProject(panel.projects, proj_name);
	if (proj_info) {
	} else {
		al_print("This name project does not exists.\n");
		return;
	}
	var integer index;
	var string gamen_name;
	index = panel.gb_list.CurrentIndex();
	gamen_name = panel.gb_list.GetItemText(index);
	var list gb_info;
	if (gb_info = GetGamen(proj_info, gamen_name, "$gb")) {
	} else {
		return;
	}
	panel.gb_name_field.text = gb_info.head;
	panel.gb_class_field.text = gb_info.tail.tail.head;
	panel.gb_name_field.Damage();
	panel.gb_class_field.Damage();
}
end_body
member
public: void UpdateGpGamenName();
body
{
	var GbGpPanel panel;
	if (panel = GbGpPanel::inst) {
	} else {
		return;
	}
	var string proj_name;
	proj_name = panel.proj.label.text;
	if (proj_name == "") {
		al_print("Not found the project name.\n");
		return;
	} else {
	}
	var list proj_info;
	proj_info = GetProject(panel.projects, proj_name);
	if (proj_info) {
	} else {
		al_print("This name project does not exists.\n");
		return;
	}
	var integer index;
	var string gamen_name;
	index = panel.gp_list.CurrentIndex();
	gamen_name = panel.gp_list.GetItemText(index);
	var list gp_info;
	if (gp_info = GetGamen(proj_info, gamen_name, "$gp")) {
	} else {
		return;
	}
	panel.gp_name_field.text = gp_info.head;
	panel.gp_name_field.Damage();
}
end_body
member
public: static GbGpCtrl inst;
end_class
class GbCtrl
member
public: GUIbuilder editor;
member
public: void PutRectangle();
body
{
	var RectangleGlyph g;
	g = new RectangleGlyph;
	g.Create(0, 0, 50, 50);
	editor.insert_object = g;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutEllipse();
body
{
	var EllipseGlyph g;
	g = new EllipseGlyph;
	g.Create(0, 0, 50, 50);
	editor.insert_object = g;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutLine();
body
{
	var LineGlyph g;
	g = new LineGlyph;
	g.Create(0, 0, 50, 50);
	editor.insert_object = g;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutArrowLine();
body
{
	var ArrowLine g;
	g = new ArrowLine;
	g.Create(0, 0, 50, 50);
	editor.insert_object = g;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutPath();
body
{
	var PathGlyph g;
	g = new PathGlyph;
	g.Create(0, 0, 50, 50);
	editor.insert_object = g;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutArrowPath();
body
{
	var ArrowPath g;
	g = new ArrowPath;
	g.Create(0, 0, 50, 50);
	editor.insert_object = g;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutLabel();
body
{
	var LabelGlyph g;
	g = new LabelGlyph;
	g.Create(0, 0, 80, 20, "Label");
	editor.insert_object = g;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutMLabel();
body
{
	var MLabel g;
	g = new MLabel;
	g.Create(0, 0, 80, 20, "Label");
	editor.insert_object = g;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutFrameLabel();
body
{
	var FrameLabel g;
	g = new FrameLabel;
	g.Create(0, 0, 80, 20, "Label");
	editor.insert_object = g;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutStatic();
body
{
	var LabelGlyph g;
	g = new StaticLabel;
	g.Create(0, 0, 80, 20, "Label");
	editor.insert_object = g;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutImage();
body
{
	var ImageGlyph g;
	g = new ImageGlyph;
	g.Create();
	var list dir_name;
	var string dir, name, dir2;
	loop {
		dir_name = al_get_read_filename("BMP Files (*.bmp)|*.bmp|GIF Files (*.gif)|*.gif|JPEG Files (*.jpg,*jpeg)|*.jpg;*.jpeg||", null);
		if (dir_name) {
		} else {
			return;
		}
		dir = dir_name.head;
		name = dir_name.tail.head;
		dir2 = GUIbuilder::GetPath();
		al_file_manip("copy", dir + "/" + name, dir2 + "/" + name);
		if (g.Load(dir2, name)) {
		} else {
			break;
		}
	}
	editor.insert_object = g;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutButton();
body
{
	var AlButton g;
	g = new AlButton;
	g.Create(0, 0, 80, 20, "Button");
	editor.insert_object = g;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutVScrollBar();
body
{
	var AlVScrollBar g;
	g = new AlVScrollBar;
	g.Create(0, 0, 20, 150);
	editor.insert_object = g;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutHScrollBar();
body
{
	var AlHScrollBar g;
	g = new AlHScrollBar;
	g.Create(0, 0, 150, 20);
	editor.insert_object = g;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutListBox();
body
{
	var AlListBox g;
	g = new AlListBox;
	g.Create(0, 0, 100, 100);
	editor.insert_object = g;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutComboBox();
body
{
	var AlComboBox g;
	g = new AlComboBox;
	g.Create(0, 0, 100, 100);
	editor.insert_object = g;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutPictEditor();
body
{
	var GlyphEditor ed;
	ed = new GlyphEditor;
	ed.Create(0, 0, 3000, 3000);
	al_create_arc(ed, GUIbuilder::GetEditorID(), "$editor_id");
	var ScrollGlyph scroll;
	scroll = new FrameScrollGlyph;
	scroll.Create();
	scroll.Resize(0, 0, 120, 120);
	scroll.Body(ed);
	editor.insert_object = scroll;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutGraphEditor();
body
{
	var GraphEditor ed;
	ed = new GraphEditor;
	ed.Create(0, 0, 3000, 3000);
	al_create_arc(ed, GUIbuilder::GetEditorID(), "$editor_id");
	var ScrollGlyph scroll;
	scroll = new FrameScrollGlyph;
	scroll.Create();
	scroll.Resize(0, 0, 120, 120);
	scroll.Body(ed);
	editor.insert_object = scroll;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutHierEditor();
body
{
	var HierEditor ed;
	ed = new HierEditor;
	ed.Create();
	ed.MakeSpaceIndex();
	al_create_arc(ed, GUIbuilder::GetEditorID(), "$editor_id");
	var ScrollGlyph scroll;
	scroll = new FrameScrollGlyph;
	scroll.Create();
	scroll.Resize(0, 0, 120, 120);
	scroll.Body(ed);
	editor.insert_object = scroll;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutTableEditor();
body
{
	var TableEditor ed;
	ed = new TableEditor;
	ed.Create(5, 10, 40, 20, "");
	ed.MakeSpaceIndex();
	al_create_arc(ed, GUIbuilder::GetEditorID(), "$editor_id");
	var ScrollGlyph scroll;
	scroll = new FrameScrollGlyph;
	scroll.Create();
	scroll.Resize(0, 0, 120, 120);
	scroll.Body(ed);
	editor.insert_object = scroll;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutTextEditor();
body
{
	var TextEditor ed;
	ed = new TextEditor;
	ed.Create();
	al_create_arc(ed, GUIbuilder::GetEditorID(), "$editor_id");
	var ScrollGlyph scroll;
	scroll = new FrameScrollGlyph;
	scroll.Create();
	scroll.Resize(0, 0, 120, 120);
	scroll.Body(ed);
	editor.insert_object = scroll;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutOcx();
body
{
	var AlDialog dialog;
	dialog = new AlDialog;
	var list progID_ls;
	var string progID, subStgID;
	progID_ls = al_ocx("ocx_list", null, null, null);
	progID_ls = al_misc("sort", progID_ls, al_list2(0, 0));
	if (dialog.ShowSelect("Select OCX", progID_ls)) {
		progID = dialog.text;
		if (progID && progID != "") {
		} else {
			return;
		}
	} else {
		return;
	}
	subStgID = GUIbuilder::GetOcxSubStgID();
	var OcxGlyph o;
	o = new OcxGlyph;
	o.Create(progID, 0, 0, 100, 100, (list)1, subStgID);
	o.Filename(GUIbuilder::GetPath() + "/ocx.dat");
	o.Mode(null);
	editor.insert_object = o;
	editor.status = Status::InsertObject;
}
end_body
member
public: void PutGUIbuilder();
body
{
	var GbGpPanel panel;
	var LabelGlyph label;
	var string proj_name;
	var list itr, proj_info1;
	if (panel = GbGpPanel::inst) {
	} else {
		return;
	}
	label = panel.proj.label;
	proj_name = label.text;
	itr = al_dst_itr(panel.projects);
	loop {
		if (proj_info1 = al_next(itr)) {
		} else {
			return;
		}
		if (proj_info1.head == proj_name) {
			break;
		} else {
		}
	}
	var string class_name;
	var AlDialog dialog;
	dialog = new AlDialog;
	if (dialog.ShowSelect("Select Class", proj_info1.tail.tail.tail.tail.head)) {
		class_name = dialog.text;
		if (class_name == "") {
			return;
		} else {
		}
	} else {
		return;
	}
	var GUIbuilder gb;
	gb = al_gp("new", class_name, null, null, null);
	if (gb = al_gp("new", class_name, null, null, null)) {
	} else {
		al_print("Can't create \"");
		al_print(class_name);
		al_print("\".\n");
		return;
	}
	var list rect;
	rect = gb.GbInit();
	if (gb.left && gb.top && gb.right && gb.bottom) {
	} else {
		al_print("Screen source codes not generated.\n");
		return;
	}
	gb.Resize(0, 0, (integer)rect.tail.tail.head, (integer)rect.tail.tail.tail.head);
	gb.status = Status::Layout;
	editor.insert_object = gb;
	editor.status = Status::InsertObject;
}
end_body
member
public: void Raise();
body
{
	editor.Raise();
}
end_body
member
public: void Lower();
body
{
	editor.Lower();
}
end_body
member
public: void Delete();
body
{
	editor.Delete();
}
end_body
member
public: void LayoutMode();
body
{
	editor.LayoutMode();
}
end_body
member
public: void ExecuteMode();
body
{
	editor.ExecuteMode();
}
end_body
member
public: void AlignHorizTop();
body
{
	editor.AlignHorizTop();
}
end_body
member
public: void AlignHorizCenter();
body
{
	editor.AlignHorizCenter();
}
end_body
member
public: void AlignHorizBottom();
body
{
	editor.AlignHorizBottom();
}
end_body
member
public: void AlignVertLeft();
body
{
	editor.AlignVertLeft();
}
end_body
member
public: void AlignVertCenter();
body
{
	editor.AlignVertCenter();
}
end_body
member
public: void AlignVertRight();
body
{
	editor.AlignVertRight();
}
end_body
member
public: void AlignWidth();
body
{
	editor.AlignWidth();
}
end_body
member
public: void AlignHeight();
body
{
	editor.AlignHeight();
}
end_body
member
public: void AttachLeft();
body
{
	editor.AttachLeft();
}
end_body
member
public: void AttachTop();
body
{
	editor.AttachTop();
}
end_body
member
public: void AttachRight();
body
{
	editor.AttachRight();
}
end_body
member
public: void AttachBottom();
body
{
	editor.AttachBottom();
}
end_body
member
public: void AttachOppositeLeft();
body
{
	editor.AttachOppositeLeft();
}
end_body
member
public: void AttachOppositeTop();
body
{
	editor.AttachOppositeTop();
}
end_body
member
public: void AttachOppositeRight();
body
{
	editor.AttachOppositeRight();
}
end_body
member
public: void AttachOppositeBottom();
body
{
	editor.AttachOppositeBottom();
}
end_body
member
public: void DetachLeft();
body
{
	editor.DetachLeft();
}
end_body
member
public: void DetachTop();
body
{
	editor.DetachTop();
}
end_body
member
public: void DetachRight();
body
{
	editor.DetachRight();
}
end_body
member
public: void DetachBottom();
body
{
	editor.DetachBottom();
}
end_body
member
public: void ConnectScroll();
body
{
	editor.ConnectScroll();
}
end_body
member
public: void GenerateCode();
body
{
	var list gb_info, rect;
	rect = al_dst_node(editor, "$wnd_rect_ref");
	gb_info = al_src_node(rect, "$wnd_rect");
	rect = al_get_window_rect(editor.wnd, 0);
	al_set_dst_node(gb_info, "$wnd_rect", rect);
	al_set_dst_node(editor, "$wnd_rect_ref", rect);
	editor.GenerateCode();
}
end_body
member
public: void ChangeName();
body
{
	editor.ChangeName();
}
end_body
member
public: void ChangeXCoord();
body
{
	editor.ChangeXCoord();
}
end_body
member
public: void ChangeYCoord();
body
{
	editor.ChangeYCoord();
}
end_body
member
public: void ChangeAttrib();
body
{
	editor.ChangeAttrib();
}
end_body
member
public: void AppendCustom();
body
{
	var string custom, ins_class;
	if (custom = al_dst_node(GUIbuilder::proj_info, "$custom")) {
	} else {
		var AlDialog dialog;
		dialog = new AlDialog;
		if (dialog.ShowInput("Input derived class from GbCtrl", "GbCustom")) {
		} else {
			return;
		}
		custom = dialog.text;
		if (custom == "") {
			return;
		} else {
		}
		if (al_gp("regist_class", "GbCtrl", custom, null, null)) {
			al_print(custom);
			al_print("may be corrision of class name.\n");
			return;
		} else {
		}
		if (al_gp("regist_vfunc", custom, "void", "UpdateCustom", null)) {
			al_print(custom);
			al_print("Can|'t register ::UpdateCustom().\n");
			return;
		} else {
		}
		pif = al_gp("pif_create", custom, null, "UpdateCustom", null);
		al_gp("pif_clear", pif, null, null, null);
		Insert("{");
		Insert("editor.custom_menu.Clear();");
		Insert("}");
		al_gp("pif_destroy", pif, null, null, null);
		al_create_arc(GUIbuilder::proj_info, custom, "$custom");
		var list save_cl;
		save_cl = GUIbuilder::proj_info.tail.tail.tail.head;
		al_create_arc(save_cl, custom, null);
	}
	var AlDialog dialog;
	dialog = new AlDialog;
	if (dialog.ShowSelect("Select Class", GUIbuilder::proj_info.tail.tail.tail.tail.head)) {
	} else {
		return;
	}
	ins_class = dialog.text;
	if (al_gp("regist_vfunc", custom, "void", "Put" + ins_class, null)) {
		al_print(ins_class);
		al_print(" is already registered as custom.\n");
		return;
	} else {
	}
	pif = al_gp("pif_create", custom, null, "Put" + ins_class, null);
	al_gp("pif_clear", pif, null, null, null);
	Insert("{");
	Insert("var " + ins_class + " g;");
	Insert("g = new " + ins_class + ";");
	Insert("// Insert creation codes here.");
	Insert("// g.Create(0, 0 , 100, 100);");
	Insert("editor.insert_object = g;");
	Insert("editor.status = Status::InsertObject;");
	Insert("}");
	al_gp("pif_destroy", pif, null, null, null);
	pif = al_gp("pif_create", custom, null, "UpdateCustom", null);
	var integer lno;
	al_gp("pif_reset", pif, -1, null, null);
	lno = al_gp("pif_lno", pif, null, null, null);
	al_gp("pif_reset", pif, lno - 2, null, null);
	Insert("editor.custom_menu.Append(\"" + ins_class + "\", (AlMenu)null, this, " + custom + "::Put" + ins_class + ");");
	al_gp("pif_destroy", pif, null, null, null);
	al_gp("vtbl", null, null, null, null);
	var GbCtrl ctrl;
	ctrl = al_gp("new", custom, null, null, null);
	ctrl.editor = editor;
	ctrl.UpdateCustom();
	al_print("Add codes into \n");
	al_print(custom);
	al_print("::Put");
	al_print(ins_class);
	al_print(".\n");
}
end_body
member
public: void UpdateCustom();
body
{
}
end_body
member
public: list pif;
member
public: void Insert(string s);
body
{
	al_gp("pif_insert", pif, s, null, null);
}
end_body
end_class
class GpClassCtrl
member
public: void NewClass();
body
{
	var string base_class, class_name;
	var list s_node, label, node;
	s_node = editor.GetSelectedNode();
	if (s_node && s_node.tail.head == GpEditor::ClassNode) {
	} else {
		al_print("Do it after selection of the class node.\n");
		return;
	}
	base_class = GraphEditor::LabelText(s_node, "$gp_class");
	if (base_class && base_class != "") {
	} else {
		al_print("Base class name is illegal.\n");
		return;
	}
	var AlDialog dialog;
	dialog = new AlDialog;
	if (dialog.ShowInput("Input New ClassName", "")) {
		class_name = dialog.text;
	} else {
		return;
	}
	if (class_name == "") {
		return;
	} else {
	}
	var GbGpPanel panel;
	var string proj_name;
	var list proj_info, save_cl, cl;
	if (panel = GbGpPanel::inst) {
	} else {
		al_print("panel not found\n");
		return;
	}
	proj_name = panel.proj.label.text;
	if (proj_name == "") {
		al_print("Not Found the project name.\n");
		return;
	} else {
	}
	if (proj_info = panel.ctrl.GetProject(panel.projects, proj_name)) {
	} else {
		al_print("This project name does not exists.\n");
		return;
	}
	save_cl = proj_info.tail.tail.tail.head;
	cl = proj_info.tail.tail.tail.tail.head;
	if (al_gp("regist_class", base_class, class_name, null, null)) {
		al_print("Can't register the new class.\n");
		return;
	} else {
	}
	if (IsSaveClass(save_cl, class_name)) {
	} else {
		al_create_arc(save_cl, class_name, null);
	}
	al_create_arc(cl, class_name, null);
	var TMGlyph info;
	var integer x, y;
	info = al_dst_node(s_node, "$geom");
	x = info.right + 20;
	y = info.bottom + 40;
	var Glyph g;
	g = new GpClass;
	g.Create();
	node = editor.CreateNode(g, x, y);
	node.tail = al_cons(GpEditor::ClassNode, null);
	info = al_dst_node(node, "$geom");
	label = editor.CreateLabel(node, class_name, info.left, info.bottom);
	al_create_arc(label, node, "$gp_class");
	var list arc;
	var PathGlyph path;
	arc = editor.CreateArc(s_node, node);
	arc.tail = al_cons(GpEditor::SubClassArc, null);
	info = al_dst_node(arc, "$geom");
	path = info.child;
	path.line_style = "Dot";
	arc.tail = al_cons(GpEditor::SubClassArc, null);
}
end_body
member
public: void MemberVar();
body
{
	var list class_node;
	var string class_name;
	class_node = editor.GetSelectedNode();
	if (class_node && class_node.tail.head == GpEditor::ClassNode) {
	} else {
		al_print("Do it after selection of the class node.\n");
		return;
	}
	class_name = GraphEditor::LabelText(class_node, "$gp_class");
	if (class_name && class_name != "") {
	} else {
		al_print("Class name is illegal.\n");
		return;
	}
	var string type;
	if (type = editor.SelectClass()) {
	} else {
		return;
	}
	var string v_name;
	var AlDialog dialog;
	dialog = new AlDialog;
	if (dialog.ShowInput("Input New Variable Name", "")) {
		v_name = dialog.text;
	} else {
		return;
	}
	if (v_name == "") {
		return;
	} else {
	}
	if (al_gp("regist_var", class_name, type, v_name, null)) {
		al_print("Can't register this name variable.\n");
		return;
	} else {
	}
	var list node, label;
	var TMGlyph info;
	var integer x, y;
	info = al_dst_node(class_node, "$geom");
	x = info.right + 40;
	y = (info.top + info.bottom) / 2;
	var Glyph g;
	g = new GpObject;
	g.Create();
	node = editor.CreateNode(g, x, y);
	node.tail = al_cons(GpEditor::ObjectNode, null);
	info = al_dst_node(node, "$geom");
	label = editor.CreateLabel(node, type, info.right, info.top);
	al_create_arc(label, node, "$gp_class");
	label = editor.CreateLabel(node, v_name, info.right, info.top + 12);
	al_create_arc(label, node, "$gp_id");
	var list arc;
	arc = editor.CreateArc(class_node, node);
	arc.tail = al_cons(GpEditor::MemberVarArc, null);
}
end_body
member
public: list IsSaveClass(list save_cl, string class_name);
body
{
	var list cl_node, base_cl_node;
	var list itr;
	cl_node = al_gp("runtime_class", class_name, null, null, null);
	loop {
		if (base_cl_node = al_src_node(cl_node, "$subclass")) {
		} else {
			return null;
		}
		itr = al_dst_itr(save_cl);
		loop {
			if (cl_node = al_next(itr)) {
			} else {
				break;
			}
			if (al_addr_eq(base_cl_node.head, cl_node)) {
				return 1;
			} else {
			}
		}
		cl_node = base_cl_node;
	}
}
end_body
end_class
class GpMemberCtrl
member
public: void PutVFunc();
body
{
	editor.status = GpEditor::PutVFunc;
}
end_body
member
public: void PutSFunc();
body
{
	editor.status = GpEditor::PutSFunc;
}
end_body
member
public: void ChildPort();
body
{
	var TMGlyph info;
	var list port, port0, node;
	if (info = al_dst_node(editor.selection, "$select")) {
	} else {
		return;
	}
	port0 = al_src_node(info, "$geom");
	if (port0 && port0.head == 1) {
	} else {
		return;
	}
	var integer t;
	t = port0.tail.head;
	port = editor.CreatePort(t, 1, "***", info.left, info.top);
	al_create_arc(port0, port, "$gp_port");
	node = GpEditor::Root(port);
	if (GpEditor::IsFuncNode(node) || GpEditor::IsMacroNode(node)) {
		editor.AdjustRootNode(node);
		return;
	} else {
	}
	info = al_dst_node(node, "$geom");
	if (editor.IsLeftPort(node)) {
		editor.AdjustLeftPort(node, info.left, info.top);
		return;
	} else {
	}
	if (editor.IsRightPort(node)) {
		editor.AdjustRightPort(node, info.left, info.top);
		return;
	} else {
	}
}
end_body
member
public: void PortInsert();
body
{
	var TMGlyph info;
	var list port, port1, port0, node;
	if (info = al_dst_node(editor.selection, "$select")) {
	} else {
		return;
	}
	port1 = al_src_node(info, "$geom");
	if (port1 && port1.head == 1) {
	} else {
		return;
	}
	var integer t;
	t = port1.tail.head;
	if (port0 = al_src_node(port1, "$gp_port")) {
	} else {
		return;
	}
	port = editor.CreatePort(t, 1, "***", info.left, info.top);
	al_insert_before(port0, port1, port, "$gp_port");
	node = GpEditor::Root(port);
	if (GpEditor::IsFuncNode(node)) {
		editor.AdjustRootNode(node);
		return;
	} else {
	}
	info = al_dst_node(node, "$geom");
	if (editor.IsLeftPort(node)) {
		editor.AdjustLeftPort(node, info.left, info.top);
		return;
	} else {
	}
	if (editor.IsRightPort(node)) {
		editor.AdjustRightPort(node, info.left, info.top);
		return;
	} else {
	}
}
end_body
member
public: void PortAppend();
body
{
	var TMGlyph info;
	var list port, port1, port0, node;
	if (info = al_dst_node(editor.selection, "$select")) {
	} else {
		return;
	}
	port1 = al_src_node(info, "$geom");
	if (port1 && port1.head == 1) {
	} else {
		return;
	}
	var integer t;
	t = port1.tail.head;
	if (port0 = al_src_node(port1, "$gp_port")) {
	} else {
		return;
	}
	port = editor.CreatePort(t, 1, "***", info.left, info.top);
	al_append_after(port0, port1, port, "$gp_port");
	node = GpEditor::Root(port);
	if (GpEditor::IsFuncNode(node)) {
		editor.AdjustRootNode(node);
		return;
	} else {
	}
	info = al_dst_node(node, "$geom");
	if (editor.IsLeftPort(node)) {
		editor.AdjustLeftPort(node, info.left, info.top);
		return;
	} else {
	}
	if (editor.IsRightPort(node)) {
		editor.AdjustRightPort(node, info.left, info.top);
		return;
	} else {
	}
}
end_body
member
public: void ConnectArc();
body
{
	editor.status = Status::InputArc;
}
end_body
member
public: void RegistFunc();
body
{
	var list node, port, port2, obj, arg_dcl, itr;
	var string func_type, func_name;
	if (node = editor.GetSelectedNode()) {
	} else {
		al_print("Do it after selection of the node.\n");
		return;
	}
	itr = al_dst_itr(node);
	loop {
		if (port = al_next_a(itr, "$gp_port")) {
		} else {
			func_type = "void";
			break;
		}
		if (port.tail.head == GpEditor::DataOut) {
		} else {
			continue;
		}
		if (obj = GpEditor::Dst(port)) {
		} else {
			continue;
		}
		if (obj.tail.head == GpEditor::ObjectNode) {
		} else {
			al_print("Return value not connected to the object node.\n");
			return;
		}
		if (func_type = GraphEditor::LabelText(obj, "$gp_class")) {
			break;
		} else {
			al_print("Return type is incorrect.\n");
			return;
		}
	}
	func_name = GraphEditor::LabelText(node, "$gp_func");
	if (func_name && func_name != "") {
	} else {
		al_print("Variable name is illegal.\n");
		return;
	}
	itr = al_dst_itr(node);
	loop {
		if (port = al_next_a(itr, "$gp_port")) {
		} else {
			al_print("Not found data input port.\n");
			return;
		}
		if (port.tail.head == GpEditor::DataIn) {
			break;
		} else {
		}
	}
	var string name, type;
	arg_dcl = null;
	itr = al_dst_itr(port);
	loop {
		if (port2 = al_next_a(itr, "$gp_port")) {
		} else {
			break;
		}
		name = GraphEditor::LabelText(port2, "$port_id");
		if (name && name != "") {
		} else {
			al_print("Port without the port name.\n");
			return;
		}
		if (obj = GpEditor::Src(port2, null, null)) {
		} else {
			al_print("Data input port without data input.\n");
			return;
		}
		if (obj.tail.head == GpEditor::ObjectNode) {
		} else {
			al_print("Argument ");
			al_print(name);
			al_print(" is not connected from th object node.\n");
			return;
		}
		if (type = GraphEditor::LabelText(obj, "$gp_class")) {
		} else {
			al_print("Input data type is illegal.\n");
			return;
		}
		arg_dcl = al_gp("add_to_arg_dcl", arg_dcl, type, name, null);
	}
	var integer err;
	err = -1;
	if (node.tail.head == GpEditor::SFuncNode) {
		err = al_gp("regist_sfunc", editor.class_name, func_type, func_name, arg_dcl);
	} else {
	}
	if (node.tail.head == GpEditor::VFuncNode) {
		err = al_gp("regist_vfunc", editor.class_name, func_type, func_name, arg_dcl);
	} else {
	}
	if (err == -1) {
		al_print("Select Function Node.\n");
	} else {
	}
	if (err == 1) {
		al_print("Fail to register function.\n");
	} else {
	}
	if (err == 2) {
		al_print("Alreay registered.\n");
	} else {
	}
}
end_body
member
public: void NormalTranslate();
body
{
	debug = debug2 = null;
	_Translate();
}
end_body
member
public: void Level1Translate();
body
{
	debug = null;
	debug2 = 1;
	_Translate();
}
end_body
member
public: void Level2Translate();
body
{
	debug = debug2 = 1;
	_Translate();
}
end_body
member
public: void _Translate();
body
{
	var list node;
	if (node = editor.GetSelectedNode()) {
	} else {
		al_print("Do it after selection of the node.\n");
		return;
	}
	var list class_node;
	if (class_node = al_src_node(editor, "$gp_macro")) {
	} else {
		al_print("can't find class name.\n");
		return;
	}
	var string class_name, func_name;
	class_name = GraphEditor::LabelText(class_node, "$gp_class");
	if (class_name) {
	} else {
		al_print("can't find class name.\n");
		return;
	}
	func_name = GraphEditor::LabelText(node, "$gp_func");
	if (func_name) {
	} else {
		al_print("can't find func name.\n");
		return;
	}
	var list itr, port, obj, arg_dcl;
	var string name, type;
	if (port = GpEditor::DataInPort(node)) {
	} else {
		al_print("Not found the data input node.\n");
		return;
	}
	itr = al_dst_itr(port);
	loop {
		if (port = al_next_a(itr, "$gp_port")) {
		} else {
			break;
		}
		name = GraphEditor::LabelText(port, "$port_id");
		if (name = GraphEditor::LabelText(port, "$port_id")) {
		} else {
			al_print("Port without the port name.\n");
			return;
		}
		if (obj = GpEditor::Src(port, null, null)) {
		} else {
			al_print("Port without the input data.\n");
			return;
		}
		if (obj.tail.head == GpEditor::ObjectNode) {
		} else {
			al_print("Argument ");
			al_print(name);
			al_print(" is not connected from the object node.\n");
			return;
		}
		if (type = GraphEditor::LabelText(obj, "$gp_class")) {
		} else {
			al_print("Input data type is incorrect.\n");
			return;
		}
		arg_dcl = al_gp("add_to_arg_dcl", arg_dcl, type, name, null);
	}
	var GpTranslator tr;
	tr = new GpTranslator;
	tr.debug = debug;
	tr.debug2 = debug2;
	var integer err;
	err = tr.GenerateCode(node, class_name, func_name, arg_dcl);
	if (err && err != 0) {
		al_print("An Error occurs while translation.\n");
	} else {
	}
}
end_body
member
public: list debug;
member
public: list debug2;
member
public: void Interpret();
body
{
	var list node;
	if (node = editor.GetSelectedNode()) {
	} else {
		al_print("Do it after selection of the node.\n");
		return;
	}
	var list class_node;
	if (class_node = al_src_node(editor, "$gp_macro")) {
	} else {
		al_print("can't find class name.\n");
		return;
	}
	var list class_func;
	var string class_name, func_name;
	class_name = GraphEditor::LabelText(class_node, "$gp_class");
	if (class_name) {
	} else {
		al_print("can't find class name.\n");
		return;
	}
	func_name = GraphEditor::LabelText(node, "$gp_func");
	if (func_name) {
	} else {
		al_print("can't find func name.\n");
		return;
	}
	class_func = al_list2(class_name, func_name);
	al_set_dst_node(GUIbuilder::proj_info, "$exec", class_func);
}
end_body
end_class
class GpBodyCtrl
member
public: void CopyObject();
body
{
	var list node, label;
	var TMGlyph info;
	var string class_name, obj_id;
	node = editor.GetSelectedNode();
	if (node && node.tail.head == GpEditor::ObjectNode) {
	} else {
		al_print("Do it after selection of the object node.\n");
		return;
	}
	class_name = GraphEditor::LabelText(node, "$gp_class");
	if (class_name) {
	} else {
		al_print("No types at the object node.\n");
		return;
	}
	obj_id = GraphEditor::LabelText(node, "$obj_id");
	if (obj_id) {
	} else {
		var AlDialog dialog;
		dialog = new AlDialog;
		if (dialog.ShowInput("Input Object ID", "")) {
		} else {
			return;
		}
		obj_id = dialog.text;
		var list obj_ids;
		if (obj_ids = al_dst_node(editor, "$obj_ids")) {
		} else {
			obj_ids = al_cons(null, null);
			al_create_arc(editor, obj_ids, "$obj_ids");
		}
		if (al_dst_node(obj_ids, obj_id)) {
			al_print("The same object id alreay used.\n");
			return;
		} else {
		}
		al_create_arc(obj_ids, al_cons(null, null), obj_id);
		info = al_dst_node(node, "$geom");
		label = editor.CreateLabel(node, obj_id, info.left, info.bottom + 12);
		al_create_arc(label, node, "$obj_id");
	}
	var integer x, y;
	info = al_dst_node(node, "$geom");
	x = info.right + 5;
	y = info.bottom;
	var Glyph g;
	g = new GpObject;
	g.Create();
	node = editor.CreateNode(g, x, y);
	node.tail = al_cons(GpEditor::ObjectNode, null);
	info = al_dst_node(node, "$geom");
	label = editor.CreateLabel(node, class_name, info.left, info.bottom);
	al_create_arc(label, node, "$gp_class");
	label = editor.CreateLabel(node, obj_id, info.left, info.bottom + 12);
	al_create_arc(label, node, "$obj_id");
}
end_body
member
public: void Constant();
body
{
	var list node, label;
	var string class_name;
	node = editor.GetSelectedNode();
	if (node && node.tail.head == GpEditor::ObjectNode) {
	} else {
		al_print("Do it after selection of the object node.\n");
		return;
	}
	class_name = GraphEditor::LabelText(node, "$gp_class");
	if (class_name) {
	} else {
		al_print("No type at the object node.\n");
		return;
	}
	var string contant;
	var AlDialog dialog;
	dialog = new AlDialog;
	if (dialog.ShowInput("Input Constant", "")) {
		contant = dialog.text;
	} else {
		return;
	}
	if (contant == "") {
		return;
	} else {
	}
	var TMGlyph info;
	info = al_dst_node(node, "$geom");
	label = editor.CreateLabel(node, contant, info.left, info.bottom + 12);
	al_set_dst_node(label, "$const", node);
}
end_body
member
public: void This();
body
{
	var list node;
	if (node = editor.GetSelectedNode()) {
	} else {
		al_print("Do it after selection of the node that is hint of position.\n");
		return;
	}
	var TMGlyph info;
	if (info = al_dst_node(node, "$geom")) {
	} else {
		al_print("can't find info of node.\n");
	}
	var integer x, y;
	x = info.right + 10;
	y = info.bottom + 10;
	var Glyph g;
	g = new GpObject;
	g.Create();
	var list label;
	node = editor.CreateNode(g, x, y);
	node.tail = al_cons(GpEditor::ObjectNode, null);
	info = al_dst_node(node, "$geom");
	label = editor.CreateLabel(node, editor.class_name, info.right, info.top);
	al_create_arc(label, node, "$gp_class");
	label = editor.CreateLabel(node, "this", info.right, info.top + 18);
	al_create_arc(label, node, "$const");
}
end_body
member
public: void MemberVar();
body
{
	var list node, rc;
	var string class_name;
	node = editor.GetSelectedNode();
	if (node && node.tail.head == GpEditor::ObjectNode) {
	} else {
		al_print("Do it after selection of the object node.\n");
		return;
	}
	class_name = GraphEditor::LabelText(node, "$gp_class");
	if (class_name) {
	} else {
		al_print("Node without the class name.\n");
		return;
	}
	rc = al_gp("runtime_class", class_name, null, null, null);
	if (rc) {
	} else {
		al_print(class_name);
		al_print(" is not the class name.\n");
		return;
	}
	var list m_ls, var_dcl, var_dcl2;
	var string m_str;
	m_ls = al_gp("var_list", class_name, null, null, null);
	var AlDialog dialog;
	dialog = new AlDialog;
	if (dialog.ShowSelect("Select Member Variable", m_ls)) {
		m_str = dialog.text;
	} else {
		return;
	}
	if (m_str == "") {
		return;
	} else {
	}
	if (var_dcl = al_dst_node(m_str, null)) {
	} else {
		al_print("can't find var_dcl.\n");
		return;
	}
	var string class_name2;
	class_name2 = al_gp("type_to_name", var_dcl.tail.head, null, null, null);
	var integer x, y;
	var TMGlyph info;
	info = al_dst_node(node, "$geom");
	x = info.right + 30;
	y = info.top - 10;
	var Glyph g;
	g = new GpObject;
	g.Create();
	var list obj_node, label, itr;
	obj_node = editor.CreateNode(g, x, y);
	obj_node.tail = al_cons(GpEditor::ObjectNode, null);
	info = al_dst_node(obj_node, "$geom");
	label = editor.CreateLabel(obj_node, class_name2, info.right, info.top);
	al_create_arc(label, obj_node, "$gp_class");
	loop {
		itr = al_dst_itr(rc);
		loop {
			if (var_dcl2 = al_next(itr)) {
			} else {
				break;
			}
			if (al_addr_eq(var_dcl2, var_dcl)) {
				break;
			} else {
			}
		}
		if (var_dcl2) {
			break;
		} else {
		}
		if (rc = al_src_node(rc, "$subclass")) {
		} else {
			al_print("can't find var_dcl.\n");
			return;
		}
	}
	var string var_name;
	var_name = al_arc_a(itr);
	var list arc;
	arc = editor.CreateArc(node, obj_node);
	arc.tail = al_cons(GpEditor::MemberVarArc, null);
	x = info.right;
	y = info.top + 18;
	label = editor.CreateLabel(arc, var_name, x, y);
	al_create_arc(label, obj_node, "$gp_member");
}
end_body
member
public: void MemberFunc();
body
{
	var list node, node2, rc;
	var string class_name;
	if (node = editor.GetSelectedNode()) {
	} else {
		al_print("Do it after selection of the node.\n");
		return;
	}
	var integer t;
	t = node.tail.head;
	if (t == GpEditor::ClassNode || t == GpEditor::ObjectNode) {
		node2 = node;
	} else {
		if (t == GpEditor::ExtDataIn) {
			node2 = GpEditor::Outside(node, null, null, null, null);
			if (node2 && node2.tail.head == GpEditor::ObjectNode) {
			} else {
				al_print("Do it after selection of the node.\n");
				return;
			}
		} else {
			al_print("Do it after selection of the node.\n");
			return;
		}
	}
	class_name = GraphEditor::LabelText(node2, "$gp_class");
	if (class_name) {
	} else {
		al_print("Node without the class name.\n");
		return;
	}
	rc = al_gp("runtime_class", class_name, null, null, null);
	if (rc) {
	} else {
		al_print(class_name);
		al_print(" is not the class name.\n");
		return;
	}
	var list m_ls, l, func_dcl, func_dcl2;
	var string m_str;
	var AlDialog dialog;
	dialog = new AlDialog;
	if (node2.tail.head == GpEditor::ClassNode) {
		m_ls = al_gp("sfunc_list", class_name, null, null, null);
		l = dialog.ShowSelect("Select static function", m_ls);
	} else {
		m_ls = al_gp("vfunc_list", class_name, null, null, null);
		l = dialog.ShowSelect("Select virtual function", m_ls);
	}
	if (l) {
		m_str = dialog.text;
	} else {
		return;
	}
	if (m_str == "") {
		return;
	} else {
	}
	if (func_dcl = al_dst_node(m_str, null)) {
	} else {
		al_print("can't find func_dcl.\n");
		return;
	}
	var integer x, y;
	var TMGlyph info;
	info = al_dst_node(node, "$geom");
	x = (info.left + info.right) / 2;
	y = info.top - 80;
	var Glyph g;
	g = new GpFunc;
	g.Create();
	var list func_node, label, itr;
	func_node = editor.CreateNode(g, x, y);
	if (node2.tail.head == GpEditor::ClassNode) {
		func_node.tail = al_cons(GpEditor::SFuncNode, null);
	} else {
		func_node.tail = al_cons(GpEditor::VFuncNode, null);
	}
	info = al_dst_node(func_node, "$geom");
	loop {
		itr = al_dst_itr(rc);
		loop {
			if (func_dcl2 = al_next(itr)) {
			} else {
				break;
			}
			if (al_addr_eq(func_dcl2, func_dcl)) {
				break;
			} else {
			}
		}
		if (func_dcl2) {
			break;
		} else {
		}
		rc = al_src_node(rc, "$subclass");
	}
	var string func_name;
	func_name = al_arc_a(itr);
	label = editor.CreateLabel(func_node, func_name, info.left, info.top - 12);
	al_create_arc(label, func_node, "$gp_func");
	var list ci_port, di_port, co_port, do_port, obj_port;
	ci_port = editor.CreatePort(GpEditor::CtrlIn, 1, "c-in", info.left, info.top);
	di_port = editor.CreatePort(GpEditor::DataIn, 1, "d-in", info.left, info.top);
	co_port = editor.CreatePort(GpEditor::CtrlOut, 1, "c-out", info.left, info.top);
	do_port = editor.CreatePort(GpEditor::DataOut, 1, "d-out", info.left, info.top);
	if (node.tail.head == GpEditor::ClassNode) {
		obj_port = editor.CreatePort(GpEditor::ObjPort, 2, "class", info.left, info.top);
	} else {
		obj_port = editor.CreatePort(GpEditor::ObjPort, 2, "obj", info.left, info.top);
	}
	al_create_arc(func_node, ci_port, "$gp_port");
	al_create_arc(func_node, di_port, "$gp_port");
	al_create_arc(func_node, co_port, "$gp_port");
	al_create_arc(func_node, do_port, "$gp_port");
	al_create_arc(func_node, obj_port, "$gp_port");
	var list arg_dcl, port;
	var string arg_name;
	arg_dcl = func_dcl.tail.tail.tail.head;
	loop {
		if (arg_dcl) {
		} else {
			break;
		}
		arg_name = arg_dcl.head;
		port = editor.CreatePort(GpEditor::DataIn, 1, arg_name, info.left, info.top);
		al_create_arc(di_port, port, "$gp_port");
		arg_dcl = arg_dcl.tail.tail;
	}
	var list arc;
	arc = editor.CreateArc(node, obj_port);
	arc.tail = al_cons(GpEditor::MemberFuncArc, null);
	editor.AdjustRootNode(func_node);
}
end_body
member
public: void PutSysFunc();
body
{
	editor.status = GpEditor::PutSysFunc;
}
end_body
member
public: void PutMacro();
body
{
	editor.status = GpEditor::PutMacro;
}
end_body
member
public: void ChildPort();
body
{
	var TMGlyph info;
	var list port, port0, node;
	if (info = al_dst_node(editor.selection, "$select")) {
	} else {
		return;
	}
	port0 = al_src_node(info, "$geom");
	if (port0 && port0.head == 1) {
	} else {
		return;
	}
	var integer t;
	t = port0.tail.head;
	port = editor.CreatePort(t, 1, "***", info.left, info.top);
	al_create_arc(port0, port, "$gp_port");
	node = GpEditor::Root(port);
	if (GpEditor::IsFuncNode(node) || GpEditor::IsMacroNode(node)) {
		editor.AdjustRootNode(node);
		return;
	} else {
	}
	info = al_dst_node(node, "$geom");
	if (editor.IsLeftPort(node)) {
		editor.AdjustLeftPort(node, info.top, info.right);
		return;
	} else {
	}
	if (editor.IsRightPort(node)) {
		editor.AdjustRightPort(node, info.top, info.left);
		return;
	} else {
	}
}
end_body
member
public: void PortInsert();
body
{
	var TMGlyph info;
	var list port, port1, port0, node;
	if (info = al_dst_node(editor.selection, "$select")) {
	} else {
		return;
	}
	port1 = al_src_node(info, "$geom");
	if (port1 && port1.head == 1) {
	} else {
		return;
	}
	var integer t;
	t = port1.tail.head;
	if (port0 = al_src_node(port1, "$gp_port")) {
	} else {
		return;
	}
	port = editor.CreatePort(t, 1, "***", info.left, info.top);
	al_insert_before(port0, port1, port, "$gp_port");
	node = GpEditor::Root(port);
	if (GpEditor::IsFuncNode(node)) {
		editor.AdjustRootNode(node);
		return;
	} else {
	}
	info = al_dst_node(node, "$geom");
	if (editor.IsLeftPort(node)) {
		editor.AdjustLeftPort(node, info.left, info.top);
		return;
	} else {
	}
	if (editor.IsRightPort(node)) {
		editor.AdjustRightPort(node, info.left, info.top);
		return;
	} else {
	}
}
end_body
member
public: void PortAppend();
body
{
	var TMGlyph info;
	var list port, port1, port0, node;
	if (info = al_dst_node(editor.selection, "$select")) {
	} else {
		return;
	}
	port1 = al_src_node(info, "$geom");
	if (port1 && port1.head == 1) {
	} else {
		return;
	}
	var integer t;
	t = port1.tail.head;
	if (port0 = al_src_node(port1, "$gp_port")) {
	} else {
		return;
	}
	port = editor.CreatePort(t, 1, "***", info.left, info.top);
	al_append_after(port0, port1, port, "$gp_port");
	node = GpEditor::Root(port);
	if (GpEditor::IsFuncNode(node)) {
		editor.AdjustRootNode(node);
		return;
	} else {
	}
	info = al_dst_node(node, "$geom");
	if (editor.IsLeftPort(node)) {
		editor.AdjustLeftPort(node, info.left, info.top);
		return;
	} else {
	}
	if (editor.IsRightPort(node)) {
		editor.AdjustRightPort(node, info.left, info.top);
		return;
	} else {
	}
}
end_body
member
public: void ConnectArc();
body
{
	editor.status = Status::InputArc;
}
end_body
member
public: void ViewLarge();
body
{
	var ScrollGlyph scroll;
	if (scroll = al_src_node(editor, "child")) {
	} else {
		al_print("can't find scroll.\n");
		return;
	}
	var matrix tm;
	if (tm = scroll.tm) {
	} else {
		scroll.tm = tm = al_unit_tm();
	}
	tm[0][0] = tm[0][0] * 1.25;
	tm[1][1] = tm[1][1] * 1.25;
	scroll.Body(editor);
	scroll.Damage();
}
end_body
member
public: void ViewSmall();
body
{
	var ScrollGlyph scroll;
	if (scroll = al_src_node(editor, "child")) {
	} else {
		al_print("can't find scroll.\n");
		return;
	}
	var matrix tm;
	if (tm = scroll.tm) {
	} else {
		scroll.tm = tm = al_unit_tm();
	}
	tm[0][0] = tm[0][0] * 0.8;
	tm[1][1] = tm[1][1] * 0.8;
	scroll.Body(editor);
	scroll.Damage();
}
end_body
member
public: void WizardNew();
body
{
	editor.status = GpEditor::PutWizardNew;
	al_message_text(wnd, "Please click where putting objects.");
}
end_body
member
public: void WizardWindow();
body
{
	editor.status = GpEditor::PutWizardWindow;
	al_message_text(wnd, "Please click where putting objects.");
}
end_body
member
public: void WizardCallback();
body
{
	var list itr;
	var TMGlyph info;
	var Glyph g;
	var list node, label;
	var list gb_node, btn_node, ocx_node;
	var string gb_class_name;
	itr = al_dst_itr(editor.selection);
	loop {
		if (info = al_next_a(itr, "$select")) {
		} else {
			break;
		}
		node = al_src_node(info, "$geom");
		label = GraphEditor::LabelText(node, "$gp_class");
		if (g = al_gp("new", label, null, null, null)) {
		} else {
			continue;
		}
		if (al_is_derived(g, runtime GUIbuilder)) {
			gb_node = node;
			gb_class_name = label;
			continue;
		} else {
		}
		if (al_is_derived(g, runtime AlButton)) {
			btn_node = node;
			continue;
		} else {
		}
		if (al_is_derived(g, runtime OcxGlyph)) {
			ocx_node = node;
			continue;
		} else {
		}
	}
	if (gb_node == null || btn_node == null && ocx_node == null) {
		al_print("Do it after selection of GUIBuilder, and AlButton or OcxGlyph.\n");
		return;
	} else {
	}
	if (btn_node && ocx_node) {
		al_print("Stop select both AlButton and OcxGlyph simultainiously.\n");
		return;
	} else {
	}
	var string event_name, func_name;
	var AlDialog dialog;
	dialog = new AlDialog;
	if (ocx_node) {
		if (dialog.ShowInput("Input Event Name", "eventName")) {
		} else {
			return;
		}
		event_name = dialog.text;
		if (event_name == "") {
			return;
		} else {
		}
	} else {
	}
	dialog = new AlDialog;
	if (dialog.ShowInput("Input Function Name", "callback")) {
	} else {
		return;
	}
	func_name = dialog.text;
	if (func_name == "") {
		return;
	} else {
	}
	var list arg_dcl;
	if (ocx_node) {
		arg_dcl = al_gp("add_to_arg_dcl", arg_dcl, "OcxGlyph", "o", null);
		arg_dcl = al_gp("add_to_arg_dcl", arg_dcl, "array", "arg", null);
	} else {
	}
	if (al_gp("regist_vfunc", gb_class_name, "void", func_name, arg_dcl)) {
		al_print("Can't register ");
		al_print(gb_class_name);
		al_print("::");
		al_print(func_name);
		al_print(".\n");
		return;
	} else {
	}
	var list const_node, cb_node, set_cb_node;
	var TMGlyph info;
	var Glyph g;
	var integer cb_x, cb_y, set_cb_x, set_cb_y;
	var integer const_x, const_y;
	if (btn_node) {
		info = al_dst_node(gb_node, "$geom");
		cb_x = info.left - 20;
		cb_y = info.top - 110;
		info = al_dst_node(btn_node, "$geom");
		set_cb_x = info.left + 70;
		set_cb_y = info.top - 110;
	} else {
	}
	if (ocx_node) {
		info = al_dst_node(gb_node, "$geom");
		const_x = info.left + 50;
		const_y = info.top - 170;
		cb_x = info.left - 20;
		cb_y = info.top - 110;
		info = al_dst_node(ocx_node, "$geom");
		set_cb_x = info.left + 70;
		set_cb_y = info.top - 110;
	} else {
	}
	if (ocx_node) {
		// create constant node
		g = new GpObject;
		g.Create();
		const_node = editor.CreateNode(g, const_x, const_y);
		const_node.tail = al_cons(GpEditor::ObjectNode, null);
		info = al_dst_node(const_node, "$geom");
		label = editor.CreateLabel(const_node, "string", info.left, info.bottom);
		al_create_arc(label, const_node, "$gp_class");
		label = editor.CreateLabel(const_node, "\"" + event_name + "\"", info.left, info.bottom + 12);
		al_set_dst_node(label, "$const", const_node);
	} else {
	}
	var list ci_port, co_port, di_port, do_port, obj_port, port, arc;
	// create callback function node
	g = new GpFunc;
	g.Create();
	cb_node = editor.CreateNode(g, cb_x, cb_y);
	cb_node.tail = al_cons(GpEditor::VFuncNode, null);
	info = al_dst_node(cb_node, "$geom");
	label = editor.CreateLabel(cb_node, func_name, info.left, info.top - 12);
	al_create_arc(label, cb_node, "$gp_func");
	ci_port = editor.CreatePort(GpEditor::CtrlIn, 1, "c-in", info.left, info.top);
	co_port = editor.CreatePort(GpEditor::CtrlOut, 1, "c-out", info.left, info.top);
	di_port = editor.CreatePort(GpEditor::DataIn, 1, "d-in", info.left, info.top);
	do_port = editor.CreatePort(GpEditor::DataOut, 1, "d-out", info.left, info.top);
	obj_port = editor.CreatePort(GpEditor::ObjPort, 2, "obj", info.left, info.top);
	al_create_arc(cb_node, ci_port, "$gp_port");
	al_create_arc(cb_node, co_port, "$gp_port");
	al_create_arc(cb_node, di_port, "$gp_port");
	al_create_arc(cb_node, do_port, "$gp_port");
	al_create_arc(cb_node, obj_port, "$gp_port");
	if (ocx_node) {
		port = editor.CreatePort(GpEditor::DataIn, 1, "o", info.left, info.top);
		al_create_arc(di_port, port, "$gp_port");
		port = editor.CreatePort(GpEditor::DataIn, 1, "arg", info.left, info.top);
		al_create_arc(di_port, port, "$gp_port");
	} else {
	}
	editor.AdjustRootNode(cb_node);
	arc = editor.CreateArc(gb_node, obj_port);
	arc.tail = al_cons(GpEditor::DataArc, null);
	// create callback set function node
	g = new GpFunc;
	g.Create();
	set_cb_node = editor.CreateNode(g, set_cb_x, set_cb_y);
	set_cb_node.tail = al_cons(GpEditor::VFuncNode, null);
	info = al_dst_node(set_cb_node, "$geom");
	label = editor.CreateLabel(set_cb_node, "SetCallback", info.left, info.top - 12);
	al_create_arc(label, set_cb_node, "$gp_func");
	ci_port = editor.CreatePort(GpEditor::CtrlIn, 1, "c-in", info.left, info.top);
	co_port = editor.CreatePort(GpEditor::CtrlOut, 1, "c-out", info.left, info.top);
	di_port = editor.CreatePort(GpEditor::DataIn, 1, "d-in", info.left, info.top);
	do_port = editor.CreatePort(GpEditor::DataOut, 1, "d-out", info.left, info.top);
	obj_port = editor.CreatePort(GpEditor::ObjPort, 2, "obj", info.left, info.top);
	al_create_arc(set_cb_node, ci_port, "$gp_port");
	al_create_arc(set_cb_node, co_port, "$gp_port");
	al_create_arc(set_cb_node, di_port, "$gp_port");
	al_create_arc(set_cb_node, do_port, "$gp_port");
	al_create_arc(set_cb_node, obj_port, "$gp_port");
	var list event_port, object_port, func_port;
	if (ocx_node) {
		event_port = editor.CreatePort(GpEditor::DataIn, 1, "eventName", info.left, info.top);
		al_create_arc(di_port, event_port, "$gp_port");
	} else {
	}
	object_port = editor.CreatePort(GpEditor::DataIn, 1, "obj", info.left, info.top);
	al_create_arc(di_port, object_port, "$gp_port");
	func_port = editor.CreatePort(GpEditor::DataIn, 1, "func", info.left, info.top);
	al_create_arc(di_port, func_port, "$gp_port");
	editor.AdjustRootNode(set_cb_node);
	if (btn_node) {
		arc = editor.CreateArc(btn_node, obj_port);
	} else {
		arc = editor.CreateArc(ocx_node, obj_port);
	}
	arc.tail = al_cons(GpEditor::DataArc, null);
	// create arc
	if (ocx_node) {
		arc = editor.CreateArc(const_node, event_port);
		arc.tail = al_cons(GpEditor::DataArc, null);
	} else {
	}
	arc = editor.CreateArc(gb_node, object_port);
	arc.tail = al_cons(GpEditor::DataArc, null);
	arc = editor.CreateArc(cb_node, func_port);
	arc.tail = al_cons(GpEditor::DataArc, null);
}
end_body
end_class
class GpTranslator
member
public: list GenerateCode(list fn, string class_name, string func_name, list arg_dcl);
body
{
	_func_node = fn;
	pif = al_gp("pif_create", class_name, null, func_name, arg_dcl);
	al_gp("pif_clear", pif, null, null, null);
	obj_id_tbl = al_cons(null, null);
	port_stack = null;
	gui_stack = null;
	err = null;
	if (pif) {
	} else {
		return 1;
	}
	loop {
		ins_str = "{";
		if (LineInsert()) {
			break;
		} else {
		}
		port = GpEditor::StartPort(_func_node);
		if (debug) {
			al_print("Unmark1\n");
		} else {
		}
		loop {
			if (UnmarkNext()) {
				break;
			} else {
			}
			err = UnmarkMain();
		}
		if (err) {
			break;
		} else {
		}
		id = status = 1;
		port = GpEditor::StartPort(_func_node);
		if (debug) {
			al_print("Mark\n");
		} else {
		}
		loop {
			if (MarkNext()) {
				break;
			} else {
			}
			err = MarkMain();
		}
		if (err) {
			break;
		} else {
		}
		id = 1;
		port = GpEditor::StartPort(_func_node);
		if (debug) {
			al_print("VarDcl\n");
		} else {
		}
		loop {
			if (VarDclNext()) {
				break;
			} else {
			}
			err = VarDclMain();
		}
		if (err) {
			break;
		} else {
		}
		id = prev_status = 1;
		port = GpEditor::StartPort(_func_node);
		if (debug) {
			al_print("Code\n");
		} else {
		}
		if (err = CodeBegin()) {
			break;
		} else {
		}
		func_node = null;
		loop {
			if (CodeNext()) {
				break;
			} else {
			}
			if (GpEditor::IsBranchNode(func_node)) {
				err = CodeBranch();
				continue;
			} else {
			}
			if (GpEditor::IsParaNode(func_node)) {
				err = CodePara();
				continue;
			} else {
			}
			err = CodeMain();
		}
		if (err) {
			break;
		} else {
		}
		if (err = CodeEnd()) {
			break;
		} else {
		}
		port = GpEditor::StartPort(_func_node);
		if (debug) {
			al_print("Unmark2\n");
		} else {
		}
		loop {
			if (UnmarkNext()) {
				break;
			} else {
			}
			err = UnmarkMain();
		}
		if (err) {
			break;
		} else {
		}
		ins_str = "}";
		err = LineInsert();
		break;
	}
	if (err) {
		al_gp("pif_destroy", pif, null, null, null);
		return err;
	} else {
	}
	return al_gp("pif_destroy", pif, null, null, null);
}
end_body
member
public: list MarkNext();
body
{
	if (err) {
		return err;
	} else {
	}
	if (port) {
	} else {
		return 0;
	}
	var list port2;
	loop {
		if (port2 = GpEditor::Dst(port)) {
			func_node = GpEditor::Root(port2);
			if (GpEditor::IsMacroNode(func_node)) {
				if (port2 = GpEditor::Inside(port2, null, (list)1, null, null)) {
				} else {
					return err = 1;
				}
				func_node = GpEditor::Root(port2);
			} else {
			}
			if (GpEditor::IsFuncNode(func_node)) {
			} else {
				return err = 1;
			}
			break;
		} else {
		}
		if (port_stack) {
			port = port_stack.head;
			port_stack = port_stack.tail;
			status = status + 1;
		} else {
			port = null;
			return 0;
		}
	}
	var list flag;
	if (GpEditor::Mark(func_node) == null) {
		if (GpEditor::IsMultiCtrlIn(func_node)) {
			status = status + 1;
			GpEditor::Mark(func_node, (list)al_list2(id, status));
		} else {
			GpEditor::Mark(func_node, (list)al_list2(id, status));
			if (GpEditor::IsBranchNode(func_node)) {
				status = status + 1;
			} else {
			}
		}
		if (debug) {
			TraceNode("FuncNode", func_node, "$gp_func");
		} else {
		}
		id = id + 1;
		if (GpEditor::IsBranchNode(func_node)) {
			var list port3;
			port2 = port_stack;
			port3 = GpEditor::IfFalsePort(func_node);
			loop {
				if (port2) {
				} else {
					break;
				}
				if (port2.head == port3) {
					break;
				} else {
				}
				port2 = port2.tail;
			}
			if (port2 == null) {
				if (port = GpEditor::IfFalsePort(func_node)) {
				} else {
					return err = 1;
				}
				port_stack = al_cons(port, port_stack);
				if (port = GpEditor::IfTruePort(func_node)) {
				} else {
					return err = 1;
				}
				flag = 1;
			} else {
				if (port = GpEditor::IfTruePort(func_node)) {
				} else {
					return err = 1;
				}
				flag = 1;
			}
		} else {
		}
		if (GpEditor::IsParaNode(func_node)) {
			if (port = GpEditor::ParaPort(func_node)) {
			} else {
				return err = 1;
			}
			port_stack = al_cons(port, port_stack);
			if (port = GpEditor::SeqPort(func_node)) {
			} else {
				return err = 1;
			}
			flag = 1;
		} else {
		}
	} else {
	}
	if (flag || port = GpEditor::CtrlOutPort(func_node)) {
	} else {
		return err = 1;
	}
	return null;
}
end_body
member
public: list MarkMain();
body
{
	var list prt, node, n;
	var list itr, gui;
	// data output port
	if (prt = GpEditor::DataOutPort(func_node)) {
		node = GpEditor::Dst(prt);
		if (node && GpEditor::IsObjectNode(node)) {
			loop {
				if (n = GpEditor::Src(node, (list)1, null)) {
				} else {
					break;
				}
				node = n;
			}
			if (GpEditor::Mark(node)) {
			} else {
				MarkNode(node);
			}
		} else {
		}
	} else {
	}
	// object port
	if (prt = GpEditor::GetObjPort(func_node)) {
		node = GpEditor::Src(prt, null, null);
		if (node && GpEditor::IsObjectNode(node)) {
			loop {
				if (n = GpEditor::Src(node, (list)1, null)) {
				} else {
					break;
				}
				node = n;
			}
			if (GpEditor::Mark(node)) {
			} else {
				MarkNode(node);
			}
		} else {
		}
	} else {
	}
	// data input port
	if (prt = GpEditor::DataInPort(func_node)) {
		itr = al_dst_itr(prt);
		loop {
			if (prt = al_prev_a(itr, "$gp_port")) {
			} else {
				break;
			}
			if (GpEditor::Src(prt, null, (list)1)) {
				continue;
			} else {
			}
			node = GpEditor::Src(prt, null, null);
			if (node && GpEditor::IsObjectNode(node)) {
				loop {
					if (n = GpEditor::Src(node, (list)1, null)) {
					} else {
						break;
					}
					node = n;
				}
				if (GpEditor::Mark(node)) {
				} else {
					MarkNode(node);
				}
			} else {
			}
		}
	} else {
	}
	return null;
}
end_body
member
public: void MarkNode(list node);
body
{
	var string obj_id;
	var list obj_info;
	if (obj_id = GraphEditor::LabelText(node, "$obj_id")) {
		if (obj_info = al_dst_node(obj_id_tbl, obj_id)) {
			GpEditor::Mark(node, (list)al_list2(obj_info.head, 1));
		} else {
			al_create_arc(obj_id_tbl, al_list2(id, null), obj_id);
			GpEditor::Mark(node, (list)al_list2(id, null));
			if (debug) {
				TraceNode("ObjectNode", node, "$gp_class");
			} else {
			}
			id = id + 1;
		}
	} else {
		GpEditor::Mark(node, (list)al_list2(id, null));
		if (debug) {
			TraceNode("ObjectNode", node, "$gp_class");
		} else {
		}
		id = id + 1;
	}
}
end_body
member
public: list UnmarkNext();
body
{
	if (err) {
		return err;
	} else {
	}
	if (port) {
	} else {
		return 0;
	}
	var list port2, mark;
	loop {
		if (port2 = GpEditor::Dst(port)) {
			func_node = GpEditor::Root(port2);
			if (GpEditor::IsMacroNode(func_node)) {
				if (port2 = GpEditor::Inside(port2, null, (list)1, null, null)) {
				} else {
					return err = 1;
				}
				func_node = GpEditor::Root(port2);
			} else {
			}
			if (GpEditor::IsFuncNode(func_node)) {
			} else {
				return err = 1;
			}
			break;
		} else {
		}
		if (port_stack) {
			port = port_stack.head;
			port_stack = port_stack.tail;
		} else {
			port = null;
			return 0;
		}
	}
	var list flag;
	if (mark = GpEditor::Mark(func_node)) {
		if (debug) {
			id = mark.head;
			TraceNode("FuncNode", func_node, "$gp_func");
		} else {
		}
		GpEditor::Mark(func_node, null);
		if (GpEditor::IsBranchNode(func_node)) {
			var list port3;
			port2 = port_stack;
			port3 = GpEditor::IfFalsePort(func_node);
			loop {
				if (port2) {
				} else {
					break;
				}
				if (port2.head == port3) {
					break;
				} else {
				}
				port2 = port2.tail;
			}
			if (port2 == null) {
				if (port = GpEditor::IfFalsePort(func_node)) {
				} else {
					return err = 1;
				}
				port_stack = al_cons(port, port_stack);
				if (port = GpEditor::IfTruePort(func_node)) {
				} else {
					return err = 1;
				}
				flag = 1;
			} else {
				if (port = GpEditor::IfTruePort(func_node)) {
				} else {
					return err = 1;
				}
				flag = 1;
			}
		} else {
		}
		if (GpEditor::IsParaNode(func_node)) {
			if (port = GpEditor::ParaPort(func_node)) {
			} else {
				return err = 1;
			}
			port_stack = al_cons(port, port_stack);
			if (port = GpEditor::SeqPort(func_node)) {
			} else {
				return err = 1;
			}
			flag = 1;
		} else {
		}
	} else {
	}
	if (flag || port = GpEditor::CtrlOutPort(func_node)) {
	} else {
		return err = 1;
	}
	return null;
}
end_body
member
public: list UnmarkMain();
body
{
	var list prt, node, n;
	var list itr, gui, mark;
	// data output port
	if (prt = GpEditor::DataOutPort(func_node)) {
		node = GpEditor::Dst(prt);
		if (node && GpEditor::IsObjectNode(node)) {
			loop {
				if (n = GpEditor::Src(node, (list)1, null)) {
				} else {
					break;
				}
				node = n;
			}
			if (mark = GpEditor::Mark(node)) {
				if (debug) {
					id = mark.head;
					TraceNode("ObjectNode", node, "$gp_class");
				} else {
				}
				GpEditor::Mark(node, null);
			} else {
			}
		} else {
		}
	} else {
	}
	// object port
	if (prt = GpEditor::GetObjPort(func_node)) {
		node = GpEditor::Src(prt, null, null);
		if (node && GpEditor::IsObjectNode(node)) {
			loop {
				if (n = GpEditor::Src(node, (list)1, null)) {
				} else {
					break;
				}
				node = n;
			}
			if (mark = GpEditor::Mark(node)) {
				if (debug) {
					id = mark.head;
					TraceNode("ObjectNode", node, "$gp_class");
				} else {
				}
				GpEditor::Mark(node, null);
			} else {
			}
		} else {
		}
	} else {
	}
	// data input port
	if (prt = GpEditor::DataInPort(func_node)) {
		itr = al_dst_itr(prt);
		loop {
			if (prt = al_prev_a(itr, "$gp_port")) {
			} else {
				break;
			}
			if (GpEditor::Src(prt, null, (list)1)) {
				continue;
			} else {
			}
			node = GpEditor::Src(prt, null, null);
			if (node && GpEditor::IsObjectNode(node)) {
				loop {
					if (n = GpEditor::Src(node, (list)1, null)) {
					} else {
						break;
					}
					node = n;
				}
				if (mark = GpEditor::Mark(node)) {
					if (debug) {
						id = mark.head;
						TraceNode("ObjectNode", node, "$gp_class");
					} else {
					}
					GpEditor::Mark(node, null);
				} else {
				}
			} else {
			}
		}
	} else {
	}
	return null;
}
end_body
member
public: list VarDclNext();
body
{
	if (err) {
		return err;
	} else {
	}
	if (port) {
	} else {
		return 0;
	}
	var list port2;
	loop {
		if (port2 = GpEditor::Dst(port)) {
			func_node = GpEditor::Root(port2);
			if (GpEditor::IsMacroNode(func_node)) {
				if (port2 = GpEditor::Inside(port2, null, (list)1, null, null)) {
				} else {
					return err = 1;
				}
				func_node = GpEditor::Root(port2);
			} else {
			}
			if (GpEditor::IsFuncNode(func_node)) {
			} else {
				return err = 1;
			}
			break;
		} else {
		}
		if (port_stack) {
			port = port_stack.head;
			port_stack = port_stack.tail;
		} else {
			port = null;
			return 0;
		}
	}
	var list flag;
	var integer num;
	num = GpEditor::Mark(func_node).head;
	if (num >= id) {
		if (debug) {
			TraceNode("FuncNode", func_node, "$gp_func");
		} else {
		}
		id = num + 1;
		if (GpEditor::IsBranchNode(func_node)) {
			var list port3;
			port2 = port_stack;
			port3 = GpEditor::IfFalsePort(func_node);
			loop {
				if (port2) {
				} else {
					break;
				}
				if (port3.head == port3) {
					break;
				} else {
				}
				port2 = port2.tail;
			}
			if (port2 == null) {
				if (port = GpEditor::IfFalsePort(func_node)) {
				} else {
					return err = 1;
				}
				port_stack = al_cons(port, port_stack);
				if (port = GpEditor::IfTruePort(func_node)) {
				} else {
					return err = 1;
				}
				flag = 1;
			} else {
				if (port = GpEditor::IfTruePort(func_node)) {
				} else {
					return err = 1;
				}
				flag = 1;
			}
		} else {
		}
		if (GpEditor::IsParaNode(func_node)) {
			if (port = GpEditor::SeqPort(func_node)) {
			} else {
				return err = 1;
			}
			flag = 1;
		} else {
		}
	} else {
	}
	if (flag || port = GpEditor::CtrlOutPort(func_node)) {
	} else {
		return err = 1;
	}
	return null;
}
end_body
member
public: list VarDclMain();
body
{
	var list prt, node, n, mark;
	var string type, name;
	var integer num;
	var list itr, gui;
	// data output port
	if (prt = GpEditor::DataOutPort(func_node)) {
		node = GpEditor::Dst(prt);
		if (node && GpEditor::IsObjectNode(node)) {
			loop {
				if (n = GpEditor::Src(node, (list)1, null)) {
				} else {
					break;
				}
				node = n;
			}
			if (type = GraphEditor::LabelText(node, "$gp_class")) {
			} else {
				return 1;
			}
			mark = GpEditor::Mark(node);
			num = mark.head;
			if (num >= id) {
				if (debug) {
					TraceNode("ObjectNode", node, "$gp_class");
				} else {
				}
				id = num + 1;
			} else {
			}
			if (mark.tail.head) {
			} else {
				mark.tail.head = 1;
				ins_str = "var " + type + " obj" + (string)num + ";";
				if (LineInsert()) {
					return err;
				} else {
				}
			}
		} else {
		}
	} else {
	}
	// object port
	if (prt = GpEditor::GetObjPort(func_node)) {
		node = GpEditor::Src(prt, null, null);
		if (node && GpEditor::IsObjectNode(node)) {
			loop {
				if (n = GpEditor::Src(node, (list)1, null)) {
				} else {
					break;
				}
				node = n;
			}
			if (type = GraphEditor::LabelText(node, "$gp_class")) {
			} else {
				return 1;
			}
			mark = GpEditor::Mark(node);
			num = mark.head;
			if (num >= id) {
				if (debug) {
					TraceNode("ObjectNode", node, "$gp_class");
				} else {
				}
				id = num + 1;
			} else {
			}
			if (mark.tail.head) {
			} else {
				mark.tail.head = 1;
				ins_str = "var " + type + " obj" + (string)num + ";";
				if (LineInsert()) {
					return err;
				} else {
				}
				if (GraphEditor::LabelText(node, "$const") == "this") {
					ins_str = "obj" + (string)num + " = this;";
					if (LineInsert()) {
						return err;
					} else {
					}
				} else {
				}
			}
		} else {
		}
	} else {
	}
	// data input port
	if (prt = GpEditor::DataInPort(func_node)) {
		itr = al_dst_itr(prt);
		loop {
			if (prt = al_prev_a(itr, "$gp_port")) {
			} else {
				break;
			}
			if (GpEditor::Src(prt, null, (list)1)) {
				continue;
			} else {
			}
			node = GpEditor::Src(prt, null, null);
			if (node && GpEditor::IsObjectNode(node)) {
				loop {
					if (n = GpEditor::Src(node, (list)1, null)) {
					} else {
						break;
					}
					node = n;
				}
				if (type = GraphEditor::LabelText(node, "$gp_class")) {
				} else {
					return 1;
				}
				mark = GpEditor::Mark(node);
				num = mark.head;
				if (num >= id) {
					if (debug) {
						TraceNode("ObjectNode", node, "$gp_class");
					} else {
					}
					id = num + 1;
				} else {
				}
				if (mark.tail.head) {
				} else {
					mark.tail.head = 1;
					ins_str = "var " + type + " obj" + (string)num + ";";
					if (LineInsert()) {
						return err;
					} else {
					}
					if (GraphEditor::LabelText(node, "$const") == "this") {
						ins_str = "obj" + (string)num + " = this;";
						if (LineInsert()) {
							return err;
						} else {
						}
					} else {
					}
				}
			} else {
			}
		}
	} else {
	}
	return null;
}
end_body
member
public: list CodeBegin();
body
{
	var list gui, itr, arc, node;
	var string name;
	var integer num_gui, num_var;
	ins_str = "var integer stat;";
	if (LineInsert()) {
		return err;
	} else {
	}
	ins_str = "stat = 1;";
	if (LineInsert()) {
		return err;
	} else {
	}
	ins_str = "loop {";
	if (LineInsert()) {
		return err;
	} else {
	}
	ins_str = "if (stat == 1) {";
	if (LineInsert()) {
		return err;
	} else {
	}
	return null;
}
end_body
member
public: list CodeNext();
body
{
	if (err) {
		return err;
	} else {
	}
	if (port) {
	} else {
		return 0;
	}
	var list port2, func_node2;
	loop {
		if (port2 = GpEditor::Dst(port)) {
			func_node2 = GpEditor::Root(port2);
			if (GpEditor::IsMacroNode(func_node2)) {
				if (port2 = GpEditor::Inside(port2, null, (list)1, null, null)) {
				} else {
					return err = 1;
				}
				func_node2 = GpEditor::Root(port2);
			} else {
			}
			if (GpEditor::IsFuncNode(func_node2)) {
			} else {
				return err = 1;
			}
			if (GpEditor::Mark(func_node2).tail.head >= prev_status) {
				func_node = func_node2;
				break;
			} else {
			}
		} else {
			ins_str = "break;";
			if (LineInsert()) {
				return err;
			} else {
			}
		}
		if (port_stack) {
			port = port_stack.head;
			port_stack = port_stack.tail;
		} else {
			port = null;
			return 0;
		}
	}
	var integer status1;
	status1 = GpEditor::Mark(func_node).tail.head;
	if (status1 != prev_status) {
		ins_str = "} else {";
		if (LineInsert()) {
			return err;
		} else {
		}
		ins_str = "}";
		if (LineInsert()) {
			return err;
		} else {
		}
		ins_str = "if (stat == " + (string)status1 + ") {";
		if (LineInsert()) {
			return err;
		} else {
		}
		prev_status = status1;
	} else {
	}
	var list flag;
	var integer num;
	num = GpEditor::Mark(func_node).head;
	if (num >= id) {
		if (debug) {
			TraceNode("FuncNode", func_node, "$gp_func");
		} else {
		}
		id = num + 1;
		if (GpEditor::IsBranchNode(func_node)) {
			var list port3;
			port2 = port_stack;
			port3 = GpEditor::IfFalsePort(func_node);
			loop {
				if (port2) {
				} else {
					break;
				}
				if (port2.head == port3) {
					break;
				} else {
				}
				port2 = port2.tail;
			}
			if (port2 == null) {
				if (port = GpEditor::IfFalsePort(func_node)) {
				} else {
					return err = 1;
				}
				port_stack = al_cons(port, port_stack);
				if (port = GpEditor::IfTruePort(func_node)) {
				} else {
					return err = 1;
				}
				flag = 1;
			} else {
				if (port = GpEditor::IfTruePort(func_node)) {
				} else {
					return err = 1;
				}
				flag = 1;
			}
		} else {
		}
		if (GpEditor::IsParaNode(func_node)) {
			if (port = GpEditor::SeqPort(func_node)) {
			} else {
				return err = 1;
			}
			flag = 1;
		} else {
		}
	} else {
	}
	if (flag || port = GpEditor::CtrlOutPort(func_node)) {
	} else {
		return err = 1;
	}
	if (port2 = GpEditor::Dst(port)) {
		func_node2 = GpEditor::Root(port2);
		if (GpEditor::IsMultiCtrlIn(func_node2)) {
			var integer status2;
			status2 = GpEditor::Mark(func_node2).tail.head;
			ins_str = "stat = " + (string)status2 + ";";
			if (LineInsert()) {
				return err;
			} else {
			}
		} else {
		}
	} else {
	}
	return null;
}
end_body
member
public: list CodeMain();
body
{
	var list prt, node, mem_var_stack, n;
	var list type, data, func, cls;
	var list itr, first, gui;
	var integer num;
	var string name;
	// data output port
	if (prt = GpEditor::DataOutPort(func_node)) {
		node = GpEditor::Dst(prt);
		if (node && GpEditor::IsObjectNode(node)) {
			loop {
				if (n = GpEditor::Src(node, (list)1, null)) {
				} else {
					break;
				}
				mem_var_stack = al_cons(node, mem_var_stack);
				node = n;
			}
			num = GpEditor::Mark(node).head;
			if (num >= id) {
				if (debug) {
					TraceNode("ObjectNode", node, "$gp_class");
				} else {
				}
				id = num + 1;
			} else {
			}
			if (mem_var_stack) {
				ins_str = "obj" + (string)num;
				loop {
					if (name = GraphEditor::LabelText(mem_var_stack.head, "$gp_member")) {
					} else {
						return 1;
					}
					ins_str = ins_str + "." + name;
					if (mem_var_stack = mem_var_stack.tail) {
					} else {
						break;
					}
				}
				ins_str = ins_str + " = ";
			} else {
				ins_str = "obj" + (string)num + " = ";
			}
		} else {
			ins_str = "";
		}
	} else {
	}
	// object port
	if (prt = GpEditor::GetObjPort(func_node)) {
	} else {
		return 1;
	}
	if (node = GpEditor::Src(prt, null, (list)1)) {
		if (name = GraphEditor::LabelText(node, "$port_id")) {
			ins_str = ins_str + name + ".";
		} else {
			return 1;
		}
	} else {
		node = GpEditor::Src(prt, null, null);
		if (node && GpEditor::IsObjectNode(node)) {
			loop {
				if (n = GpEditor::Src(node, (list)1, null)) {
				} else {
					break;
				}
				mem_var_stack = al_cons(node, mem_var_stack);
				node = n;
			}
			if (type = GraphEditor::LabelText(node, "$gp_class")) {
			} else {
				return 1;
			}
			num = GpEditor::Mark(node).head;
			if (num >= id) {
				if (debug) {
					TraceNode("ObjectNode", node, "$gp_class");
				} else {
				}
				id = num + 1;
			} else {
			}
			ins_str = ins_str + "obj" + (string)num + ".";
			if (mem_var_stack) {
				loop {
					if (name = GraphEditor::LabelText(mem_var_stack.head, "$gp_member")) {
					} else {
						return 1;
					}
					ins_str = ins_str + name + ".";
					if (mem_var_stack = mem_var_stack.tail) {
					} else {
						break;
					}
				}
			} else {
			}
		} else {
		}
		if (node && GpEditor::IsClassNode(node)) {
			if (type = GraphEditor::LabelText(node, "$gp_class")) {
			} else {
				return 1;
			}
			if (GpEditor::IsNewNode(func_node)) {
			} else {
				ins_str = ins_str + type + "::";
			}
		} else {
		}
	}
	// function node
	if (func = GraphEditor::LabelText(func_node, "$gp_func")) {
		if (GpEditor::IsNewNode(func_node)) {
			ins_str = ins_str + " new " + type + ";";
			return LineInsert();
		} else {
			ins_str = ins_str + func;
		}
	} else {
		return 1;
	}
	// data input port
	if (prt = GpEditor::DataInPort(func_node)) {
	} else {
		return 1;
	}
	ins_str = ins_str + "(";
	first = 1;
	itr = al_dst_itr(prt);
	loop {
		if (prt = al_next_a(itr, "$gp_port")) {
		} else {
			break;
		}
		if (first) {
			first = null;
		} else {
			ins_str = ins_str + ", ";
		}
		if (node = GpEditor::Src(prt, null, (list)1)) {
			if (name = GraphEditor::LabelText(node, "$gp_port")) {
				ins_str = ins_str + name;
			} else {
				return 1;
			}
			continue;
		} else {
		}
		if (node = GpEditor::Src(prt, null, null)) {
			if (GpEditor::IsObjectNode(node) || GpEditor::IsFuncNode(node)) {
			} else {
				return 1;
			}
		} else {
			ins_str = ins_str + "null";
			continue;
		}
		if (GpEditor::IsObjectNode(node)) {
			loop {
				if (n = GpEditor::Src(node, (list)1, null)) {
				} else {
					break;
				}
				mem_var_stack = al_cons(node, mem_var_stack);
				node = n;
			}
			if (type = GraphEditor::LabelText(node, "$gp_class")) {
			} else {
				return 1;
			}
			num = GpEditor::Mark(node).head;
			if (num >= id) {
				if (debug) {
					TraceNode("ObjectNode", node, "$gp_class");
				} else {
				}
				id = num + 1;
			} else {
			}
			if (data = GraphEditor::LabelText(node, "$const")) {
				ins_str = ins_str + data;
			} else {
				ins_str = ins_str + "obj" + (string)num;
			}
			if (mem_var_stack) {
				loop {
					if (name = GraphEditor::LabelText(mem_var_stack.head, "$gp_member")) {
					} else {
						return 1;
					}
					ins_str = ins_str + "." + name;
					if (mem_var_stack = mem_var_stack.tail) {
					} else {
						break;
					}
				}
			} else {
			}
		} else {
		}
		if (GpEditor::IsFuncNode(node)) {
			if (func = GraphEditor::LabelText(node, "$gp_func")) {
			} else {
				return 1;
			}
			if (prt = GpEditor::GetObjPort(node)) {
			} else {
				return 1;
			}
			if (prt = GpEditor::Src(prt, null, null)) {
			} else {
				return 1;
			}
			node = GpEditor::Root(prt);
			if (cls = GraphEditor::LabelText(node, "$gp_class")) {
			} else {
				return 1;
			}
			ins_str = ins_str + cls + "::" + func;
		} else {
		}
	}
	ins_str = ins_str + ");";
	return LineInsert();
}
end_body
member
public: list CodeEnd();
body
{
	ins_str = "}";
	if (LineInsert()) {
		return err;
	} else {
	}
	ins_str = "}";
	if (LineInsert()) {
		return err;
	} else {
	}
	return null;
}
end_body
member
public: list CodeBranch();
body
{
	var list prt, node, mem_var_stack, n, data, mark;
	var string name;
	var integer num;
	if (prt = GpEditor::DataInPort(func_node)) {
	} else {
		return 1;
	}
	if (prt = al_dst_node(prt, "$gp_port")) {
	} else {
		return 1;
	}
	if (node = GpEditor::Src(prt, null, (list)1)) {
		if (name = GraphEditor::LabelText(node, "$port_id")) {
		} else {
			return 1;
		}
		ins_str = "if (" + name + ") {";
		if (LineInsert()) {
			return err;
		} else {
		}
	} else {
		node = GpEditor::Src(prt, null, null);
		if (node && GpEditor::IsObjectNode(node)) {
			loop {
				if (n = GpEditor::Src(node, (list)1, null)) {
				} else {
					break;
				}
				mem_var_stack = al_cons(node, mem_var_stack);
				node = n;
			}
			if (data = GraphEditor::LabelText(node, "$const")) {
				ins_str = "if (" + data + ") {";
				if (LineInsert()) {
					return err;
				} else {
				}
				mark = GpEditor::Mark(node);
				num = mark.head;
			} else {
				mark = GpEditor::Mark(node);
				num = mark.head;
				ins_str = "if (obj" + (string)num;
				loop {
					if (mem_var_stack) {
					} else {
						break;
					}
					if (name = GraphEditor::LabelText(mem_var_stack.head, "$gp_member")) {
					} else {
						return 1;
					}
					ins_str = ins_str + "." + name;
					mem_var_stack = mem_var_stack.tail;
				}
				ins_str = ins_str + ") {";
				if (LineInsert()) {
					return err;
				} else {
				}
			}
			if (num >= id) {
			} else {
				id = num + 1;
			}
		} else {
			return 1;
		}
	}
	var integer status1, status2;
	if (prt = GpEditor::IfTruePort(func_node)) {
	} else {
		return 1;
	}
	if (prt = GpEditor::Dst(prt)) {
	} else {
		return 1;
	}
	if (node = GpEditor::Root(prt)) {
	} else {
		return 1;
	}
	if (mark = GpEditor::Mark(node)) {
	} else {
		return 1;
	}
	status1 = mark.tail.head;
	if (prt = GpEditor::IfFalsePort(func_node)) {
	} else {
		return 1;
	}
	if (prt = GpEditor::Dst(prt)) {
	} else {
		return 1;
	}
	if (node = GpEditor::Root(prt)) {
	} else {
		return 1;
	}
	if (mark = GpEditor::Mark(node)) {
	} else {
		return 1;
	}
	status2 = mark.tail.head;
	ins_str = "stat = " + (string)status1 + ";";
	if (LineInsert()) {
		return err;
	} else {
	}
	ins_str = "} else {";
	if (LineInsert()) {
		return err;
	} else {
	}
	ins_str = "stat = " + (string)status2 + ";";
	if (LineInsert()) {
		return err;
	} else {
	}
	ins_str = "}";
	if (LineInsert()) {
		return err;
	} else {
	}
	return null;
}
end_body
member
public: list CodePara();
body
{
	var list fn, prt, node, mem_var_stack, n;
	var list type, data, func, cls;
	var list itr, first, gui;
	var integer num;
	var string name;
	if (prt = GpEditor::ParaPort(func_node)) {
	} else {
		return 1;
	}
	if (prt = GpEditor::Dst(prt)) {
	} else {
		return 1;
	}
	fn = GpEditor::Root(prt);
	if (fn && GpEditor::IsFuncNode(fn)) {
	} else {
		return 1;
	}
	ins_str = "para ";
	// object port
	if (prt = GpEditor::GetObjPort(fn)) {
	} else {
		return 1;
	}
	if (node = GpEditor::Src(prt, null, (list)1)) {
		if (name = GraphEditor::LabelText(node, "$port_id")) {
			ins_str = ins_str + name + ".";
		} else {
			return 1;
		}
	} else {
		node = GpEditor::Src(prt, null, null);
		if (node && GpEditor::IsObjectNode(node)) {
			loop {
				if (n = GpEditor::Src(node, (list)1, null)) {
				} else {
					break;
				}
				mem_var_stack = al_cons(node, mem_var_stack);
				node = n;
			}
			if (type = GraphEditor::LabelText(node, "$gp_class")) {
			} else {
				return 1;
			}
			num = GpEditor::Mark(node).head;
			if (num >= id) {
				if (debug) {
					TraceNode("ObjectNode", node, "$gp_class");
				} else {
				}
				id = num + 1;
			} else {
			}
			ins_str = ins_str + "obj" + (string)num + ".";
			if (mem_var_stack) {
				loop {
					if (name = GraphEditor::LabelText(mem_var_stack.head, "$gp_member")) {
					} else {
						return 1;
					}
					ins_str = ins_str + name + ".";
					if (mem_var_stack = mem_var_stack.tail) {
					} else {
						break;
					}
				}
			} else {
			}
		} else {
		}
		if (node && GpEditor::IsClassNode(node)) {
			if (type = GraphEditor::LabelText(node, "$gp_class")) {
			} else {
				return 1;
			}
			ins_str = ins_str + type + "::";
		} else {
		}
	}
	// function node
	if (func = GraphEditor::LabelText(fn, "$gp_func")) {
		ins_str = ins_str + func;
	} else {
		return 1;
	}
	// data input port
	if (prt = GpEditor::DataInPort(fn)) {
	} else {
		return 1;
	}
	ins_str = ins_str + "(";
	first = 1;
	itr = al_dst_itr(prt);
	loop {
		if (prt = al_prev_a(itr, "$gp_port")) {
		} else {
			break;
		}
		if (first) {
			first = null;
		} else {
			ins_str = ins_str + ", ";
		}
		if (node = GpEditor::Src(prt, null, (list)1)) {
			if (name = GraphEditor::LabelText(node, "$gp_port")) {
				ins_str = ins_str + name;
			} else {
				return 1;
			}
			continue;
		} else {
		}
		node = GpEditor::Src(prt, null, null);
		if (node && GpEditor::IsObjectNode(node)) {
			loop {
				if (n = GpEditor::Src(node, (list)1, null)) {
				} else {
					break;
				}
				mem_var_stack = al_cons(node, mem_var_stack);
				node = n;
			}
			if (type = GraphEditor::LabelText(node, "$gp_class")) {
			} else {
				return 1;
			}
			num = GpEditor::Mark(node).head;
			if (num >= id) {
				if (debug) {
					TraceNode("ObjectNode", node, "$gp_class");
				} else {
				}
				id = num + 1;
			} else {
			}
			if (data = GraphEditor::LabelText(node, "$const")) {
				ins_str = ins_str + data;
			} else {
				ins_str = ins_str + "obj" + (string)num;
			}
			if (mem_var_stack) {
				loop {
					if (name = GraphEditor::LabelText(mem_var_stack.head, "$gp_member")) {
					} else {
						return 1;
					}
					ins_str = ins_str + "." + name;
					if (mem_var_stack = mem_var_stack.tail) {
					} else {
						break;
					}
				}
			} else {
			}
			continue;
		} else {
		}
		if (node && GpEditor::IsFuncNode(node)) {
			if (func = GraphEditor::LabelText(node, "$gp_func")) {
			} else {
				return 1;
			}
			if (prt = GpEditor::GetObjPort(node)) {
			} else {
				return 1;
			}
			if (prt = GpEditor::Src(prt, null, null)) {
			} else {
				return 1;
			}
			node = GpEditor::Root(prt);
			if (cls = GraphEditor::LabelText(node, "$gp_class")) {
			} else {
				return 1;
			}
			ins_str = ins_str + cls + "::" + func;
			continue;
		} else {
		}
		return 1;
	}
	ins_str = ins_str + ");";
	return LineInsert();
}
end_body
member
public: list _func_node;
member
public: list pif;
member
public: list port;
member
public: list func_node;
member
public: integer id;
member
public: integer status;
member
public: integer prev_status;
member
public: list obj_id_tbl;
member
public: list port_stack;
member
public: list gui_stack;
member
public: integer err;
member
public: list LineInsert();
body
{
	if (debug2) {
		al_print(ins_str);
		al_print("\n");
	} else {
	}
	err = al_gp("pif_insert", pif, ins_str, null, null);
	return err;
}
end_body
member
public: string ins_str;
member
public: list debug;
member
public: void TraceNode(string s, list node, string attr);
body
{
	al_print(s);
	al_print("\t");
	var string name;
	name = GraphEditor::LabelText(node, attr);
	al_print(name);
	al_print("\t");
	al_print(id);
	al_print("\n");
}
end_body
member
public: list debug2;
end_class
end_class
TEXT
Glyph
class OcxGlyph
member
public: void Create(string progID, integer l, integer t, integer r, integer b, list v, string subStgID);
body
{
	Glyph::Create();
	Glyph::Resize(l, t, r, b);
	_ocx = al_ocx("pre_create", progID, v, subStgID);
}
end_body
member
public: void MoveControl(window w);
body
{
	if (IsCreated()) {
	} else {
		if (al_ocx("create", _ocx, w, null)) {
			al_print("Fail to create control (");
			al_print(ProgID());
			al_print(").\n");
			return;
		} else {
		}
		if (Filename()) {
		} else {
			Filename(GUIbuilder::GetPath() + "/ocx.dat");
			al_ocx("load", _ocx, null, null);
		}
	}
	var list rect;
	rect = al_transform_rect(al_window_tm(w), left, top, right, bottom);
	al_ocx("place", _ocx, rect, null);
}
end_body
member
public: void Draw(window w);
body
{
	if (al_is_printing(w)) {
	} else {
		return;
	}
	al_push_pen(w, "Solid", 0, 0x0);
	al_push_brush(w, "Null", 0x0, null);
	if (al_misc("platform", null, null) == "windows") {
		al_push_font(w, "lr SVbN", 12, 0, 0x0);
	} else {
	}
	if (al_misc("platform", null, null) == "linux" || al_misc("platform", null, null) == "mac") {
		al_push_font(w, "-*-*-medium-r-normal-*-14-*-*-*-*-*-*-*,*", 12, 0, 0x0);
	} else {
	}
	al_rectangle(w, left, top, right, bottom);
	al_text(w, left + 2, top + 2, ProgID());
	al_pop_font(w);
	al_pop_brush(w);
	al_pop_pen(w);
}
end_body
member
public: void Destroy();
body
{
	if (_ocx) {
		al_ocx("unset_callback", _ocx, null, null);
		al_ocx("destroy", _ocx, null, null);
	} else {
	}
}
end_body
member
public: string ProgID();
body
{
	return al_ocx("progID", _ocx, null, null);
}
end_body
member
public: list RuntimeVisible();
body
{
	return al_ocx("runtime_invisible", _ocx, null, null) == null;
}
end_body
member
public: string SubStgID();
body
{
	return al_ocx("subStgID", _ocx, null, null);
}
end_body
member
public: list IsCreated();
body
{
	return al_ocx("is_created", _ocx, null, null);
}
end_body
member
public: void BringWindowToTop(list flag);
body
{
	if (_ocx) {
		al_ocx("z_order", _ocx, flag, null);
	} else {
	}
}
end_body
member
public: list Execute(Hit h);
body
{
	var integer type;
	type = h.event.head;
	if (type == Event::LeftDoubleClick) {
		if (status == Status::Layout && _Edit(h)) {
			return 1;
		} else {
		}
	} else {
	}
	return Glyph::Execute(h);
}
end_body
member
public: list _Edit(Hit h);
body
{
	al_ocx("prop_editor", _ocx, null, null);
	return 1;
}
end_body
member
public: string Filename();
body
{
	return al_ocx("get_filename", _ocx, null, null);
}
end_body
member
public: void Filename(string filename);
body
{
	al_ocx("set_filename", _ocx, filename, null);
}
end_body
member
public: void Mode(list mode);
body
{
	al_ocx("mode", _ocx, mode, null);
}
end_body
member
public: variant object();
body
{
	return al_ocx("object", _ocx, null, null);
}
end_body
member
public: void SetCallback(string eventName, GUI obj, GUIfunc func);
body
{
	al_ocx("callback", _ocx, eventName, al_list3(this, obj, func));
}
end_body
member
public: window Wnd();
body
{
	return al_ocx("wnd", _ocx, null, null);
}
end_body
member
public: list _ocx;
member
public: void public_func();
body
{
	IsCreated();
	object();
	SetCallback((string)null, (GUI)null, (GUIfunc)null);
	PreLoad();
	PostLoad();
}
end_body
member
public: list GbCode(list pif);
body
{
	var list err;
	err = (err || GbCode(pif, "{"));
	err = (err || GbCode(pif, "var OcxGlyph pp;"));
	err = (err || GbCode(pif, "pp = new OcxGlyph;"));
	var string s;
	s = "pp.Create(\"" + ProgID() + "\", ";
	s = s + GbGeom() + ", " + (RuntimeVisible() ? "(list)1" : "null");
	s = s + ", \"" + SubStgID() + "\");";
	err = (err || GbCode(pif, s));
	err = (err || GbCode(pif, "p = pp;"));
	err = (err || GbCode(pif, "}"));
}
end_body
member
public: RootGlyph root;
member
public: void PreLoad();
body
{
	loop {
		if (IsCreated()) {
			break;
		} else {
		}
		al_next_process();
	}
	object().SetRootClass(al_root_class());
	root = new RootGlyph;
	var window w;
	w = object().GetWnd();
	root.wnd = w;
	al_set_window_arg(w, "root", root);
	al_set_window_arg(w, "w", w);
	al_set_draw_proc(w, Window::DrawProc);
	al_set_event_proc(w, Window::EventProc);
}
end_body
member
public: void PostLoad();
body
{
	al_wnd_message(root.wnd, "size", null, null);
	al_redraw(root.wnd);
}
end_body
end_class
$END_BODY
