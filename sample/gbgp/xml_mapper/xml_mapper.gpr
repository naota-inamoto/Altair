Class
GUIbuilder
class DataMapperView
end_class
Class
GUI
class DataMapperApp
class FileUtility
class FileItr
end_class
class RevFileItr
end_class
end_class
class XmlUtility
class DtdLoader
class ExtendedDtdLoader
end_class
end_class
class DtdItr
end_class
class DtdHandler
end_class
end_class
end_class
Member
GUIbuilder
class DataMapperView
member
public: list GbInit();
member
public: void public_func();
member
public: AlHScrollBar hbar;
member
public: void public_var();
member
public: AlVScrollBar vbar;
member
public: FrameScrollGlyph view;
member
public: GraphEditor ed;
member
public: void Init();
member
public: void OpenDTD1();
member
public: void OpenDTD2();
member
public: void CreateDrawInfo(integer side, list dtd);
member
public: void DeleteDTD1();
member
public: void DeleteDTD2();
member
public: void SaveMapInfo();
member
public: void LoadMapInfo();
member
public: void GenerateMapInfo();
member
public: void SaveToCSV();
member
public: void LoadFromCSV();
member
public: list GetNodeFromPath(list dtd_info, string abs_xpath);
member
public: void Exit();
member
public: list map_info;
member
public: list dtd_info1;
member
public: list dtd_info2;
member
public: list mapping;
member
public: void Arc();
member
public: void Reconnect();
member
public: void Delete();
member
public: list GetSelectedNode();
member
public: void Fold();
member
public: void Expand();
member
public: void ExpandAll();
member
public: void ExpandRecursive();
member
public: static void set_trace();
member
public: static void unset_trace();
end_class
Member
GUI
class DataMapperApp
member
public: static void main();
member
public: void public_func();
member
public: list debug;
member
public: list debug2;
member
public: list debug3;
member
public: void xml_debug();
class FileUtility
member
public: static string tempFile();
member
public: static list readBinary(string filename);
member
public: static string readString(string filename);
member
public: static void writeBinary(string filename, list bin);
member
public: static void writeBinary(string filename, list bin, integer from, integer size);
member
public: static void writeBinary(string filename, string str);
member
public: static void appendBinary(string filename, list bin);
member
public: static void appendBinary(string filename, list bin, integer from, integer size);
member
public: static void appendBinary(string filename, string str);
member
public: static void writeString(string filename, string str);
member
public: static void appendString(string filename, string str);
member
public: static list readGraphData(string filename);
member
public: static void writeGraphData(string filename, list data);
member
public: static void remove(string dir);
member
public: static void makeReadOnly(string dir);
member
public: static void makeWritable(string dir);
class FileItr
member
public: void Reset(string root);
member
public: list Next();
member
public: list stack;
member
public: string root;
member
public: string path;
member
public: string name;
member
public: string abs_path;
member
public: list is_dir;
end_class
class RevFileItr
member
public: void Reset(string root);
member
public: list Next();
member
public: list stack;
member
public: string root;
member
public: string path;
member
public: string name;
member
public: string abs_path;
member
public: list is_dir;
end_class
end_class
class XmlUtility
member
public: static list loadDTD(string filename);
class DtdLoader
member
public: list read_entities(file in);
member
public: list apply_entities(file in, file out);
member
public: list entities;
member
public: list read_element(file in);
member
public: list elems;
member
public: list root_elem;
member
public: list elem_attr(file in);
member
public: list load_elem(file in);
member
public: list load_elem1(file in);
member
public: list load_elem2(file in);
member
public: list load_elem_tag(file in);
member
public: list load_elem_empty_any(file in);
member
public: list load_elem_data(file in);
member
public: list add_attr(list elem, file in);
member
public: list attr;
member
public: list load_attr_choice(file in);
member
public: void normalize();
member
public: list check_recursive(list elem, list tags);
member
public: list check_recursive(list ret, string tag);
member
public: list data_duplicate;
member
public: void error_log(string s);
member
public: void warning_log(string s);
member
public: void info_log(string s);
member
public: list log_level;
member
public: static void attach_content_validation_data(list dtd, string csv_filename);
member
public: static void get_node(list ret, list elem, string xpath);
class ExtendedDtdLoader
member
public: list read_element(file in);
member
public: list elem_attr(file in);
member
public: list add_attr(list elem, file in);
end_class
end_class
class DtdItr
member
public: void Reset(list node0);
member
public: list Next(list skip_flag);
member
public: list pop();
member
public: list stack;
member
public: list type;
member
public: list node;
member
public: list opt;
member
public: void ContinueRepetition();
member
public: void BreakRepetition();
member
public: list repetition_stack;
member
public: string abs_xpath;
member
public: string rel_xpath;
member
public: string attr;
member
public: string tag;
member
public: list xpath_stack;
member
public: void expand_recursive();
member
public: void mark(list elem);
member
public: void unmark(list elem);
member
public: list recursive_expanded;
member
public: string repetition_tag;
member
public: DtdHandler handler;
member
public: DtdItr Copy();
member
public: list stack_copy(list stack);
member
public: list repetition_stack_copy(list repetition_stack);
member
public: list getFieldList();
member
public: list getChildList();
member
public: DtdItr getChild(string xpath);
member
public: list getFieldList2();
member
public: list getChild2(string xpath);
member
public: list tag2;
member
public: list ns_stack;
member
public: list all_tag;
end_class
class DtdHandler
member
public: void startElement(string tag);
member
public: void endElement(string tag);
member
public: void setNamespace(string name);
end_class
end_class
end_class
Body
GUIbuilder
class DataMapperView
member
public: list GbInit();
body
{
    Create(0, 0, 1500, 1500);
    var Glyph p;
    var TMGlyph info;
    {
        var AlHScrollBar pp;
        pp = new AlHScrollBar;
        pp.Create(0, 0, 509, 18);
        pp.face_color = 12632256;
        pp.highlight_color = 16777215;
        pp.shadow_color = 8421504;
        pp.frame_color = 0;
        pp.text_color = 0;
        pp.text_bg_color = 12632256;
        p = pp;
    }
    p.status = Status::Execute;
    hbar = p;
    info = child.Append(p, 0, 333);
    Attach(info, FormGlyph::Left, 0, 0);
    Attach(info, FormGlyph::Right, 0, 18);
    Attach(info, FormGlyph::Bottom, 0, 0);
    Attach(info, FormGlyph::Top, 1, 18);
    {
        var AlVScrollBar pp;
        pp = new AlVScrollBar;
        pp.Create(0, 0, 18, 333);
        pp.face_color = 12632256;
        pp.highlight_color = 16777215;
        pp.shadow_color = 8421504;
        pp.frame_color = 0;
        pp.text_color = 0;
        pp.text_bg_color = 12632256;
        p = pp;
    }
    p.status = Status::Execute;
    vbar = p;
    info = child.Append(p, 509, 0);
    Attach(info, FormGlyph::Top, 0, 0);
    Attach(info, FormGlyph::Right, 0, 0);
    Attach(info, FormGlyph::Bottom, 0, 18);
    Attach(info, FormGlyph::Left, 1, 18);
    {
        var ScrollGlyph pp;
        pp = new FrameScrollGlyph;
        pp.Resize(0, 0, 509, 333);
        {
            var GraphEditor pp;
            pp = new GraphEditor;
            // ### pp.Create(0, 0, 3000, 3000);
            pp.Create(0, 0, 3000, 20000);
            var file f;
            if (f = al_file_open(GUIbuilder::GetPath() + "/ed1.dat", "r")) {
                // ### pp.Load(f);
                f = null;
            } else {
            }
            p = pp;
        }
        pp.Body(p);
        pp.status = Status::Execute;
        p = pp;
    }
    p.status = Status::Execute;
    view = p;
    info = child.Append(p, 0, 0);
    Attach(info, FormGlyph::Left, 0, 0);
    Attach(info, FormGlyph::Top, 0, 0);
    Attach(info, FormGlyph::Right, 0, 18);
    Attach(info, FormGlyph::Bottom, 0, 18);
    vbar.Connect(view);
    hbar.Connect(view);
    MakeSpaceIndex();
    return al_list4(64, 35, 539, 382);
}
end_body
member
public: void public_func();
body
{
    GbInit();
    Init();
}
end_body
member
public: AlHScrollBar hbar;
member
public: void public_var();
body
{
    hbar;
    vbar;
    view;
}
end_body
member
public: AlVScrollBar vbar;
member
public: FrameScrollGlyph view;
member
public: GraphEditor ed;
member
public: void Init();
body
{
    ed = view.child;
    var AlMenu menu_bar;
    var AlMenu file_menu, edit_menu;
    menu_bar = new AlMenu;
    file_menu = new AlMenu;
    edit_menu = new AlMenu;
    menu_bar.Append("File", file_menu);
    menu_bar.Append("Edit", edit_menu);
    file_menu.Append("OpenDTD1", this, DataMapperView::OpenDTD1);
    file_menu.Append("OpenDTD2", this, DataMapperView::OpenDTD2);
    file_menu.Append("Save", this, DataMapperView::SaveMapInfo);
    file_menu.Append("Load", this, DataMapperView::LoadMapInfo);
    file_menu.Append("SaveToCSV", this, DataMapperView::SaveToCSV);
    file_menu.Append("LoadFromCSV", this, DataMapperView::LoadFromCSV);
    file_menu.Append("Exit", this, DataMapperView::Exit);
    edit_menu.Append("Fold", this, DataMapperView::Fold);
    edit_menu.Append("Expand", this, DataMapperView::Expand);
    edit_menu.Append("ExpandAll", this, DataMapperView::ExpandAll);
    edit_menu.Append("ExpandRecursive", this, DataMapperView::ExpandRecursive);
    edit_menu.Append("Arc", this, DataMapperView::Arc);
    edit_menu.Append("Reconnect", this, DataMapperView::Reconnect);
    edit_menu.Append("Delete", this, DataMapperView::Delete);
    al_set_menu(wnd, menu_bar);
    al_set_title(wnd, "Data Mapper");
    al_move_window(wnd, 50, 50);
    al_resize_window(wnd, 900, 600);
    map_info = al_cons(null, null);
    al_set_dst_node(map_info, "mapping", mapping = al_cons(null, null));
}
end_body
member
public: void OpenDTD1();
body
{
    var list dir_name;
    var string filename;
    if (dir_name = al_get_read_filename("DTD file(*.dtd)|*.dtd||", null)) {
    } else {
        return;
    }
    filename = dir_name.head + "/" + dir_name.tail.head;
    var list dtd;
    try {
        dtd = XmlUtility::loadDTD(filename);
    } catch (AlException e) {
        var AlDialog dlg;
        dlg = new AlDialog;
        dlg.ShowChoose("error", (string)e.msg, "", "", "OK", "");
        return;
    }
    DeleteDTD1();
    dtd_info1 = al_cons(null, null);
    al_set_dst_node(dtd_info1, "dtd_filename", filename);
    al_set_dst_node(dtd_info1, "dtd_info", dtd);
    al_set_dst_node(map_info, "dtd_info1", dtd_info1);
    al_set_dst_node(map_info, "mapping", mapping = al_cons(null, null));
    CreateDrawInfo(1, dtd);
}
end_body
member
public: void OpenDTD2();
body
{
    var list dir_name;
    var string filename;
    if (dir_name = al_get_read_filename("DTD file(*.dtd)|*.dtd||", null)) {
    } else {
        return;
    }
    filename = dir_name.head + "/" + dir_name.tail.head;
    var list dtd;
    try {
        dtd = XmlUtility::loadDTD(filename);
    } catch (AlException e) {
        var AlDialog dlg;
        dlg = new AlDialog;
        dlg.ShowChoose("error", (string)e.msg, "", "", "OK", "");
        return;
    }
    DeleteDTD2();
    dtd_info2 = al_cons(null, null);
    al_set_dst_node(dtd_info2, "dtd_filename", filename);
    al_set_dst_node(dtd_info2, "dtd_info", dtd);
    al_set_dst_node(map_info, "dtd_info2", dtd_info2);
    al_set_dst_node(map_info, "mapping", mapping = al_cons(null, null));
    CreateDrawInfo(2, dtd);
}
end_body
member
public: void CreateDrawInfo(integer side, list dtd);
body
{
    var integer TAG, REPT_TAG, RECUR_TAG, ATTR, INDENT, HEIGHT;
    TAG = 0xc0ffc0;
    REPT_TAG = 0xffffc0;
    RECUR_TAG = 0xffc0c0;
    ATTR = 0xc0ffff;
    INDENT = 30;
    HEIGHT = 20;
    var integer x, y;
    if (side == 1) {
        x =  - INDENT;
        y = 20;
    } else {
        // side == 2
        x = 500 - INDENT;
        y = 20;
    }
    var DtdItr dtd_itr;
    var string type, tag;
    var list node, label, case_x, recursive;
    var integer xx, count, fold_x;
    dtd_itr = new DtdItr;
    dtd_itr.Reset(dtd);
    dtd_itr.all_tag = 1;
    loop {
        type = dtd_itr.Next((list)2);
        if (type == "end") {
            break;
        } else {
        }
        if (type == "end_choice") {
            case_x = case_x.tail;
            x = x - INDENT;
            continue;
        } else {
        }
        if (type == "end_case") {
            x = x - INDENT;
            continue;
        } else {
        }
        if (dtd_itr.node) {
        } else {
            continue;
        }
        if (type == "repetition") {
            var list ls, itr;
            ls = al_str_misc("split", dtd_itr.abs_xpath, '/');
            itr = al_dst_itr(ls);
            count = al_count(itr);
            if (dtd_itr.node.tail.head == "|") {
                continue;
            } else {
            }
            tag = al_prev(itr);
            xx = x + INDENT * count;
            if (fold_x) {
                if (xx - INDENT / 2 < fold_x) {
                    y = y + HEIGHT;
                    fold_x = null;
                } else {
                }
            } else {
            }
            var RectangleGlyph g;
            g = new RectangleGlyph;
            g.Create(0, 0, 180, 16);
            if (recursive = al_dst_node(dtd_itr.node, "$recursive") && recursive < 2) {
                g.fill_color = RECUR_TAG;
            } else {
                recursive = null;
                g.fill_color = REPT_TAG;
            }
            node = ed.CreateNode(g, xx, y);
            al_set_dst_node(node, "$path", dtd_itr.abs_xpath);
            al_set_dst_node(node, "$side", side);
            al_set_dst_node(node, "$recursive", recursive);
            al_create_arc(node, dtd_itr.node, "$map");
            label = ed.CreateLabel(node, tag + (string)dtd_itr.opt, xx, y);
            var TMGlyph tm_g;
            var integer l, t;
            tm_g = al_dst_node(label, "$geom");
            l = tm_g.left;
            t = tm_g.top;
            tm_g.Resize(l, t, l + 180, t + 16);
            ed.selection = al_cons(null, null);
            al_create_arc(ed.selection, tm_g, "$select");
            ed.Lower();
            ed.selection = al_cons(null, null);
            tm_g = al_dst_node(node, "$geom");
            al_create_arc(ed.selection, tm_g, "$select");
            ed.Lower();
            ed.selection = al_cons(null, null);
            if (al_dst_node(dtd_itr.node, "$fold")) {
                if (fold_x) {
                } else {
                    fold_x = xx;
                }
            } else {
                if (fold_x) {
                    if (xx - INDENT / 2 <= fold_x) {
                        y = y + HEIGHT;
                        fold_x = null;
                    } else {
                    }
                } else {
                    y = y + HEIGHT;
                }
            }
            continue;
        } else {
        }
        if (type == "choice") {
            x = x + INDENT;
            var list ls, itr;
            ls = al_str_misc("split", dtd_itr.abs_xpath, '/');
            itr = al_dst_itr(ls);
            count = al_count(itr);
            xx = x + INDENT * count;
            if (fold_x) {
                if (xx - INDENT / 2 < fold_x) {
                    y = y + HEIGHT;
                    fold_x = null;
                } else {
                }
            } else {
            }
            var RectangleGlyph g;
            g = new RectangleGlyph;
            g.Create(0, 0, 180, 16);
            node = ed.CreateNode(g, xx, y);
            al_set_dst_node(node, "$path", dtd_itr.abs_xpath);
            al_set_dst_node(node, "$side", side);
            al_set_dst_node(node, "$recursive", recursive);
            al_create_arc(node, dtd_itr.node, "$map");
            label = ed.CreateLabel(node, "switch" + (string)dtd_itr.opt, xx, y);
            var TMGlyph tm_g;
            var integer l, t;
            tm_g = al_dst_node(label, "$geom");
            l = tm_g.left;
            t = tm_g.top;
            tm_g.Resize(l, t, l + 180, t + 16);
            ed.selection = al_cons(null, null);
            al_create_arc(ed.selection, tm_g, "$select");
            ed.Lower();
            ed.selection = al_cons(null, null);
            tm_g = al_dst_node(node, "$geom");
            al_create_arc(ed.selection, tm_g, "$select");
            ed.Lower();
            ed.selection = al_cons(null, null);
            case_x = al_cons(xx, case_x);
            if (al_dst_node(dtd_itr.node, "$fold")) {
                if (fold_x) {
                } else {
                    fold_x = xx;
                }
            } else {
                if (fold_x) {
                    if (xx - INDENT / 2 <= fold_x) {
                        y = y + HEIGHT;
                        fold_x = null;
                    } else {
                    }
                } else {
                    y = y + HEIGHT;
                }
            }
            continue;
        } else {
        }
        if (type == "case") {
            xx = case_x.head + INDENT;
            if (fold_x) {
                if (xx - INDENT / 2 < fold_x) {
                    y = y + HEIGHT;
                    fold_x = null;
                } else {
                }
            } else {
            }
            var RectangleGlyph g;
            g = new RectangleGlyph;
            g.Create(0, 0, 180, 16);
            node = ed.CreateNode(g, xx, y);
            al_set_dst_node(node, "$side", side);
            al_create_arc(node, dtd_itr.node, "$map");
            label = ed.CreateLabel(node, "case", xx, y);
            var TMGlyph tm_g;
            var integer l, t;
            tm_g = al_dst_node(label, "$geom");
            l = tm_g.left;
            t = tm_g.top;
            tm_g.Resize(l, t, l + 180, t + 16);
            ed.selection = al_cons(null, null);
            al_create_arc(ed.selection, tm_g, "$select");
            ed.Lower();
            ed.selection = al_cons(null, null);
            tm_g = al_dst_node(node, "$geom");
            al_create_arc(ed.selection, tm_g, "$select");
            ed.Lower();
            ed.selection = al_cons(null, null);
            if (al_dst_node(dtd_itr.node, "$fold")) {
                if (fold_x) {
                } else {
                    fold_x = xx;
                }
            } else {
                if (fold_x) {
                    if (xx - INDENT / 2 <= fold_x) {
                        y = y + HEIGHT;
                        fold_x = null;
                    } else {
                    }
                } else {
                    y = y + HEIGHT;
                }
            }
            x = x + INDENT;
            continue;
        } else {
        }
        if (type == "attr") {
            var list ls, itr;
            ls = al_str_misc("split", dtd_itr.abs_xpath, '/');
            itr = al_dst_itr(ls);
            count = al_count(itr);
            xx = x + INDENT * count + INDENT;
            if (fold_x) {
                if (xx - INDENT / 2 < fold_x) {
                    y = y + HEIGHT;
                    fold_x = null;
                } else {
                }
            } else {
            }
            var RectangleGlyph g;
            g = new RectangleGlyph;
            g.Create(0, 0, 180, 16);
            g.fill_color = ATTR;
            node = ed.CreateNode(g, xx, y);
            al_set_dst_node(node, "$path", dtd_itr.abs_xpath + "/@" + dtd_itr.attr);
            al_set_dst_node(node, "$side", side);
            al_create_arc(node, dtd_itr.node, "$map");
            label = ed.CreateLabel(node, dtd_itr.attr + (string)dtd_itr.opt, xx, y);
            var TMGlyph tm_g;
            var integer l, t;
            tm_g = al_dst_node(label, "$geom");
            l = tm_g.left;
            t = tm_g.top;
            tm_g.Resize(l, t, l + 180, t + 16);
            ed.selection = al_cons(null, null);
            al_create_arc(ed.selection, tm_g, "$select");
            ed.Lower();
            ed.selection = al_cons(null, null);
            tm_g = al_dst_node(node, "$geom");
            al_create_arc(ed.selection, tm_g, "$select");
            ed.Lower();
            ed.selection = al_cons(null, null);
            if (al_dst_node(dtd_itr.node, "$fold")) {
                if (fold_x) {
                } else {
                    fold_x = xx;
                }
            } else {
                if (fold_x) {
                    if (xx - INDENT / 2 <= fold_x) {
                        y = y + HEIGHT;
                        fold_x = null;
                    } else {
                    }
                } else {
                    y = y + HEIGHT;
                }
            }
            continue;
        } else {
        }
        if (type == "optional" || type == "elem2" || type == "elem3") {
            var list ls, itr;
            ls = al_str_misc("split", dtd_itr.abs_xpath, '/');
            itr = al_dst_itr(ls);
            count = al_count(itr);
            tag = al_prev(itr);
            xx = x + INDENT * count;
            if (fold_x) {
                if (xx - INDENT / 2 < fold_x) {
                    y = y + HEIGHT;
                    fold_x = null;
                } else {
                }
            } else {
            }
            var RectangleGlyph g;
            g = new RectangleGlyph;
            g.Create(0, 0, 180, 16);
            if (recursive = al_dst_node(dtd_itr.node, "$recursive") && recursive < 2) {
                g.fill_color = RECUR_TAG;
            } else {
                recursive = null;
                g.fill_color = TAG;
            }
            node = ed.CreateNode(g, xx, y);
            al_set_dst_node(node, "$path", dtd_itr.abs_xpath);
            al_set_dst_node(node, "$side", side);
            al_set_dst_node(node, "$recursive", recursive);
            al_create_arc(node, dtd_itr.node, "$map");
            label = ed.CreateLabel(node, tag + (string)dtd_itr.opt, xx, y);
            var TMGlyph tm_g;
            var integer l, t;
            tm_g = al_dst_node(label, "$geom");
            l = tm_g.left;
            t = tm_g.top;
            tm_g.Resize(l, t, l + 180, t + 16);
            ed.selection = al_cons(null, null);
            al_create_arc(ed.selection, tm_g, "$select");
            ed.Lower();
            ed.selection = al_cons(null, null);
            tm_g = al_dst_node(node, "$geom");
            al_create_arc(ed.selection, tm_g, "$select");
            ed.Lower();
            ed.selection = al_cons(null, null);
            if (al_dst_node(dtd_itr.node, "$fold")) {
                if (fold_x) {
                } else {
                    fold_x = xx;
                }
            } else {
                if (fold_x) {
                    if (xx - INDENT / 2 <= fold_x) {
                        y = y + HEIGHT;
                        fold_x = null;
                    } else {
                    }
                } else {
                    y = y + HEIGHT;
                }
            }
            continue;
        } else {
        }
    }
}
end_body
member
public: void DeleteDTD1();
body
{
    var list dtd0;
    var DtdItr dtd_itr;
    var string type;
    var list node, label;
    if (dtd_info1 && dtd0 = al_dst_node(dtd_info1, "dtd_info")) {
        ed.selection = al_cons(null, null);
        dtd_itr = new DtdItr;
        dtd_itr.Reset(dtd0);
        dtd_itr.all_tag = 1;
        loop {
            type = dtd_itr.Next((list)2);
            if (type == "end") {
                break;
            } else {
            }
            if (node = al_src_node(dtd_itr.node, "$map")) {
            } else {
                continue;
            }
            var TMGlyph tm_g;
            tm_g = al_dst_node(node, "$geom");
            al_create_arc(ed.selection, tm_g, "$select");
            if (label = al_src_node(node, "$refer")) {
            } else {
                continue;
            }
            tm_g = al_dst_node(label, "$geom");
            al_create_arc(ed.selection, tm_g, "$select");
        }
        Delete();
    } else {
    }
}
end_body
member
public: void DeleteDTD2();
body
{
    var list dtd0;
    var DtdItr dtd_itr;
    var string type;
    var list node, label;
    if (dtd_info2 && dtd0 = al_dst_node(dtd_info2, "dtd_info")) {
        ed.selection = al_cons(null, null);
        dtd_itr = new DtdItr;
        dtd_itr.Reset(dtd0);
        dtd_itr.all_tag = 1;
        loop {
            type = dtd_itr.Next((list)2);
            if (type == "end") {
                break;
            } else {
            }
            if (node = al_src_node(dtd_itr.node, "$map")) {
            } else {
                continue;
            }
            var TMGlyph tm_g;
            tm_g = al_dst_node(node, "$geom");
            al_create_arc(ed.selection, tm_g, "$select");
            if (label = al_src_node(node, "$refer")) {
            } else {
                continue;
            }
            tm_g = al_dst_node(label, "$geom");
            al_create_arc(ed.selection, tm_g, "$select");
        }
        Delete();
    } else {
    }
}
end_body
member
public: void SaveMapInfo();
body
{
    var list dir_name;
    var string filename;
    if (dir_name = al_get_write_filename("map_info file(*.mapinfo)|*.mapinfo||", null)) {
    } else {
        return;
    }
    GenerateMapInfo();
    filename = dir_name.head + "/" + dir_name.tail.head;
    var file f;
    if (f = al_file_open(filename, "w")) {
    } else {
        return;
    }
    try {
        if (al_file_write(f, "graph", map_info)) {
            var AlException ex;
            ex = new AlException;
            ex.msg = "disk may be full.";
            throw ex;
        } else {
        }
    } catch (AlException e) {
        var AlDialog dlg;
        dlg = new AlDialog;
        dlg.ShowChoose("error", (string)e.msg, "", "", "OK", "");
        return;
    }
}
end_body
member
public: void LoadMapInfo();
body
{
    var list dir_name;
    var string filename;
    if (dir_name = al_get_read_filename("map_info file(*.mapinfo)|*.mapinfo||", null)) {
    } else {
        return;
    }
    filename = dir_name.head + "/" + dir_name.tail.head;
    var file f;
    if (f = al_file_open(filename, "r")) {
    } else {
        return;
    }
    var list map_info2;
    try {
        if (map_info2 = al_file_read(f, "graph")) {
        } else {
            var AlException ex;
            ex = new AlException;
            ex.msg = "file read error.";
            throw ex;
        }
    } catch (AlException e) {
        var AlDialog dlg;
        dlg = new AlDialog;
        dlg.ShowChoose("error", (string)e.msg, "", "", "OK", "");
        return;
    }
    DeleteDTD1();
    DeleteDTD2();
    map_info = map_info2;
    dtd_info1 = al_dst_node(map_info, "dtd_info1");
    dtd_info2 = al_dst_node(map_info, "dtd_info2");
    mapping = al_dst_node(map_info, "mapping");
    var list dtd;
    if (dtd_info1 && dtd = al_dst_node(dtd_info1, "dtd_info")) {
        CreateDrawInfo(1, dtd);
    } else {
    }
    if (dtd_info2 && dtd = al_dst_node(dtd_info2, "dtd_info")) {
        CreateDrawInfo(2, dtd);
    } else {
    }
    var DtdItr dtd_itr;
    var string type;
    dtd_itr = new DtdItr;
    dtd_itr.Reset((list)al_dst_node(dtd_info1, "dtd_info"));
    dtd_itr.all_tag = 1;
    var list itr, data;
    var string abs_xpath1, abs_xpath2, path;
    var list node1, node2;
    itr = al_dst_itr(mapping);
    loop {
        if (data = al_next(itr)) {
        } else {
            break;
        }
        abs_xpath1 = data.head;
        abs_xpath2 = data.tail.head;
        loop {
            type = dtd_itr.Next((list)2);
            if (type == "end") {
                break;
            } else {
            }
            if (dtd_itr.node) {
            } else {
                continue;
            }
            if (type == "attr") {
                path = dtd_itr.abs_xpath + "/@" + dtd_itr.attr;
            } else {
                path = dtd_itr.abs_xpath;
            }
            if (path == abs_xpath1) {
            } else {
                continue;
            }
            if (node1 = al_src_node(dtd_itr.node, "$map")) {
            } else {
                continue;
            }
            if (node2 = GetNodeFromPath((list)al_dst_node(dtd_info2, "dtd_info"), abs_xpath2)) {
                ed.CreateArc(node1, node2);
                break;
            } else {
            }
        }
    }
}
end_body
member
public: void GenerateMapInfo();
body
{
    al_set_dst_node(map_info, "mapping", mapping = al_cons(null, null));
    if (dtd_info1 && dtd_info2) {
    } else {
        return;
    }
    var DtdItr dtd_itr;
    var string type;
    var list node1, arc, node2;
    var string abs_xpath1, abs_xpath2;
    dtd_itr = new DtdItr;
    dtd_itr.Reset((list)al_dst_node(dtd_info1, "dtd_info"));
    dtd_itr.all_tag = 1;
    loop {
        type = dtd_itr.Next((list)2);
        if (type == "end") {
            break;
        } else {
        }
        if (type == "all_opt" || type == "repetition" && dtd_itr.node.tail.head == "|") {
            continue;
        } else {
        }
        if (dtd_itr.node) {
        } else {
            continue;
        }
        if (node1 = al_src_node(dtd_itr.node, "$map")) {
        } else {
            continue;
        }
        if (abs_xpath1 = al_dst_node(node1, "$path")) {
        } else {
            continue;
        }
        if (arc = al_src_node(node1, "$src")) {
        } else {
            continue;
        }
        if (node2 = al_dst_node(arc, "$dst")) {
        } else {
            continue;
        }
        if (abs_xpath2 = al_dst_node(node2, "$path")) {
        } else {
            continue;
        }
        al_create_arc(mapping, al_list2(abs_xpath1, abs_xpath2), null);
    }
    al_misc("output", null, null);
}
end_body
member
public: void SaveToCSV();
body
{
    var list dir_name;
    var string filename;
    if (dir_name = al_get_write_filename("CSV file(*.csv)|*.csv||", null)) {
    } else {
        return;
    }
    GenerateMapInfo();
    filename = dir_name.head + "/" + dir_name.tail.head;
    var file f;
    if (f = al_file_open(filename, "w")) {
    } else {
        return;
    }
    var list itr, data;
    var string abs_xpath1, abs_xpath2;
    itr = al_dst_itr(mapping);
    loop {
        if (data = al_next(itr)) {
        } else {
            break;
        }
        abs_xpath1 = data.head;
        abs_xpath2 = data.tail.head;
        data = al_cons(null, null);
        al_create_arc(data, abs_xpath1, 1);
        al_create_arc(data, abs_xpath2, 2);
        try {
            if (al_file_write(f, "csv", data)) {
                var AlException ex;
                ex = new AlException;
                ex.msg = "disk may be full.";
                throw ex;
            } else {
            }
        } catch (AlException e) {
            var AlDialog dlg;
            dlg = new AlDialog;
            dlg.ShowChoose("error", (string)e.msg, "", "", "OK", "");
            return;
        }
    }
    f = null;
}
end_body
member
public: void LoadFromCSV();
body
{
    var list dir_name;
    var string filename;
    if (dir_name = al_get_read_filename("CSV file(*.csv)|*.csv||", null)) {
    } else {
        return;
    }
    filename = dir_name.head + "/" + dir_name.tail.head;
    var file f;
    if (f = al_file_open(filename, "r")) {
    } else {
        return;
    }
    var DtdItr dtd_itr;
    dtd_itr = new DtdItr;
    dtd_itr.Reset((list)al_dst_node(dtd_info1, "dtd_info"));
    dtd_itr.all_tag = 1;
    var string type;
    var list data;
    var string abs_xpath1, abs_xpath2, path;
    var list node1, node2;
    loop {
        data = al_file_read(f, "csv");
        if (data == 1) {
            break;
        } else {
        }
        abs_xpath1 = al_dst_node(data, 1);
        abs_xpath2 = al_dst_node(data, 2);
        loop {
            type = dtd_itr.Next((list)2);
            if (type == "end") {
                break;
            } else {
            }
            if (dtd_itr.node) {
            } else {
                continue;
            }
            if (type == "attr") {
                path = dtd_itr.abs_xpath + "/@" + dtd_itr.attr;
            } else {
                path = dtd_itr.abs_xpath;
            }
            if (path == abs_xpath1) {
            } else {
                continue;
            }
            if (node1 = al_src_node(dtd_itr.node, "$map")) {
            } else {
                continue;
            }
            if (node2 = GetNodeFromPath((list)al_dst_node(dtd_info2, "dtd_info"), abs_xpath2)) {
                ed.CreateArc(node1, node2);
                break;
            } else {
            }
        }
    }
}
end_body
member
public: list GetNodeFromPath(list dtd_info, string abs_xpath);
body
{
    var DtdItr dtd_itr;
    var string type, path;
    dtd_itr = new DtdItr;
    dtd_itr.Reset(dtd_info);
    dtd_itr.all_tag = 1;
    var list node1;
    loop {
        type = dtd_itr.Next((list)2);
        if (type == "end") {
            break;
        } else {
        }
        if (type == "all_opt" || type == "repetition" && dtd_itr.node.tail.head == "|") {
            continue;
        } else {
        }
        if (dtd_itr.node) {
        } else {
            continue;
        }
        if (type == "attr") {
            path = dtd_itr.abs_xpath + "/@" + dtd_itr.attr;
        } else {
            path = dtd_itr.abs_xpath;
        }
        if (path == abs_xpath) {
        } else {
            continue;
        }
        if (node1 = al_src_node(dtd_itr.node, "$map")) {
        } else {
            continue;
        }
        return node1;
    }
    return null;
}
end_body
member
public: void Exit();
body
{
    al_misc("exit", 0, null);
}
end_body
member
public: list map_info;
member
public: list dtd_info1;
member
public: list dtd_info2;
member
public: list mapping;
member
public: void Arc();
body
{
    ed.status = Status::InputArc;
}
end_body
member
public: void Reconnect();
body
{
    ed.status = Status::SelectArc;
}
end_body
member
public: void Delete();
body
{
    ed.Delete();
}
end_body
member
public: list GetSelectedNode();
body
{
    var list itr, elem1, elem2;
    var TMGlyph info;
    itr = al_dst_itr(ed.selection);
    if (al_count(itr) == 1) {
    } else {
        return null;
    }
    if (info = al_dst_node(ed.selection, "$select")) {
        if (elem1 = al_src_node(info, "$geom")) {
            if (elem1 && elem1.head == 1) {
                return elem1;
            } else {
                elem2 = al_dst_node(elem1, "$refer");
                if (elem2 && elem2.head == 1) {
                    return elem2;
                } else {
                    return null;
                }
            }
        } else {
        }
    } else {
        return null;
    }
}
end_body
member
public: void Fold();
body
{
    var list ui_node, dtd_node, ui_node2;
    var integer side;
    var TMGlyph tm_g;
    var integer x, x2, y, y2, INDENT, HEIGHT;
    INDENT = 30;
    HEIGHT = 20;
    if (ui_node = GetSelectedNode()) {
    } else {
        return;
    }
    if (side = al_dst_node(ui_node, "$side")) {
    } else {
        return;
    }
    if (dtd_node = al_dst_node(ui_node, "$map")) {
    } else {
        return;
    }
    if (dtd_node.head == "attr") {
        return;
    } else {
    }
    if (al_dst_node(dtd_node, "$fold")) {
        return;
    } else {
    }
    al_set_dst_node(dtd_node, "$fold", 1);
    var list dtd;
    if (side == 1) {
        dtd = al_dst_node(dtd_info1, "dtd_info");
    } else {
        dtd = al_dst_node(dtd_info2, "dtd_info");
    }
    var DtdItr dtd_itr;
    var string type;
    dtd_itr = new DtdItr;
    dtd_itr.Reset(dtd);
    dtd_itr.all_tag = 1;
    loop {
        type = dtd_itr.Next((list)2);
        if (type == "end") {
            break;
        } else {
        }
        if (type == "all_opt" || type == "repetition" && dtd_itr.node.tail.head == "|") {
            continue;
        } else {
        }
        if (al_addr_eq(dtd_itr.node, dtd_node)) {
            break;
        } else {
        }
    }
    tm_g = al_dst_node(ui_node, "$geom");
    x = tm_g.left;
    y = tm_g.top;
    loop {
        type = dtd_itr.Next((list)2);
        if (type == "end") {
            break;
        } else {
        }
        if (type == "all_opt" || type == "repetition" && dtd_itr.node.tail.head == "|") {
            continue;
        } else {
        }
        if (dtd_itr.node && ui_node2 = al_src_node(dtd_itr.node, "$map")) {
        } else {
            continue;
        }
        tm_g = al_dst_node(ui_node2, "$geom");
        x2 = tm_g.left;
        y2 = tm_g.top;
        if (x2 - INDENT / 2 < x) {
            ed.selection = al_cons(null, null);
            al_create_arc(ed.selection, tm_g, "$select");
            break;
        } else {
        }
        ed.selection = al_cons(null, null);
        al_create_arc(ed.selection, tm_g, "$select");
        ed.DoMove(0, y - y2);
    }
    loop {
        type = dtd_itr.Next((list)2);
        if (type == "end") {
            break;
        } else {
        }
        if (type == "all_opt" || type == "repetition" && dtd_itr.node.tail.head == "|") {
            continue;
        } else {
        }
        if (dtd_itr.node && ui_node2 = al_src_node(dtd_itr.node, "$map")) {
        } else {
            continue;
        }
        tm_g = al_dst_node(ui_node2, "$geom");
        al_create_arc(ed.selection, tm_g, "$select");
    }
    ed.DoMove(0, y - y2 + HEIGHT);
    ed.selection = al_cons(null, null);
    tm_g = al_dst_node(ui_node, "$geom");
    al_create_arc(ed.selection, tm_g, "$select");
    ed.Damage();
}
end_body
member
public: void Expand();
body
{
    var list ui_node, dtd_node, ui_node2;
    var integer side;
    var TMGlyph tm_g;
    var integer x, x2, x3, y, y2, INDENT, HEIGHT;
    INDENT = 30;
    HEIGHT = 20;
    if (ui_node = GetSelectedNode()) {
    } else {
        return;
    }
    if (side = al_dst_node(ui_node, "$side")) {
    } else {
        return;
    }
    if (dtd_node = al_dst_node(ui_node, "$map")) {
    } else {
        return;
    }
    if (al_dst_node(dtd_node, "$fold")) {
    } else {
        return;
    }
    al_set_dst_node(dtd_node, "$fold", null);
    var list dtd;
    if (side == 1) {
        dtd = al_dst_node(dtd_info1, "dtd_info");
    } else {
        dtd = al_dst_node(dtd_info2, "dtd_info");
    }
    var DtdItr dtd_itr;
    var string type;
    dtd_itr = new DtdItr;
    dtd_itr.Reset(dtd);
    dtd_itr.all_tag = 1;
    loop {
        type = dtd_itr.Next((list)2);
        if (type == "end") {
            break;
        } else {
        }
        if (type == "all_opt" || type == "repetition" && dtd_itr.node.tail.head == "|") {
            continue;
        } else {
        }
        if (al_addr_eq(dtd_itr.node, dtd_node)) {
            break;
        } else {
        }
    }
    tm_g = al_dst_node(ui_node, "$geom");
    x = tm_g.left;
    y2 = y = tm_g.top;
    loop {
        type = dtd_itr.Next((list)2);
        if (type == "end") {
            break;
        } else {
        }
        if (type == "all_opt" || type == "repetition" && dtd_itr.node.tail.head == "|") {
            continue;
        } else {
        }
        if (dtd_itr.node && ui_node2 = al_src_node(dtd_itr.node, "$map")) {
        } else {
            continue;
        }
        tm_g = al_dst_node(ui_node2, "$geom");
        x2 = tm_g.left;
        y2 = y2 + HEIGHT;
        if (x2 - INDENT / 2 < x) {
            ed.selection = al_cons(null, null);
            al_create_arc(ed.selection, tm_g, "$select");
            break;
        } else {
        }
        ed.selection = al_cons(null, null);
        al_create_arc(ed.selection, tm_g, "$select");
        ed.DoMove(0, y2 - y);
        x3 = 10000000;
        loop {
            if (al_dst_node(dtd_itr.node, "$fold")) {
                loop {
                    type = dtd_itr.Next((list)2);
                    if (type == "end") {
                        break;
                    } else {
                    }
                    if (type == "all_opt" || type == "repetition" && dtd_itr.node.tail.head == "|") {
                        continue;
                    } else {
                    }
                    if (dtd_itr.node && ui_node2 = al_src_node(dtd_itr.node, "$map")) {
                    } else {
                        continue;
                    }
                    tm_g = al_dst_node(ui_node2, "$geom");
                    x3 = tm_g.left;
                    if (x3 - INDENT / 2 < x) {
                        ed.selection = al_cons(null, null);
                        al_create_arc(ed.selection, tm_g, "$select");
                        break;
                    } else {
                    }
                    if (x3 - INDENT / 2 < x2) {
                        y2 = y2 + HEIGHT;
                        ed.selection = al_cons(null, null);
                        al_create_arc(ed.selection, tm_g, "$select");
                        ed.DoMove(0, y2 - y);
                        break;
                    } else {
                        ed.selection = al_cons(null, null);
                        al_create_arc(ed.selection, tm_g, "$select");
                        ed.DoMove(0, y2 - y);
                    }
                }
            } else {
                break;
            }
            if (x3 - INDENT / 2 < x) {
                break;
            } else {
            }
        }
        if (x3 - INDENT / 2 < x) {
            y2 = y2 + HEIGHT;
            break;
        } else {
        }
    }
    loop {
        type = dtd_itr.Next((list)2);
        if (type == "end") {
            break;
        } else {
        }
        if (type == "all_opt" || type == "repetition" && dtd_itr.node.tail.head == "|") {
            continue;
        } else {
        }
        if (dtd_itr.node && ui_node2 = al_src_node(dtd_itr.node, "$map")) {
        } else {
            continue;
        }
        tm_g = al_dst_node(ui_node2, "$geom");
        al_create_arc(ed.selection, tm_g, "$select");
    }
    ed.DoMove(0, y2 - y - HEIGHT);
    ed.selection = al_cons(null, null);
    tm_g = al_dst_node(ui_node, "$geom");
    al_create_arc(ed.selection, tm_g, "$select");
    ed.Damage();
}
end_body
member
public: void ExpandAll();
body
{
    GenerateMapInfo();
    DeleteDTD1();
    DeleteDTD2();
    var DtdItr dtd_itr;
    var string type;
    var list dtd;
    if (dtd_info1 && dtd = al_dst_node(dtd_info1, "dtd_info")) {
        dtd_itr = new DtdItr;
        dtd_itr.Reset(dtd);
        dtd_itr.all_tag = 1;
        loop {
            type = dtd_itr.Next((list)2);
            if (type == "end") {
                break;
            } else {
            }
            if (dtd_itr.node) {
                al_set_dst_node(dtd_itr.node, "$fold", null);
            } else {
            }
        }
        CreateDrawInfo(1, dtd);
    } else {
    }
    if (dtd_info2 && dtd = al_dst_node(dtd_info2, "dtd_info")) {
        dtd_itr = new DtdItr;
        dtd_itr.Reset(dtd);
        dtd_itr.all_tag = 1;
        loop {
            type = dtd_itr.Next((list)2);
            if (type == "end") {
                break;
            } else {
            }
            if (dtd_itr.node) {
                al_set_dst_node(dtd_itr.node, "$fold", null);
            } else {
            }
        }
        CreateDrawInfo(2, dtd);
    } else {
    }
    if (dtd_info1 && dtd_info2) {
    } else {
        return;
    }
    dtd_itr = new DtdItr;
    dtd_itr.Reset((list)al_dst_node(dtd_info1, "dtd_info"));
    dtd_itr.all_tag = 1;
    var list itr, data;
    var string abs_xpath1, abs_xpath2, path;
    var list node1, node2;
    itr = al_dst_itr(mapping);
    loop {
        if (data = al_next(itr)) {
        } else {
            break;
        }
        abs_xpath1 = data.head;
        abs_xpath2 = data.tail.head;
        loop {
            type = dtd_itr.Next((list)2);
            if (type == "end") {
                break;
            } else {
            }
            if (dtd_itr.node) {
            } else {
                continue;
            }
            if (type == "attr") {
                path = dtd_itr.abs_xpath + "/@" + dtd_itr.attr;
            } else {
                path = dtd_itr.abs_xpath;
            }
            if (path == abs_xpath1) {
            } else {
                continue;
            }
            if (node1 = al_src_node(dtd_itr.node, "$map")) {
            } else {
                continue;
            }
            if (node2 = GetNodeFromPath((list)al_dst_node(dtd_info2, "dtd_info"), abs_xpath2)) {
                ed.CreateArc(node1, node2);
                break;
            } else {
            }
        }
    }
}
end_body
member
public: void ExpandRecursive();
body
{
    var list ui_node, dtd_node, dtd_node2;
    var integer side;
    if (ui_node = GetSelectedNode()) {
    } else {
        return;
    }
    if (side = al_dst_node(ui_node, "$side")) {
    } else {
        return;
    }
    if (dtd_node = al_dst_node(ui_node, "$map")) {
    } else {
        return;
    }
    if (al_dst_node(dtd_node, "$recursive") == 0) {
    } else {
        return;
    }
    GenerateMapInfo();
    var list dtd;
    if (side == 1) {
        dtd = al_dst_node(dtd_info1, "dtd_info");
    } else {
        dtd = al_dst_node(dtd_info2, "dtd_info");
    }
    var DtdItr dtd_itr;
    var string type;
    dtd_itr = new DtdItr;
    dtd_itr.Reset(dtd);
    dtd_itr.all_tag = 1;
    loop {
        type = dtd_itr.Next((list)2);
        if (type == "end") {
            break;
        } else {
        }
        if (al_addr_eq(dtd_itr.node, dtd_node)) {
            break;
        } else {
        }
        dtd_node2 = dtd_itr.node;
    }
    dtd_itr = new DtdItr;
    dtd_itr.Reset(dtd);
    dtd_itr.all_tag = 1;
    loop {
        type = dtd_itr.Next((list)2);
        if (type == "end") {
            break;
        } else {
        }
        if (al_addr_eq(dtd_itr.node, dtd_node2)) {
            break;
        } else {
        }
    }
    dtd_itr.all_tag = null;
    dtd_itr.Next(null);
    if (side == 1) {
        DeleteDTD1();
        CreateDrawInfo(1, dtd);
    } else {
        DeleteDTD2();
        CreateDrawInfo(2, dtd);
    }
    if (dtd_info1 && dtd_info2) {
    } else {
        return;
    }
    dtd_itr = new DtdItr;
    dtd_itr.Reset((list)al_dst_node(dtd_info1, "dtd_info"));
    dtd_itr.all_tag = 1;
    var list itr, data;
    var string abs_xpath1, abs_xpath2, path;
    var list node1, node2;
    itr = al_dst_itr(mapping);
    loop {
        if (data = al_next(itr)) {
        } else {
            break;
        }
        abs_xpath1 = data.head;
        abs_xpath2 = data.tail.head;
        loop {
            type = dtd_itr.Next((list)2);
            if (type == "end") {
                break;
            } else {
            }
            if (dtd_itr.node) {
            } else {
                continue;
            }
            if (type == "attr") {
                path = dtd_itr.abs_xpath + "/@" + dtd_itr.attr;
            } else {
                path = dtd_itr.abs_xpath;
            }
            if (path == abs_xpath1) {
            } else {
                continue;
            }
            if (node1 = al_src_node(dtd_itr.node, "$map")) {
            } else {
                continue;
            }
            if (node2 = GetNodeFromPath((list)al_dst_node(dtd_info2, "dtd_info"), abs_xpath2)) {
                ed.CreateArc(node1, node2);
                break;
            } else {
            }
        }
    }
}
end_body
member
public: static void set_trace();
body
{
    al_prof("set", "trace", null);
    var string platform;
    platform = al_misc("platform", null, null);
    if (platform == "windows") {
        al_prof("start", "trace", al_list2(2, "d:/temp/trace.txt"));
    } else {
    }
    if (platform == "linux") {
        al_prof("start", "trace", al_list2(2, "/proj/altair/tmp/trace.txt"));
    } else {
    }
}
end_body
member
public: static void unset_trace();
body
{
    al_prof("stop", "trace", null);
    al_prof("clear", "trace", null);
}
end_body
end_class
Body
GUI
class DataMapperApp
member
public: static void main();
body
{
    var DataMapperView obj2;
    var integer obj3;
    var string obj4;
    var integer stat;
    stat = 1;
    loop {
        if (stat == 1) {
            obj2 = GUIbuilder::CreateWindow("DataMapperView", (list)0x2000, null, null);
            obj2.Init();
            break;
        } else {
        }
    }
}
end_body
member
public: void public_func();
body
{
    DataMapperApp::main();
}
end_body
member
public: list debug;
member
public: list debug2;
member
public: list debug3;
member
public: void xml_debug();
class FileUtility
member
public: static string tempFile();
body
{
    var string platform, dir;
    platform = al_misc("platform", null, null);
    if (platform == "linux") {
        dir = "/tmp";
    } else {
    }
    if (platform == "windows") {
        dir = al_misc("get_env", "TEMP", null);
    } else {
    }
    return al_file_manip("tmp_file", dir, "al");
}
end_body
member
public: static list readBinary(string filename);
body
{
    var integer size;
    var file in;
    var list buffer;
    if (al_file_manip("does_exist", filename, null)) {
    } else {
        var AlException ex;
        ex = new AlException;
        ex.msg = "file: \'" + (string)filename + "\' not found";
        throw ex;
    }
    if (filename && size = al_file_manip("get_size", filename, null)) {
    } else {
        var AlException ex;
        ex = new AlException;
        ex.msg = "file: can\'t get file size of \'" + (string)filename + "\'";
        throw ex;
    }
    if (in = al_file_open(filename, "rb")) {
    } else {
        var AlException ex;
        ex = new AlException;
        ex.msg = "file: can\'t open read file \'" + (string)filename + "\'";
        throw ex;
    }
    buffer = al_misc("binary", size, null);
    if (al_file_read(in, al_list3(buffer, 0, size))) {
        var AlException ex;
        ex = new AlException;
        ex.msg = "file: fail to read \'" + (string)filename + "\'";
        throw ex;
    } else {
    }
    return buffer;
}
end_body
member
public: static string readString(string filename);
body
{
    var list buffer;
    var integer size;
    var string str;
    buffer = FileUtility::readBinary(filename);
    size = al_misc("binary_size", buffer, null);
    str = al_misc("binary_to_string", al_list3(buffer, 0, size), null);
    return str;
}
end_body
member
public: static void writeBinary(string filename, list bin);
body
{
    var integer size;
    size = al_misc("binary_size", bin, null);
    FileUtility::writeBinary(filename, bin, 0, size);
}
end_body
member
public: static void writeBinary(string filename, list bin, integer from, integer size);
body
{
    var file out;
    if (out = al_file_open(filename, "wb")) {
    } else {
        var AlException ex;
        ex = new AlException;
        ex.msg = "file: can\'t open write file \'" + (string)filename + "\'";
        throw ex;
    }
    if (al_file_write(out, al_list3(bin, from, size), null)) {
        var AlException ex;
        ex = new AlException;
        ex.msg = "file: fail to write \'" + (string)filename + "\'";
        throw ex;
    } else {
    }
}
end_body
member
public: static void writeBinary(string filename, string str);
body
{
    var integer size;
    var list bin;
    size = al_strlen(str);
    bin = al_misc("binary", size, null);
    al_misc("binary_copy", al_list2(bin, 0), str);
    FileUtility::writeBinary(filename, bin, 0, size);
}
end_body
member
public: static void appendBinary(string filename, list bin);
body
{
    var integer size;
    size = al_misc("binary_size", bin, null);
    FileUtility::appendBinary(filename, bin, 0, size);
}
end_body
member
public: static void appendBinary(string filename, list bin, integer from, integer size);
body
{
    var file out;
    if (out = al_file_open(filename, "ab")) {
    } else {
        var AlException ex;
        ex = new AlException;
        ex.msg = "file: can\'t open write file \'" + (string)filename + "\'";
        throw ex;
    }
    if (al_file_write(out, al_list3(bin, from, size), null)) {
        var AlException ex;
        ex = new AlException;
        ex.msg = "file: fail to write \'" + (string)filename + "\'";
        throw ex;
    } else {
    }
}
end_body
member
public: static void appendBinary(string filename, string str);
body
{
    var integer size;
    var list bin;
    size = al_strlen(str);
    bin = al_misc("binary", size, null);
    al_misc("binary_copy", al_list2(bin, 0), str);
    FileUtility::appendBinary(filename, bin, 0, size);
}
end_body
member
public: static void writeString(string filename, string str);
body
{
    var file out;
    if (out = al_file_open(filename, "w")) {
    } else {
        var AlException ex;
        ex = new AlException;
        ex.msg = "file: can\'t open write file \'" + (string)filename + "\'";
        throw ex;
    }
    if (al_file_write(out, "string", str)) {
        var AlException ex;
        ex = new AlException;
        ex.msg = "file: fail to write \'" + (string)filename + "\'";
        throw ex;
    } else {
    }
}
end_body
member
public: static void appendString(string filename, string str);
body
{
    var file out;
    if (out = al_file_open(filename, "a")) {
    } else {
        var AlException ex;
        ex = new AlException;
        ex.msg = "file: can\'t open write file \'" + (string)filename + "\'";
        throw ex;
    }
    if (al_file_write(out, "string", str)) {
        var AlException ex;
        ex = new AlException;
        ex.msg = "file: fail to write \'" + (string)filename + "\'";
        throw ex;
    } else {
    }
}
end_body
member
public: static list readGraphData(string filename);
body
{
    if (al_file_manip("does_exist", filename, null)) {
    } else {
        return null;
    }
    var list data;
    var file in;
    if (in = al_file_open(filename, "r")) {
    } else {
        var AlException ex;
        ex = new AlException;
        ex.msg = "file: can\'t open read file \'" + (string)filename + "\'";
        throw ex;
    }
    if (data = al_file_read(in, "graph")) {
    } else {
        var AlException ex;
        ex = new AlException;
        ex.msg = "file: fail to read graph data from \'" + (string)filename + "\'";
        throw ex;
    }
    return data;
}
end_body
member
public: static void writeGraphData(string filename, list data);
body
{
    var file out;
    if (out = al_file_open(filename, "w")) {
    } else {
        var AlException ex;
        ex = new AlException;
        ex.msg = "file: can\'t open write file \'" + (string)filename + "\'";
        throw ex;
    }
    if (al_file_write(out, "graph", data)) {
        var AlException ex;
        ex = new AlException;
        ex.msg = "file: fail to write graph data \'" + (string)filename + "\'";
        throw ex;
    } else {
    }
}
end_body
member
public: static void remove(string dir);
body
{
    var RevFileItr itr;
    itr = new RevFileItr;
    itr.Reset(dir);
    loop {
        if (itr.Next()) {
        } else {
            break;
        }
        al_file_manip("remove", itr.abs_path, null);
    }
}
end_body
member
public: static void makeReadOnly(string dir);
body
{
    var FileItr itr;
    itr = new FileItr;
    itr.Reset(dir);
    loop {
        if (itr.Next()) {
        } else {
            break;
        }
        al_file_manip("set_readonly", itr.abs_path, null);
    }
}
end_body
member
public: static void makeWritable(string dir);
body
{
    var FileItr itr;
    itr = new FileItr;
    itr.Reset(dir);
    loop {
        if (itr.Next()) {
        } else {
            break;
        }
        al_file_manip("set_readonly", itr.abs_path, 1);
    }
}
end_body
class FileItr
member
public: void Reset(string root);
body
{
    if (al_file_manip("does_exist", root, null) && al_file_manip("is_dir", root, null)) {
    } else {
        return;
    }
    var list node, itr;
    node = al_file_manip("find_file", root, null);
    itr = al_dst_itr(node);
    stack = al_cons(al_list2("", itr), stack);
    this.root = root;
    abs_path = null;
}
end_body
member
public: list Next();
body
{
    if (stack) {
    } else {
        return null;
    }
    var list itr, node;
    if (abs_path) {
    } else {
        path = "";
        name = "";
        abs_path = root;
        is_dir = al_file_manip("is_dir", abs_path, null);
        return abs_path;
    }
    path = stack.head.head;
    itr = stack.head.tail.head;
    if (is_dir && name != "") {
        node = al_file_manip("find_file", abs_path, null);
        itr = al_dst_itr(node);
        if (path == "") {
            path = name;
        } else {
            path = path + "/" + name;
        }
        stack = al_cons(al_list2(path, itr), stack);
    } else {
    }
    loop {
        if (name = al_next(itr)) {
        } else {
            stack = stack.tail;
            if (stack) {
            } else {
                return null;
            }
            path = stack.head.head;
            itr = stack.head.tail.head;
            continue;
        }
        if (name == "." || name == "..") {
            continue;
        } else {
        }
        if (path == "") {
            abs_path = root + "/" + name;
        } else {
            abs_path = root + "/" + path + "/" + name;
        }
        is_dir = al_file_manip("is_dir", abs_path, null);
        return abs_path;
    }
}
end_body
member
public: list stack;
member
public: string root;
member
public: string path;
member
public: string name;
member
public: string abs_path;
member
public: list is_dir;
end_class
class RevFileItr
member
public: void Reset(string root);
body
{
    if (al_file_manip("does_exist", root, null) && al_file_manip("is_dir", root, null)) {
    } else {
        return;
    }
    var list node, itr;
    node = al_file_manip("find_file", root, null);
    itr = al_dst_itr(node);
    stack = al_cons(al_list2("", itr), stack);
    this.root = root;
    abs_path = null;
}
end_body
member
public: list Next();
body
{
    if (is_dir) {
        stack = stack.tail;
    } else {
    }
    if (stack) {
    } else {
        return null;
    }
    var list itr, node;
    path = stack.head.head;
    itr = stack.head.tail.head;
    loop {
        if (name = al_next(itr)) {
        } else {
            path = stack.head.head;
            if (path == "") {
                abs_path = root;
            } else {
                abs_path = root + "/" + path;
            }
            is_dir = 1;
            return abs_path;
        }
        if (name == "." || name == "..") {
            continue;
        } else {
        }
        if (path == "") {
            abs_path = root + "/" + name;
        } else {
            abs_path = root + "/" + path + "/" + name;
        }
        is_dir = al_file_manip("is_dir", abs_path, null);
        if (is_dir) {
            node = al_file_manip("find_file", abs_path, null);
            itr = al_dst_itr(node);
            if (path == "") {
                path = name;
            } else {
                path = path + "/" + name;
            }
            stack = al_cons(al_list2(path, itr), stack);
        } else {
            return abs_path;
        }
    }
}
end_body
member
public: list stack;
member
public: string root;
member
public: string path;
member
public: string name;
member
public: string abs_path;
member
public: list is_dir;
end_class
end_class
class XmlUtility
member
public: static list loadDTD(string filename);
body
{
    var DtdLoader loader;
    var file in, out;
    var list err;
    var string tmp_file;
    loader = new ExtendedDtdLoader;
    loader.log_level = 20;
    loop {
        if (in = al_file_open(filename, "r")) {
        } else {
            err = "can\'t open DTD file \"" + filename + "\"";
            break;
        }
        if (err = loader.read_entities(in)) {
            break;
        } else {
        }
        if (tmp_file = FileUtility::tempFile()) {
        } else {
            err = "can\'t get temp file name";
            break;
        }
        if (in = al_file_open(filename, "r")) {
        } else {
            err = "can\'t open DTD file \"" + filename + "\"";
            break;
        }
        if (out = al_file_open(tmp_file, "w")) {
        } else {
            err = "can\'t open temp file \"" + tmp_file + "\"";
            break;
        }
        if (err = loader.apply_entities(in, out)) {
            break;
        } else {
        }
        in = out = null;
        if (in = al_file_open(tmp_file, "r")) {
        } else {
            err = "can\'t open temp file \"" + tmp_file + "\"";
            break;
        }
        if (err = loader.read_element(in)) {
            break;
        } else {
        }
        in = null;
        if (in = al_file_open(tmp_file, "r")) {
        } else {
            err = "can\'t open temp file \"" + tmp_file + "\"";
            break;
        }
        if (err = loader.elem_attr(in)) {
            break;
        } else {
        }
        in = null;
        break;
    }
    in = out = null;
    if (tmp_file) {
        al_file_manip("remove", tmp_file, null);
    } else {
    }
    if (err) {
        var AlException ex;
        ex = new AlException;
        ex.msg = "xml: " + (string)err;
        throw ex;
    } else {
    }
    return loader.root_elem;
}
end_body
class DtdLoader
member
public: list read_entities(file in);
body
{
    entities = al_cons(null, null);
    var string str, name, value, name2, value2;
    var integer ch;
    loop {
        if (al_file_match_str(in, "<")) {
        } else {
            if (str = al_file_read(in, "xident")) {
                error_log("unexpected string \'" + str + "\'");
                return "unexpected string \'" + str + "\'";
            } else {
            }
            return null;
        }
        al_file_manip("unput", in, 1);
        if (al_file_match_str(in, "<!ENTITY")) {
            if (al_file_match_str(in, "%")) {
            } else {
                warning_log("not found \'%\' after \"<!ENTITY\".");
                if (al_file_read(in, al_list2("find", '>'))) {
                } else {
                    error_log("unexpected EOF (1)");
                    return "unexpected EOF (1)";
                }
                continue;
            }
            if (name = al_file_read(in, "string")) {
            } else {
                error_log("entity_name expected.");
                return "entity_name expected.";
            }
            info_log("entity: " + name);
            if (value = al_file_read(in, "quote_string") || value = al_file_read(in, "single_quote_string")) {
                var file in2;
                var string value_ref;
                value_ref = value;
                in2 = al_file_open(value, "sr");
                value = al_copy("");
                loop {
                    ch = al_file_read(in2, "char");
                    if (ch ==  - 1) {
                        break;
                    } else {
                    }
                    if (ch != '%') {
                        al_append_str(value, ch);
                    } else {
                        if (name2 = al_file_read(in2, "xident")) {
                        } else {
                            error_log("sub-entity_name expected.");
                            return "sub-entity_name expected.";
                        }
                        info_log("sub-entity: " + name2);
                        if (al_file_match_str(in2, ";")) {
                        } else {
                            error_log("\';\' expected after\'" + name2 + "\'.");
                            return "\';\' expected after\'" + name2 + "\'.";
                        }
                        if (value2 = al_dst_node(entities, name2)) {
                        } else {
                            error_log("entity " + name2 + "not found.(in entity " + name + ")");
                            return "entity " + name2 + "not found.(in entity " + name + ")";
                        }
                        al_append_str(value, value2);
                    }
                }
            } else {
                error_log("entity_value expected. (entity " + name + ")");
                return "entity_value expected. (entity " + name + ")";
            }
            al_create_arc(entities, value, name);
            info_log("value: " + value);
            if (al_file_match_str(in, ">")) {
            } else {
                error_log("\'>\' expected.");
                return "\'>\' expected.";
            }
            continue;
        } else {
        }
        if (al_file_match_str(in, "<!--")) {
            if (al_file_read(in, al_list2("find", "-->"))) {
            } else {
                error_log("unexpected EOF (2)");
                return "unexpected EOF (2)";
            }
            continue;
        } else {
        }
        if (al_file_match_str(in, "<?")) {
            if (al_file_read(in, al_list2("find", "?>"))) {
            } else {
                error_log("unexpected EOF (3)");
                return "unexpected EOF (3)";
            }
            continue;
        } else {
        }
        if (al_file_match_str(in, "<!")) {
            if (al_file_read(in, al_list2("find", ">"))) {
            } else {
                error_log("unexpected EOF (4)");
                return "unexpected EOF (4)";
            }
            continue;
        } else {
        }
    }
}
end_body
member
public: list apply_entities(file in, file out);
body
{
    var string str, name, value;
    var integer pos, ch;
    loop {
        if (al_file_match_str(in, "<")) {
        } else {
            if (str = al_file_read(in, "string")) {
                error_log("unexpected string \'" + str + "\'");
                return "unexpected string \'" + str + "\'";
            } else {
            }
            return null;
        }
        al_file_manip("unput", in, 1);
        if (al_file_match_str(in, "<!ENTITY")) {
            if (al_file_read(in, al_list2("find", '>'))) {
            } else {
                error_log("unexpected EOF (5)");
                return "unexpected EOF (5)";
            }
            continue;
        } else {
        }
        if (al_file_match_str(in, "<!--")) {
            if (al_file_read(in, al_list2("find", "-->"))) {
            } else {
                error_log("unexpected EOF (6)");
                return "unexpected EOF (6)";
            }
            continue;
        } else {
        }
        if (al_file_match_str(in, "<!NOTATION")) {
            if (al_file_read(in, al_list2("find", ">"))) {
            } else {
                error_log("unexpected EOF (7)");
                return "unexpected EOF (7)";
            }
            continue;
        } else {
        }
        if (al_file_match_str(in, "<!")) {
            str = al_copy("<!");
            loop {
                pos = al_file_manip("curr_pos", in, null);
                if (al_file_match_str(in, ">")) {
                    al_append_str(str, ">\n");
                    al_file_write(out, "string", str);
                    break;
                } else {
                }
                al_file_manip("back", in, pos);
                ch = al_file_read(in, "char");
                if (ch != '%') {
                    al_append_str(str, ch);
                } else {
                    if (name = al_file_read(in, "xident")) {
                    } else {
                        error_log("not found entity name");
                        return "not found entity name";
                    }
                    if (value = al_dst_node(entities, name)) {
                    } else {
                        error_log("not found entity \'" + name + "\'");
                        return "not found entity \'" + name + "\'";
                    }
                    if (al_file_match_str(in, ";")) {
                    } else {
                        error_log("\';\' expected after\'" + name + "\'.");
                        return "\';\' expected after\'" + name + "\'.";
                    }
                    al_append_str(str, value);
                    al_append_str(str, ' ');
                }
            }
            continue;
        } else {
        }
        if (al_file_match_str(in, "<?")) {
            if (al_file_read(in, al_list2("find", "?>"))) {
            } else {
                error_log("unexpected EOF (8)");
                return "unexpected EOF (8)";
            }
            continue;
        } else {
        }
    }
}
end_body
member
public: list entities;
member
public: list read_element(file in);
body
{
    var string tag, str;
    var list elem;
    elems = al_cons(null, null);
    loop {
        if (al_file_match_str(in, "<!ELEMENT")) {
            if (tag = al_file_read(in, "xident")) {
            } else {
                error_log("element tag name expected.");
                return "element tag name expected.";
            }
            info_log("element tag: " + tag);
            if (elem = al_dst_node(elems, tag)) {
            } else {
                elem = al_list5("elem", null, tag, "", null);
                al_create_arc(elems, elem, tag);
            }
            if (al_file_read(in, al_list2("find", ">"))) {
            } else {
                error_log("unexpected EOF (9)");
                return "unexpected EOF (9)";
            }
            continue;
        } else {
        }
        if (al_file_match_str(in, "<!ATTLIST")) {
            if (al_file_read(in, al_list2("find", ">"))) {
            } else {
                error_log("unexpected EOF (10)");
                return "unexpected EOF (10)";
            }
            continue;
        } else {
        }
        if (str = al_file_read(in, "string")) {
            error_log("unexpected token\'" + str + "\'");
            return "unexpected token\'" + str + "\'";
        } else {
        }
        return null;
    }
}
end_body
member
public: list elems;
member
public: list root_elem;
member
public: list elem_attr(file in);
body
{
    var string tag, str;
    var list elem, elem2, itr, tags, all_opt;
    loop {
        if (al_file_match_str(in, "<!ELEMENT")) {
            if (tag = al_file_read(in, "xident")) {
            } else {
                error_log("element tag name expected.");
                return "element tag name expected.";
            }
            info_log("element tag: " + tag);
            if (elem = al_dst_node(elems, tag)) {
            } else {
                error_log("element tag \'" + tag + "\' not found.");
                return "element tag \'" + tag + "\' not found.";
            }
            if (elem2 = load_elem(in)) {
                al_create_arc(elem, elem2, null);
            } else {
                error_log("element definition of tag name \'" + tag + "\' is illegal.");
                return "element definition of tag name \'" + tag + "\' is illegal.";
            }
            if (al_file_match_str(in, ">")) {
            } else {
                error_log("\'>\' expected at !ELEMENT (tag = " + tag + ").");
                return "\'>\' expected at !ELEMENT (tag = " + tag + ").";
            }
            continue;
        } else {
        }
        if (al_file_match_str(in, "<!ATTLIST")) {
            if (tag = al_file_read(in, "xident")) {
            } else {
                error_log("attlist tag name expected.");
                return "attlist tag name expected.";
            }
            info_log("attlist tag: " + tag);
            if (elem = al_dst_node(elems, tag)) {
            } else {
                error_log("attlist tag \'" + tag + "\' not found.");
                return "attlist tag \'" + tag + "\' not found.";
            }
            if (add_attr(elem, in)) {
                error_log("attr definition of tag name \'" + tag + "\' is illegal.");
                return "attr definition of tag name \'" + tag + "\' is illegal.";
            } else {
            }
            if (al_file_match_str(in, ">")) {
            } else {
                error_log("\'>\' expected at !ATTLIST (tag = " + tag + ").");
                return "\'>\' expected at !ATTLIST (tag = " + tag + ").";
            }
            continue;
        } else {
        }
        if (str = al_file_read(in, "string")) {
            error_log("unexpected token\'" + str + "\'");
            return "unexpected token\'" + str + "\'";
        } else {
        }
        itr = al_dst_itr(elems);
        root_elem = al_next(itr);
        normalize();
        elems = null;
        tags = al_cons(null, null);
        check_recursive(root_elem, tags);
        return null;
    }
}
end_body
member
public: list load_elem(file in);
body
{
    var list elem, elem2;
    if (elem = load_elem1(in)) {
    } else {
        error_log("<elem1> expected.");
        return null;
    }
    if (al_file_match_str(in, "?")) {
        elem.tail.tail.tail.head = "?";
        return elem;
    } else {
    }
    if (al_file_match_str(in, "*")) {
        elem.tail.tail.tail.head = "*";
        return elem;
    } else {
    }
    if (al_file_match_str(in, "+")) {
        elem.tail.tail.tail.head = "+";
        return elem;
    } else {
    }
    return elem;
}
end_body
member
public: list load_elem1(file in);
body
{
    var list elem, elem2, opt;
    if (al_file_match_str(in, "(")) {
        elem = al_list5("elem", null, null, "", 1);
        loop {
            if (elem2 = load_elem(in)) {
            } else {
                error_log("<elem> expected.");
                return null;
            }
            if (elem2.head == "elem") {
                if (elem2.tail.tail.head) {
                    // elem_tag
                    opt = elem2.tail.tail.tail.head;
                    if (opt == "?" || opt == "*") {
                    } else {
                        elem.tail.tail.tail.tail.head = null;
                    }
                } else {
                    // not elem tag
                    if (elem2.tail.tail.tail.tail.head) {
                    } else {
                        elem.tail.tail.tail.tail.head = null;
                    }
                }
            } else {
            }
            if (al_file_match_str(in, ")")) {
                if (elem.tail.head == null) {
                    elem.tail.head = ",";
                } else {
                }
                if (elem.tail.head == "|") {
                    var list elem3;
                    elem3 = al_list5(null, null, null, null, null);
                    al_create_arc(elem, elem3, null);
                    al_create_arc(elem3, elem2, null);
                } else {
                    al_create_arc(elem, elem2, null);
                }
                return elem;
            } else {
            }
            if (elem.tail.head) {
                if (al_file_match_str(in, elem.tail.head)) {
                    if (elem.tail.head == "|") {
                        var list elem3;
                        elem3 = al_list5(null, null, null, null, null);
                        al_create_arc(elem, elem3, null);
                        al_create_arc(elem3, elem2, null);
                    } else {
                        al_create_arc(elem, elem2, null);
                    }
                    continue;
                } else {
                    error_log("\'" + elem.tail.head + "\' expected.");
                    return null;
                }
            } else {
                if (al_file_match_str(in, "|")) {
                    elem.tail.head = "|";
                    var list elem3;
                    elem3 = al_list5(null, null, null, null, null);
                    al_create_arc(elem, elem3, null);
                    al_create_arc(elem3, elem2, null);
                    continue;
                } else {
                }
                if (al_file_match_str(in, ",")) {
                    elem.tail.head = ",";
                    al_create_arc(elem, elem2, null);
                    continue;
                } else {
                }
            }
        }
    } else {
        if (elem2 = load_elem2(in)) {
            return elem2;
        } else {
            error_log("<elem2> expected.");
            return null;
        }
    }
}
end_body
member
public: list load_elem2(file in);
body
{
    var list elem;
    if (elem = load_elem_empty_any(in)) {
        return elem;
    } else {
    }
    if (elem = load_elem_tag(in)) {
        return elem;
    } else {
    }
    if (elem = load_elem_data(in)) {
        return elem;
    } else {
    }
    return null;
}
end_body
member
public: list load_elem_tag(file in);
body
{
    var list tag, elem, elem2;
    if (tag = al_file_read(in, "xident")) {
        if (elem = al_dst_node(elems, tag)) {
            elem2 = al_list_misc("copy", elem, null);
            al_create_arc(elem, elem2, "$refer");
            return elem2;
        } else {
            error_log("element not found (tag = \'" + tag + ").");
            return null;
        }
    } else {
        return null;
    }
}
end_body
member
public: list load_elem_empty_any(file in);
body
{
    var list ident;
    var integer pos;
    pos = al_file_manip("curr_pos", in, null);
    if (ident = al_file_read(in, "ident")) {
        if (ident == "EMPTY" || ident == "ANY") {
            return al_list5("elem", ident, null, "", null);
        } else {
        }
        al_file_manip("back", in, pos);
    } else {
    }
    return null;
}
end_body
member
public: list load_elem_data(file in);
body
{
    if (al_file_match_str(in, "#PCDATA")) {
        return al_list5("elem", "#PCDATA", null, "", null);
    } else {
    }
    return null;
}
end_body
member
public: list add_attr(list elem, file in);
body
{
    var list name, kind, type, default_value;
    loop {
        if (name = al_file_read(in, "xident")) {
        } else {
            return null;
        }
        if (al_file_match_str(in, "(")) {
            var list tag;
            kind = load_attr_choice(in);
            if (al_file_match_str(in, ")")) {
            } else {
                error_log("\')\' expected at attribute kind.");
                return "\')\' expected at attribute kind.";
            }
        } else {
            if (kind = al_file_read(in, "string")) {
            } else {
                error_log("attribute kind expected.");
                return "attribute kind expected.";
            }
        }
        if (al_file_match_str(in, "#")) {
            if (type = al_file_read(in, "ident")) {
            } else {
                error_log("attribute type expected.");
                return "attribute type expected.";
            }
            type = "#" + type;
        } else {
            if (type = al_file_read(in, "single_quote_string")) {
            } else {
                if (type = al_file_read(in, "quote_string")) {
                } else {
                    error_log("attribute type expected.");
                    return "attribute type expected.";
                }
            }
        }
        if (type == "#FIXED") {
            if (default_value = al_file_read(in, "quote_string")) {
            } else {
                error_log("attribute default_value expected.");
                return "attribute default_value expected.";
            }
        } else {
        }
        var list attr;
        attr = al_list5("attr", name, kind, type, default_value);
        al_create_arc(elem, attr, "attr");
    }
}
end_body
member
public: list attr;
member
public: list load_attr_choice(file in);
body
{
    var list kind;
    var string value;
    kind = al_cons("|", null);
    loop {
        if (value = al_file_read(in, "xident")) {
            al_create_arc(kind, al_cons(null, null), value);
        } else {
            return kind;
        }
        if (al_file_match_str(in, "|")) {
            continue;
        } else {
            return kind;
        }
    }
}
end_body
member
public: void normalize();
body
{
    var list itr, elem, itr2, elem2, itr3, dst, attr, opt, all_opt;
    itr = al_dst_itr(elems);
    loop {
        if (elem = al_next(itr)) {
        } else {
            break;
        }
        {
            all_opt = 1;
            itr3 = al_dst_itr(elem);
            loop {
                if (dst = al_next(itr3)) {
                } else {
                    break;
                }
                attr = al_arc_a(itr3);
                if (al_is_type(attr, "string") && al_strlen(attr) > 0 && al_get_char(attr, 0) == '$') {
                    continue;
                } else {
                }
                if (dst.head == "elem") {
                    if (dst.tail.tail.head) {
                        // elem tag
                        opt = dst.tail.tail.tail.head;
                        if (opt == "?" || opt == "*") {
                        } else {
                            all_opt = null;
                        }
                    } else {
                        // not elem tag
                        if (dst.tail.tail.tail.tail.head) {
                        } else {
                            all_opt = null;
                        }
                    }
                } else {
                }
            }
            elem.tail.tail.tail.tail.head = all_opt;
        }
        itr2 = al_dst_itr(elem);
        loop {
            if (elem2 = al_next_a(itr2, "$refer")) {
            } else {
                break;
            }
            elem2.tail.tail.tail.tail.head = all_opt;
            itr3 = al_dst_itr(elem);
            loop {
                if (dst = al_next(itr3)) {
                } else {
                    break;
                }
                attr = al_arc_a(itr3);
                if (attr == "$refer") {
                    continue;
                } else {
                }
                al_create_arc(elem2, dst, attr);
            }
            al_remove(itr2);
        }
    }
}
end_body
member
public: list check_recursive(list elem, list tags);
body
{
    var string tag;
    var list recursive, itr, elem2, ret;
    if (elem.head == "elem") {
        if (tag = elem.tail.tail.head) {
            if (al_dst_node(tags, tag)) {
                recursive = 1;
            } else {
            }
        } else {
        }
    } else {
    }
    if (recursive) {
        al_set_dst_node(elem, "$recursive", 0);
        return tag;
    } else {
    }
    al_create_arc(tags = al_copy(tags), 0, tag);
    itr = al_dst_itr(elem);
    loop {
        if (elem2 = al_next_a(itr, null)) {
        } else {
            break;
        }
        if (al_dst_node(elem2, "$recursive")) {
            continue;
        } else {
        }
        var list tag2;
        if (tag2 = check_recursive(elem2, tags)) {
            if (ret) {
            } else {
                ret = al_cons(null, null);
            }
            al_create_arc(ret, tag2, tag2);
        } else {
            if (data_duplicate) {
                al_arc_dst(itr, al_copy(elem2));
            } else {
            }
        }
    }
    if (al_dst_node(elem, "$recursive") != 0) {
        if (ret) {
            if (tag = elem.tail.tail.head) {
                if (check_recursive(ret, tag)) {
                    al_set_dst_node(elem, "$recursive", 1);
                } else {
                    al_set_dst_node(elem, "$recursive", 2);
                }
            } else {
                al_set_dst_node(elem, "$recursive", 2);
            }
        } else {
        }
    } else {
    }
    return ret;
}
end_body
member
public: list check_recursive(list ret, string tag);
body
{
    if (al_is_type(ret, "string")) {
        if (tag == ret) {
            return 1;
        } else {
            return null;
        }
    } else {
    }
    var list itr, ret2;
    itr = al_dst_itr(ret);
    loop {
        if (ret2 = al_next(itr)) {
        } else {
            break;
        }
        if (check_recursive(ret2, tag)) {
            return 1;
        } else {
        }
    }
    return null;
}
end_body
member
public: list data_duplicate;
member
public: void error_log(string s);
body
{
    if (log_level >= 10) {
        al_print("[Error] " + s + "\n");
    } else {
    }
}
end_body
member
public: void warning_log(string s);
body
{
    if (log_level >= 20) {
        al_print("[Warning] " + s + "\n");
    } else {
    }
}
end_body
member
public: void info_log(string s);
body
{
    if (log_level >= 30) {
        al_print("[Info] " + s + "\n");
    } else {
    }
}
end_body
member
public: list log_level;
member
public: static void attach_content_validation_data(list dtd, string csv_filename);
body
{
    if (al_dst_node(dtd, "$validation_data")) {
        return;
    } else {
    }
    var file in, in2;
    var list data, node, dics, dic, ret, itr;
    var string type_dic, xpath;
    var string dic_id, value;
    var string type, repr;
    var integer min, max, idx;
    dics = al_cons(null, null);
    if (in = al_file_open(csv_filename, "r")) {
    } else {
        var AlException ex;
        ex = new AlException;
        ex.msg = "can\'t open " + (string)csv_filename;
        throw ex;
    }
    loop {
        if (data = al_file_read(in, "csv") && data != 1) {
        } else {
            break;
        }
        type_dic = al_dst_node(data, 1);
        if (type_dic == "type") {
            xpath = al_dst_node(data, 2);
            idx = al_search_str(xpath, 1, "/");
            xpath = al_tail_str(xpath, idx + 1);
            ret = al_cons(null, null);
            DtdLoader::get_node(ret, dtd, xpath);
            itr = al_dst_itr(ret);
            if (al_count(itr) == 0) {
                var AlException ex;
                ex = new AlException;
                ex.msg = "dtd node not found: validation-csv-file = " + (string)csv_filename + ", xpath = " + (string)xpath;
                throw ex;
            } else {
            }
            type = al_dst_node(data, 3);
            min = al_dst_node(data, 4);
            if (min != "") {
                min = (integer)min;
            } else {
            }
            max = al_dst_node(data, 5);
            if (max != "") {
                max = (integer)max;
            } else {
            }
            repr = al_dst_node(data, 6);
            loop {
                if (node = al_next(itr)) {
                } else {
                    break;
                }
                if (al_dst_node(node, "$type")) {
                } else {
                    al_create_arc(node, al_list4(type, min, max, repr), "$type");
                }
            }
        } else {
        }
        if (type_dic == "dic") {
            xpath = al_dst_node(data, 2);
            idx = al_search_str(xpath, 1, "/");
            xpath = al_tail_str(xpath, idx + 1);
            ret = al_cons(null, null);
            DtdLoader::get_node(ret, dtd, xpath);
            itr = al_dst_itr(ret);
            if (al_count(itr) == 0) {
                var AlException ex;
                ex = new AlException;
                ex.msg = "dtd node not found: validation-csv-file = " + (string)csv_filename + ", xpath = " + (string)xpath;
                throw ex;
            } else {
            }
            dic_id = al_dst_node(data, 3);
            if (dic = al_dst_node(dics, dic_id)) {
            } else {
                in2 = al_file_open(csv_filename, "r");
                loop {
                    if (data = al_file_read(in2, "csv") && data != 1) {
                    } else {
                        var AlException ex;
                        ex = new AlException;
                        ex.msg = "unexpected EOF: validation-csv-file = " + (string)csv_filename + ", xpath = " + (string)xpath;
                        throw ex;
                    }
                    type_dic = al_dst_node(data, 1);
                    if (type_dic == "end-" + dic_id) {
                        break;
                    } else {
                    }
                    if (type_dic != dic_id) {
                        continue;
                    } else {
                    }
                    value = al_dst_node(data, 2);
                    dic = al_cons(value, dic);
                }
                al_create_arc(dics, dic, dic_id);
            }
            loop {
                if (node = al_next(itr)) {
                } else {
                    break;
                }
                if (al_dst_node(node, "$dic")) {
                } else {
                    al_create_arc(node, dic, "$dic");
                }
            }
        } else {
        }
    }
    al_create_arc(dtd, al_cons(null, null), "$validation_data");
}
end_body
member
public: static void get_node(list ret, list elem, string xpath);
body
{
    if (xpath == "" && elem.tail.head == "#PCDATA") {
        al_create_arc(ret, elem, null);
        return;
    } else {
    }
    var integer idx;
    var string h, t;
    idx = al_search_str(xpath, 0, "/");
    if (idx >= 0) {
        h = al_substr(xpath, 0, idx);
        t = al_tail_str(xpath, idx + 1);
    } else {
        h = xpath;
        t = "";
    }
    var list choice, itr, elem2;
    var string tag;
    choice = (elem.tail.head == "|");
    itr = al_dst_itr(elem);
    loop {
        if (elem2 = al_next_a(itr, null)) {
        } else {
            break;
        }
        if (choice) {
            elem2 = al_dst_node(elem2, null);
        } else {
        }
        if (elem2.head == "elem") {
            tag = elem2.tail.tail.head;
            if (tag) {
                if (tag == h) {
                    DtdLoader::get_node(ret, elem2, t);
                } else {
                }
            } else {
                DtdLoader::get_node(ret, elem2, xpath);
            }
        } else {
        }
        if (elem2.head == "attr") {
            if ("@" + elem2.tail.head == h && t == "") {
                al_create_arc(ret, elem2, null);
            } else {
            }
        } else {
        }
    }
}
end_body
class ExtendedDtdLoader
member
public: list read_element(file in);
body
{
    var string tag, str;
    var list elem;
    elems = al_cons(null, null);
    loop {
        if (al_file_match_str(in, "<!ELEMENT")) {
            if (tag = al_file_read(in, "xident")) {
            } else {
                error_log("element tag name expected.");
                return "element tag name expected.";
            }
            info_log("element tag: " + tag);
            if (elem = al_dst_node(elems, tag)) {
            } else {
                elem = al_list5("elem", null, tag, "", null);
                al_create_arc(elems, elem, tag);
            }
            if (al_file_read(in, al_list2("find", ">"))) {
            } else {
                error_log("unexpected EOF (11)");
                return "unexpected EOF (11)";
            }
            continue;
        } else {
        }
        if (al_file_match_str(in, "<!ATTLIST")) {
            if (al_file_read(in, al_list2("find", ">"))) {
            } else {
                error_log("unexpected EOF (12)");
                return "unexpected EOF (12)";
            }
            continue;
        } else {
        }
        if (al_file_match_str(in, "<!METAINFO")) {
            if (al_file_read(in, al_list2("find", ">"))) {
            } else {
                error_log("unexpected EOF (13)");
                return "unexpected EOF (13)";
            }
            continue;
        } else {
        }
        if (str = al_file_read(in, "string")) {
            error_log("unexpected token\'" + str + "\'");
            return "unexpected token\'" + str + "\'";
        } else {
        }
        return null;
    }
}
end_body
member
public: list elem_attr(file in);
body
{
    var string tag, str;
    var list elem, elem2, itr, tags, all_opt;
    loop {
        if (al_file_match_str(in, "<!ELEMENT")) {
            if (tag = al_file_read(in, "xident")) {
            } else {
                error_log("element tag name expected.");
                return "element tag name expected.";
            }
            info_log("element tag: " + tag);
            if (elem = al_dst_node(elems, tag)) {
            } else {
                error_log("element tag \'" + tag + "\' not found.");
                return "element tag \'" + tag + "\' not found.";
            }
            if (elem2 = load_elem(in)) {
                al_create_arc(elem, elem2, null);
            } else {
                error_log("element definition of tag name \'" + tag + "\' is illegal.");
                return "element definition of tag name \'" + tag + "\' is illegal.";
            }
            if (al_file_match_str(in, ">")) {
            } else {
                error_log("\'>\' expected at !ELEMENT (tag = " + tag + ").");
                return "\'>\' expected at !ELEMENT (tag = " + tag + ").";
            }
            continue;
        } else {
        }
        if (al_file_match_str(in, "<!ATTLIST")) {
            if (tag = al_file_read(in, "xident")) {
            } else {
                error_log("attlist tag name expected.");
                return "attlist tag name expected.";
            }
            info_log("attlist tag: " + tag);
            if (elem = al_dst_node(elems, tag)) {
            } else {
                error_log("attlist tag \'" + tag + "\' not found.");
                return "attlist tag \'" + tag + "\' not found.";
            }
            if (add_attr(elem, in)) {
                error_log("attr definition of tag name \'" + tag + "\' is illegal.");
                return "attr definition of tag name \'" + tag + "\' is illegal.";
            } else {
            }
            if (al_file_match_str(in, ">")) {
            } else {
                error_log("\'>\' expected at !ATTLIST (tag = " + tag + ").");
                return "\'>\' expected at !ATTLIST (tag = " + tag + ").";
            }
            continue;
        } else {
        }
        if (al_file_match_str(in, "<!METAINFO")) {
            var string name, value;
            if (tag = al_file_read(in, "xident")) {
            } else {
                error_log("metainfo tag name expected.");
                return "metainfo tag name expected.";
            }
            info_log("metainfo tag: " + tag);
            if (elem = al_dst_node(elems, tag)) {
            } else {
                error_log("metainfo tag \'" + tag + "\' not found.");
                return "metainfo tag \'" + tag + "\' not found.";
            }
            if (name = al_file_read(in, "quote_string")) {
            } else {
                error_log("metainfo property name expected (tag = " + tag + ").");
                return "metainfo property name expected (tag = " + tag + ").";
            }
            if (value = al_file_read(in, "quote_string")) {
            } else {
                error_log("metainfo property value expected (tag = " + tag + ").");
                return "metainfo property value expected (tag = " + tag + ").";
            }
            al_create_arc(elem, value, "$" + name);
            if (al_file_match_str(in, ">")) {
            } else {
                error_log("\'>\' expected at !METAINFO (tag = " + tag + ").");
                return "\'>\' expected at !METAINFO (tag = " + tag + ").";
            }
            continue;
        } else {
        }
        if (str = al_file_read(in, "string")) {
            error_log("unexpected token\'" + str + "\'");
            return "unexpected token\'" + str + "\'";
        } else {
        }
        itr = al_dst_itr(elems);
        root_elem = al_next(itr);
        data_duplicate = (al_dst_node(root_elem, "$data.duplicate") != "false");
        normalize();
        elems = null;
        tags = al_cons(null, null);
        check_recursive(root_elem, tags);
        return null;
    }
}
end_body
member
public: list add_attr(list elem, file in);
body
{
    var list name, kind, type, default_value;
    loop {
        if (name = al_file_read(in, "xident")) {
        } else {
            return null;
        }
        if (al_file_match_str(in, "(")) {
            var list tag;
            kind = load_attr_choice(in);
            if (al_file_match_str(in, ")")) {
            } else {
                error_log("\')\' expected at attribute kind.");
                return "\')\' expected at attribute kind.";
            }
        } else {
            if (kind = al_file_read(in, "string")) {
            } else {
                error_log("attribute kind expected.");
                return "attribute kind expected.";
            }
        }
        if (al_file_match_str(in, "#")) {
            if (type = al_file_read(in, "ident")) {
            } else {
                error_log("attribute type expected.");
                return "attribute type expected.";
            }
            type = "#" + type;
        } else {
            if (type = al_file_read(in, "single_quote_string")) {
            } else {
                if (type = al_file_read(in, "quote_string")) {
                } else {
                    error_log("attribute type expected.");
                    return "attribute type expected.";
                }
            }
        }
        if (type == "#FIXED") {
            if (default_value = al_file_read(in, "quote_string")) {
            } else {
                error_log("attribute default_value expected.");
                return "attribute default_value expected.";
            }
        } else {
        }
        var list attr;
        attr = al_list5("attr", name, kind, type, default_value);
        al_create_arc(elem, attr, "attr");
        loop {
            if (al_file_match_str(in, "METAINFO")) {
                var string name2, value2;
                if (name2 = al_file_read(in, "quote_string")) {
                } else {
                    error_log("metainfo property name expected (attr = " + name + ").");
                    return "metainfo property name expected (attr = " + name + ").";
                }
                if (value2 = al_file_read(in, "quote_string")) {
                } else {
                    error_log("metainfo property value expected (attr = " + name + ").");
                    return "metainfo property value expected (attr = " + name + ").";
                }
                al_create_arc(attr, value2, "$" + name2);
            } else {
                break;
            }
        }
    }
}
end_body
end_class
end_class
class DtdItr
member
public: void Reset(list node0);
body
{
    var list itr, info;
    var string tag;
    itr = al_dst_itr(node = node0);
    stack = al_cons(al_list6("main", itr, node0, "attr", null, al_cons(null, null)), null);
    if (node0.tail.head == null) {
        tag = node0.tail.tail.head;
        abs_xpath = "/" + tag;
        rel_xpath = tag;
        if (handler) {
            handler.startElement(tag);
        } else {
        }
    } else {
        abs_xpath = "";
        rel_xpath = "";
    }
    info = al_list2(abs_xpath, rel_xpath);
    xpath_stack = al_cons(info, null);
    ns_stack = al_cons(null, null);
    type = "begin";
}
end_body
member
public: list Next(list skip_flag);
body
{
    if (type == "elem2") {
        var list info;
        info = xpath_stack.head;
        abs_xpath = info.head;
        rel_xpath = info.tail.head;
        xpath_stack = xpath_stack.tail;
    } else {
    }
    recursive_expanded = null;
    attr = null;
    var list itr, node2, info, kind, attr2;
    if (all_tag && type == "begin") {
        type = "elem3";
        opt = "";
        return type;
    } else {
    }
    if (type == "end") {
        return type;
    } else {
    }
    if (type == "end_repetition") {
        repetition_stack = repetition_stack.tail;
        if (pop()) {
            return type;
        } else {
        }
    } else {
    }
    if (type == "end_optional") {
        if (pop()) {
            return type;
        } else {
        }
    } else {
    }
    if (type == "end_choice") {
        node2 = stack.head.tail.tail.head;
        opt = node2.tail.tail.tail.head;
        if (opt == "*" || opt == "+") {
            stack.head.head = type = "end_repetition";
            return type;
        } else {
            if (opt == "?") {
                stack.head.head = type = "end_optional";
                return type;
            } else {
            }
        }
        if (pop()) {
            return type;
        } else {
        }
    } else {
    }
    if (type == "end_case") {
        stack = stack.tail;
        itr = stack.head.tail.head;
        if (node = al_next_a(itr, null)) {
            itr = al_dst_itr(node);
            stack = al_cons(al_list6(null, itr, node, "attr", null, al_cons(null, null)), stack);
            stack.head.head = type = "case";
            return type;
        } else {
            stack.head.head = type = "end_choice";
            return type;
        }
    } else {
    }
    if (type == "end_all_opt") {
        if (stack.head.head == "case") {
            type = "end_case";
            return type;
        } else {
        }
    } else {
    }
    if (type == "repetition") {
        info = al_list6(stack, node, opt, abs_xpath, xpath_stack, repetition_tag);
        repetition_stack = al_cons(info, repetition_stack);
        rel_xpath = "";
        node2 = stack.head.tail.tail.head;
        if (node2.tail.head == "|") {
            stack.head.head = type = "choice";
            return type;
        } else {
        }
    } else {
    }
    if (type == "choice") {
        itr = stack.head.tail.head;
        if (node = al_next_a(itr, null)) {
            itr = al_dst_itr(node);
            stack = al_cons(al_list6(null, itr, node, "attr", null, al_cons(null, null)), stack);
            stack.head.head = type = "case";
            return type;
        } else {
            stack.head.head = type = "end_choice";
            return type;
        }
    } else {
    }
    if (type == "all_opt") {
        node = stack.head.tail.tail.head;
        opt = node.tail.tail.tail.head;
        if (opt == "*" || opt == "+") {
            if (node.tail.head == null) {
                repetition_tag = node.tail.tail.head;
            } else {
                repetition_tag = null;
            }
            stack.head.head = type = "repetition";
            return type;
        } else {
        }
        if (opt == "?") {
            stack.head.head = type = "optional";
            return type;
        } else {
        }
        if (node.tail.head == "|") {
            stack.head.head = type = "choice";
            return type;
        } else {
        }
        if (al_dst_node(node, null) == null) {
            type = "elem";
            attr = null;
            return type;
        } else {
            if (all_tag && node.tail.tail.head) {
                type = "elem3";
                attr = null;
                return type;
            } else {
            }
        }
    } else {
    }
    loop {
        itr = stack.head.tail.head;
        kind = stack.head.tail.tail.tail.head;
        if (kind == "attr") {
            if (node = al_next_a(itr, "attr")) {
                attr = node.tail.head;
                if (attr == "xml:lang") {
                    continue;
                } else {
                }
                opt = node.tail.tail.tail.head;
                if (opt == "#REQUIRED") {
                    opt = "";
                } else {
                    opt = "?";
                }
                if (al_str_misc("starts_with", attr, "xmlns")) {
                    // push namespace stack
                    var string ns_name, ns_url;
                    if (al_strlen(attr) >= 6) {
                        ns_name = al_tail_str(attr, 6);
                    } else {
                        ns_name = al_copy("");
                    }
                    if (ns_url = node.tail.tail.tail.tail.head) {
                    } else {
                        ns_url = "";
                    }
                    var list itr2;
                    itr2 = al_dst_itr(ns_stack);
                    if (node2 = al_next(itr2)) {
                        al_insert_before(ns_stack, node2, ns_name, ns_url);
                    } else {
                        al_create_arc(ns_stack, ns_name, ns_url);
                    }
                    al_create_arc(ns_name, node, "$attr_node");
                    al_create_arc(stack.head.tail.tail.tail.tail.tail.head, ns_name, ns_name);
                    if (al_dst_node(node, "$scope") != "global") {
                        if (handler) {
                            handler.setNamespace(ns_name);
                        } else {
                        }
                    } else {
                    }
                } else {
                }
                type = "attr";
                return type;
            } else {
                stack.head.tail.tail.tail.head = null;
                node2 = stack.head.tail.tail.head;
                stack.head.tail.head = itr = al_dst_itr(node2);
                {
                    if (al_dst_node(node2, "$treat.below.as.text") == "true") {
                        al_prev(itr);
                        type = "as_text";
                        return type;
                    } else {
                    }
                }
            }
            continue;
        } else {
        }
        if (node = al_next_a(itr, null)) {
            if (skip_flag) {
                if (al_dst_node(node, "$recursive") == 0) {
                    if (stack.head.head == "case") {
                        type = "end_case";
                        return type;
                    } else {
                    }
                    // continue;
                    info = al_list2(abs_xpath, rel_xpath);
                    xpath_stack = al_cons(info, xpath_stack);
                    tag = node.tail.tail.head;
                    abs_xpath = abs_xpath + "/" + tag;
                    if (rel_xpath == "") {
                        rel_xpath = tag;
                    } else {
                        rel_xpath = rel_xpath + "/" + tag;
                    }
                    type = "elem2";
                    attr = null;
                    return type;
                } else {
                }
                if (skip_flag == 1) {
                    if (stack.head.head == "case") {
                    } else {
                        continue;
                    }
                } else {
                }
            } else {
            }
            expand_recursive();
            itr = al_dst_itr(node);
            stack = al_cons(al_list6(null, itr, node, "attr", null, al_cons(null, null)), stack);
            if (node.tail.head == null) {
                info = al_list2(abs_xpath, rel_xpath);
                xpath_stack = al_cons(info, xpath_stack);
                tag = node.tail.tail.head;
                abs_xpath = abs_xpath + "/" + tag;
                if (rel_xpath == "") {
                    rel_xpath = tag;
                } else {
                    rel_xpath = rel_xpath + "/" + tag;
                }
                if (handler) {
                    handler.startElement(tag);
                } else {
                }
            } else {
            }
            opt = node.tail.tail.tail.head;
            {
                var list is_tag, all_opt;
                is_tag = node.tail.tail.head;
                all_opt = node.tail.tail.tail.tail.head;
                if (is_tag && all_opt && (opt == "" || opt == "+")) {
                    stack.head.tail.tail.tail.tail.head = "all_opt";
                    type = "all_opt";
                    return type;
                } else {
                }
            }
            if (opt == "*" || opt == "+") {
                if (node.tail.head == null) {
                    repetition_tag = tag;
                } else {
                    repetition_tag = null;
                }
                stack.head.head = type = "repetition";
                return type;
            } else {
            }
            if (opt == "?") {
                stack.head.head = type = "optional";
                return type;
            } else {
            }
            if (node.tail.head == "|") {
                stack.head.head = type = "choice";
                return type;
            } else {
            }
            if (al_dst_node(node, null) == null) {
                type = "elem";
                attr = null;
                return type;
            } else {
                if (all_tag && node.tail.tail.head) {
                    type = "elem3";
                    attr = null;
                    return type;
                } else {
                }
            }
        } else {
            node2 = stack.head.tail.tail.head;
            if (node2.head == "elem" && node2.tail.head == null) {
                info = xpath_stack.head;
                if (abs_xpath == info.head) {
                    tag = al_tail_str(abs_xpath, 1);
                } else {
                    tag = al_tail_str(abs_xpath, al_strlen(info.head) + 1);
                }
                abs_xpath = info.head;
                rel_xpath = info.tail.head;
                xpath_stack = xpath_stack.tail;
                repetition_tag = null;
                if (handler) {
                    handler.endElement(tag);
                } else {
                }
                {
                    // pop namespace stack
                    var string ns_name;
                    var list itr2, itr3;
                    itr2 = al_dst_itr(stack.head.tail.tail.tail.tail.tail.head);
                    loop {
                        if (ns_name = al_next(itr2)) {
                        } else {
                            break;
                        }
                        itr3 = al_dst_itr(ns_stack);
                        loop {
                            if (al_next(itr3) == ns_name) {
                            } else {
                                break;
                            }
                            al_remove(itr3);
                            break;
                        }
                    }
                    itr3 = al_dst_itr(ns_stack);
                    loop {
                        if (ns_name = al_next(itr3)) {
                        } else {
                            if (handler) {
                                handler.setNamespace(ns_name);
                            } else {
                            }
                            break;
                        }
                        if (node2 = al_dst_node(ns_name, "$attr_node") && al_dst_node(node2, "$scope") == "global") {
                            continue;
                        } else {
                        }
                        if (handler) {
                            handler.setNamespace(ns_name);
                        } else {
                        }
                        break;
                    }
                }
            } else {
            }
            kind = stack.head.head;
            if (kind == "repetition") {
                type = "end_repetition";
                return type;
            } else {
            }
            if (kind == "optional") {
                type = "end_optional";
                return type;
            } else {
            }
            if (kind == "main") {
                stack = stack.tail;
                type = "end";
                return type;
            } else {
            }
            if (pop()) {
                return type;
            } else {
            }
            if (stack.head.head == "case") {
                type = "end_case";
                return type;
            } else {
            }
        }
    }
}
end_body
member
public: list pop();
body
{
    if (stack.head.tail.tail.tail.tail.head == "all_opt") {
        type = "end_all_opt";
        attr = tag = null;
        stack = stack.tail;
        return 1;
    } else {
        stack = stack.tail;
        return null;
    }
}
end_body
member
public: list stack;
member
public: list type;
member
public: list node;
member
public: list opt;
member
public: void ContinueRepetition();
body
{
    var list itr, info, node2;
    info = repetition_stack.head;
    repetition_stack = repetition_stack.tail;
    stack = info.head;
    node = info.tail.head;
    opt = info.tail.tail.head;
    abs_xpath = info.tail.tail.tail.head;
    xpath_stack = info.tail.tail.tail.tail.head;
    repetition_tag = info.tail.tail.tail.tail.tail.head;
    node2 = stack.head.tail.tail.head;
    itr = al_dst_itr(node2);
    stack.head.tail.head = itr;
    stack.head.head = type = "repetition";
    stack.head.tail.tail.tail.head = "attr";
    if (handler && repetition_tag) {
        handler.startElement(repetition_tag);
    } else {
    }
}
end_body
member
public: void BreakRepetition();
body
{
    var integer count;
    count = 1;
    loop {
        if (type == "end_repetition") {
            count = count - 1;
            if (count == 0) {
                break;
            } else {
            }
        } else {
        }
        Next((list)1);
        if (type == "end") {
            al_print("%%% BreakRepetition: end appears during finding end_repetition.\n");
            break;
        } else {
        }
        if (type == "repetition") {
            count = count + 1;
        } else {
        }
    }
}
end_body
member
public: list repetition_stack;
member
public: string abs_xpath;
member
public: string rel_xpath;
member
public: string attr;
member
public: string tag;
member
public: list xpath_stack;
member
public: void expand_recursive();
body
{
    if (al_dst_node(node, "$recursive") == 0) {
    } else {
        return;
    }
    recursive_expanded = 1;
    var list node2, itr, elem, itr2, elem2;
    node2 = al_copy(node);
    mark(node2);
    unmark(node2);
    al_graph_misc("mark", node2, null);
    itr = al_src_itr(node2);
    loop {
        if (elem = al_next(itr)) {
        } else {
            break;
        }
        al_arc_dst(itr, node);
    }
    itr = al_src_itr(node);
    loop {
        if (elem = al_next(itr)) {
        } else {
            break;
        }
        if (al_graph_misc("is_marked", elem, null)) {
            continue;
        } else {
        }
        al_arc_dst(itr, node2);
    }
    itr = al_dst_itr(node);
    itr2 = al_dst_itr(node2);
    loop {
        if (al_next(itr)) {
        } else {
            break;
        }
        elem2 = al_next(itr2);
        al_arc_dst(itr, elem2);
    }
    al_graph_misc("unmark", node2, null);
    node = node2;
}
end_body
member
public: void mark(list elem);
body
{
    if (al_dst_node(elem, "$mark")) {
        return;
    } else {
    }
    al_set_dst_node(elem, "$mark", "mark");
    if (al_dst_node(elem, "$recursive") == 0) {
        al_set_dst_node(elem, "$recursive", 1);
    } else {
    }
    var list itr, elem2;
    itr = al_dst_itr(elem);
    loop {
        if (elem2 = al_next_a(itr, null)) {
        } else {
            break;
        }
        mark(elem2);
    }
}
end_body
member
public: void unmark(list elem);
body
{
    if (al_dst_node(elem, "$mark")) {
    } else {
        return;
    }
    al_set_dst_node(elem, "$mark", null);
    var list itr, elem2;
    itr = al_dst_itr(elem);
    loop {
        if (elem2 = al_next_a(itr, null)) {
        } else {
            break;
        }
        unmark(elem2);
    }
}
end_body
member
public: list recursive_expanded;
member
public: string repetition_tag;
member
public: DtdHandler handler;
member
public: DtdItr Copy();
body
{
    var DtdItr itr;
    itr = new DtdItr;
    itr.stack = stack_copy(stack);
    itr.type = type;
    itr.node = node;
    itr.opt = opt;
    itr.repetition_stack = repetition_stack_copy(repetition_stack);
    itr.abs_xpath = abs_xpath;
    itr.rel_xpath = rel_xpath;
    itr.attr = attr;
    itr.xpath_stack = xpath_stack;
    itr.repetition_tag = repetition_tag;
    itr.ns_stack = al_copy(ns_stack);
    return itr;
}
end_body
member
public: list stack_copy(list stack);
body
{
    if (stack) {
    } else {
        return null;
    }
    var list info, info2;
    info = stack.head;
    info2 = al_list6(info.head, al_copy(info.tail.head), info.tail.tail.head, info.tail.tail.tail.head, info.tail.tail.tail.tail.head, info.tail.tail.tail.tail.tail.head);
    return al_cons(info2, stack_copy(stack.tail));
}
end_body
member
public: list repetition_stack_copy(list repetition_stack);
body
{
    if (repetition_stack) {
    } else {
        return null;
    }
    var list info, info2;
    info = repetition_stack.head;
    info2 = al_list6(stack_copy(info.head), info.tail.head, info.tail.tail.head, info.tail.tail.tail.head, info.tail.tail.tail.tail.head, info.tail.tail.tail.tail.tail.head);
    return al_cons(info2, repetition_stack_copy(repetition_stack.tail));
}
end_body
member
public: list getFieldList();
body
{
    var DtdItr itr;
    var list field_list, type;
    var string path;
    itr = Copy();
    field_list = al_cons(null, null);
    loop {
        type = itr.Next((list)2);
        if (type == "end_repetition" || type == "end") {
            break;
        } else {
        }
        if (type == "elem" || type == "all_opt") {
            path = itr.rel_xpath;
            al_create_arc(field_list, path, path);
            continue;
        } else {
        }
        if (type == "attr") {
            if (rel_xpath == "") {
                path = "@" + itr.attr;
            } else {
                path = itr.rel_xpath + "/@" + itr.attr;
            }
            al_create_arc(field_list, path, path);
            continue;
        } else {
        }
        if (type == "optional" || type == "end_optional") {
            continue;
        } else {
        }
        if (type == "choice" || type == "end_choice") {
            continue;
        } else {
        }
        if (type == "case" || type == "end_case") {
            continue;
        } else {
        }
        if (type == "repetition") {
            var integer count;
            count = 1;
            loop {
                type = itr.Next((list)1);
                if (type == "end") {
                    al_print("%%% getFieldList: end appears during finding end_repetition.\n");
                    break;
                } else {
                }
                if (type == "end_repetition") {
                    count = count - 1;
                    if (count == 0) {
                        break;
                    } else {
                    }
                } else {
                }
                if (type == "repetition") {
                    count = count + 1;
                } else {
                }
            }
            continue;
        } else {
        }
    }
    return field_list;
}
end_body
member
public: list getChildList();
body
{
    var DtdItr itr;
    var list child_list, type;
    var string path;
    itr = Copy();
    child_list = al_cons(null, null);
    loop {
        type = itr.Next((list)2);
        if (type == "end_repetition" || type == "end") {
            break;
        } else {
        }
        if (type == "elem") {
            continue;
        } else {
        }
        if (type == "attr") {
            continue;
        } else {
        }
        if (type == "optional" || type == "end_optional") {
            continue;
        } else {
        }
        if (type == "choice" || type == "end_choice") {
            continue;
        } else {
        }
        if (type == "case" || type == "end_case") {
            continue;
        } else {
        }
        if (type == "repetition") {
            al_create_arc(child_list, itr.rel_xpath, itr.rel_xpath);
            var integer count;
            count = 1;
            loop {
                type = itr.Next((list)1);
                if (type == "end") {
                    al_print("%%% getChildList: end appears during finding end_repetition.\n");
                    break;
                } else {
                }
                if (type == "end_repetition") {
                    count = count - 1;
                    if (count == 0) {
                        break;
                    } else {
                    }
                } else {
                }
                if (type == "repetition") {
                    count = count + 1;
                } else {
                }
            }
            continue;
        } else {
        }
    }
    return child_list;
}
end_body
member
public: DtdItr getChild(string xpath);
body
{
    var DtdItr itr;
    var list field_list, type;
    itr = Copy();
    field_list = al_cons(null, null);
    loop {
        type = itr.Next((list)2);
        if (type == "end_repetition" || type == "end") {
            break;
        } else {
        }
        if (type == "elem" || type == "attr") {
            continue;
        } else {
        }
        if (type == "optional" || type == "end_optional") {
            continue;
        } else {
        }
        if (type == "choice" || type == "end_choice") {
            continue;
        } else {
        }
        if (type == "case" || type == "end_case") {
            continue;
        } else {
        }
        if (type == "repetition") {
            if (itr.rel_xpath == xpath) {
                return itr;
            } else {
            }
            var integer count;
            count = 1;
            loop {
                type = itr.Next((list)1);
                if (type == "end") {
                    al_print("%%% getChild: end appears during finding end_repetition.\n");
                    break;
                } else {
                }
                if (type == "end_repetition") {
                    count = count - 1;
                    if (count == 0) {
                        break;
                    } else {
                    }
                } else {
                }
                if (type == "repetition") {
                    count = count + 1;
                } else {
                }
            }
            continue;
        } else {
        }
    }
    return null;
}
end_body
member
public: list getFieldList2();
body
{
    var DtdItr itr;
    var list field_list, pkey_list, fkey_list, rev_field_list, type;
    var string path;
    itr = Copy();
    field_list = al_cons(null, null);
    pkey_list = al_cons(null, null);
    fkey_list = al_cons(null, null);
    rev_field_list = al_cons(null, null);
    loop {
        type = itr.Next((list)2);
        if (type == "end_repetition" || type == "end") {
            break;
        } else {
        }
        if (type == "elem" || type == "all_opt") {
            if (tag2) {
            } else {
                tag2 = al_dst_node(al_str_misc("split", itr.rel_xpath, '/'), null);
            }
            path = itr.rel_xpath;
            al_create_arc(field_list, itr.tag, path);
            al_create_arc(rev_field_list, path, itr.tag);
            continue;
        } else {
        }
        if (type == "attr") {
            if (itr.attr == "primary-key") {
                al_create_arc(pkey_list, itr.tag, null);
            } else {
                al_create_arc(fkey_list, itr.attr, itr.tag);
            }
            continue;
        } else {
        }
        if (type == "optional" || type == "end_optional") {
            continue;
        } else {
        }
        if (type == "choice" || type == "end_choice") {
            continue;
        } else {
        }
        if (type == "case" || type == "end_case") {
            continue;
        } else {
        }
        if (type == "repetition") {
            var integer count;
            count = 1;
            loop {
                type = itr.Next((list)1);
                if (type == "end") {
                    al_print("%%% getFieldList2: end appears during finding end_repetition.\n");
                    break;
                } else {
                }
                if (type == "end_repetition") {
                    count = count - 1;
                    if (count == 0) {
                        break;
                    } else {
                    }
                } else {
                }
                if (type == "repetition") {
                    count = count + 1;
                } else {
                }
            }
            continue;
        } else {
        }
    }
    return al_list5(field_list, tag2, pkey_list, fkey_list, rev_field_list);
}
end_body
member
public: list getChild2(string xpath);
body
{
    var DtdItr itr;
    var list field_list, type;
    itr = Copy();
    field_list = al_cons(null, null);
    loop {
        type = itr.Next((list)2);
        if (type == "end_repetition" || type == "end") {
            break;
        } else {
        }
        if (type == "elem" || type == "attr") {
            continue;
        } else {
        }
        if (type == "optional" || type == "end_optional") {
            continue;
        } else {
        }
        if (type == "choice" || type == "end_choice") {
            continue;
        } else {
        }
        if (type == "case" || type == "end_case") {
            continue;
        } else {
        }
        if (type == "repetition") {
            if (itr.rel_xpath == xpath) {
                var list itr2;
                itr2 = al_dst_itr(al_str_misc("split", xpath, '/'));
                return al_list2(itr, al_prev(itr2));
            } else {
            }
            var integer count;
            count = 1;
            loop {
                type = itr.Next((list)1);
                if (type == "end") {
                    al_print("%%% getChild2: end appears during finding end_repetition.\n");
                    break;
                } else {
                }
                if (type == "end_repetition") {
                    count = count - 1;
                    if (count == 0) {
                        break;
                    } else {
                    }
                } else {
                }
                if (type == "repetition") {
                    count = count + 1;
                } else {
                }
            }
            continue;
        } else {
        }
    }
    return null;
}
end_body
member
public: list tag2;
member
public: list ns_stack;
member
public: list all_tag;
end_class
class DtdHandler
member
public: void startElement(string tag);
body
{
    al_print("startElement: tag = " + tag + "\n");
}
end_body
member
public: void endElement(string tag);
body
{
    al_print("endElement: tag = " + tag + "\n");
}
end_body
member
public: void setNamespace(string name);
body
{
    if (name) {
        al_print("setNamespace: name = " + name + "\n");
    } else {
        al_print("setNamespace: null is setted.\n");
    }
}
end_body
end_class
end_class
end_class
End
B 1358
N 1 L
N 2 S "DataMapper"
N 3 S "$gb"
N 4 L
N 5 L
N 6 S "f[^}bp[r["
N 7 S "$wnd_rect"
N 8 L
N 9 I 64
N 10 L
N 11 I 35
N 12 L
N 13 I 539
N 14 L
N 15 I 382
N 16 L
N 17 L
N 18 L
N 19 L
N 20 O TMGlyph
N 21 S "tm"
N 22 M 3 3 1. 0. 509. 0. 1. 0. 0. 0. 1.
N 23 S "child"
N 24 O AlVScrollBar
N 25 S "status"
N 26 I 10
N 27 S "left"
N 28 R 0.
N 29 S "top"
N 30 R 0.
N 31 S "right"
N 32 R 18.
N 33 S "bottom"
N 34 R 333.
N 35 S "face_color"
N 36 I 12632256
N 37 S "highlight_color"
N 38 I 16777215
N 39 S "shadow_color"
N 40 I 8421504
N 41 S "frame_color"
N 42 I 0
N 43 S "text_color"
N 44 I 0
N 45 S "text_bg_color"
N 46 I 12632256
N 47 S "direction"
N 48 I 1
N 49 S "delta1"
N 50 R 2.047244094488188
N 51 S "delta2"
N 52 R 27.26929133858268
N 53 S "pos"
N 54 R 0.
N 55 S "max"
N 56 R 273.
N 57 S "scrolls"
N 58 L
N 59 S "$scroll"
N 60 O FrameScrollGlyph
N 61 R 0.
N 62 R 0.
N 63 R 509.
N 64 R 333.
N 65 O GraphEditor
N 66 I 30
N 67 O SpIdxGlyph
N 68 R 0.
N 69 R 0.
N 70 R 3000.
N 71 R 3000.
N 72 S "selection"
N 73 L
N 74 S "nodes"
N 75 L
N 76 S "arcs"
N 77 L
N 78 S "labels"
N 79 L
N 80 S "$editor_id"
N 81 S "ed1.dat"
N 82 S "range_left"
N 83 S "range_top"
N 84 S "range_right"
N 85 S "range_bottom"
N 86 M 3 3 1. 0. 0. 0. 1. 0. 0. 0. 1.
N 87 R 509.
N 88 R 0.
N 89 R 527.
N 90 R 333.
N 91 L
N 92 I 1
N 93 L
N 94 I 0
N 95 L
N 96 I 0
N 97 L
N 98 L
N 99 I 2
N 100 L
N 101 I 0
N 102 L
N 103 I 0
N 104 L
N 105 L
N 106 I 3
N 107 L
N 108 I 0
N 109 L
N 110 I 18
N 111 L
N 112 L
N 113 I 0
N 114 L
N 115 I 1
N 116 L
N 117 I 18
N 118 L
N 119 O TMGlyph
N 120 M 3 3 1. 0. 0. 0. 1. 333. 0. 0. 1.
N 121 O AlHScrollBar
N 122 R 0.
N 123 R 0.
N 124 R 509.
N 125 R 18.
N 126 I 0
N 127 R 3.60497792051385
N 128 R 73.39735046166199
N 129 R 0.
N 130 R 449.
N 131 L
N 132 R 0.
N 133 R 333.
N 134 R 509.
N 135 R 351.
N 136 L
N 137 L
N 138 I 0
N 139 L
N 140 I 0
N 141 L
N 142 L
N 143 L
N 144 L
N 145 I 18
N 146 L
N 147 L
N 148 L
N 149 L
N 150 I 0
N 151 L
N 152 L
N 153 L
N 154 I 1
N 155 L
N 156 I 18
N 157 L
N 158 O TMGlyph
N 159 M 3 3 1. 0. 0. 0. 1. 0. 0. 0. 1.
N 160 R 0.
N 161 R 0.
N 162 R 509.
N 163 R 333.
N 164 L
N 165 L
N 166 L
N 167 I 0
N 168 L
N 169 L
N 170 L
N 171 L
N 172 I 0
N 173 L
N 174 L
N 175 L
N 176 L
N 177 I 18
N 178 L
N 179 L
N 180 L
N 181 L
N 182 I 18
N 183 L
N 184 L
N 185 I 10
N 186 L
N 187 S "vbar"
N 188 L
N 189 S "view"
N 190 L
N 191 L
N 192 L
N 193 S "hbar"
N 194 L
N 195 L
N 196 L
N 197 L
N 198 O SpIdxGlyph
N 199 R 0.
N 200 R 0.
N 201 R 527.
N 202 R 351.
N 203 S "allo_chg_glyph"
N 204 L
N 205 S "DataMapperView"
N 206 S "$gp"
N 207 L
N 208 L
N 209 S "vOP"
N 210 L
N 211 L
N 212 L
N 213 L
N 214 I 3
N 215 S "$refer"
N 216 L
N 217 I 1
N 218 S "$geom"
N 219 O TMGlyph
N 220 M 3 3 1. 0. 107. 0. 1. 46. 0. 0. 1.
N 221 O GpClass
N 222 I 16777215
N 223 I 8421504
N 224 I 0
N 225 I 0
N 226 I 0
N 227 I 20
N 228 I 20
N 229 I 16761024
N 230 R 107.
N 231 R 46.
N 232 R 127.
N 233 R 66.
N 234 L
N 235 I 1
N 236 O TMGlyph
N 237 M 3 3 1. 0. 107. 0. 1. 66. 0. 0. 1.
N 238 O MLabel
N 239 R 0.
N 240 R 0.
N 241 R 22.
N 242 R 16.
N 243 S "text"
N 244 S "GUI"
N 245 S "font_name"
N 246 S "lr SVbN"
N 247 S "font_height"
N 248 I 12
N 249 S "font_width"
N 250 I 0
N 251 S "font_color"
N 252 I 0
N 253 S "top_margin"
N 254 I 2
N 255 S "left_margin"
N 256 I 2
N 257 R 107.
N 258 R 66.
N 259 R 129.
N 260 R 82.
N 261 S "$gp_class"
N 262 L
N 263 L
N 264 O TMGlyph
N 265 M 3 3 1. 0. 147. 0. 1. 106. 0. 0. 1.
N 266 O GpClass
N 267 S "$child_data"
N 268 L
N 269 L
N 270 L
N 271 L
N 272 O TMGlyph
N 273 M 3 3 1. 0. 90. 0. 1. 77. 0. 0. 1.
N 274 O GpFunc
N 275 I 0
N 276 I 0
N 277 I 50
N 278 I 50
N 279 I 16777152
N 280 L
N 281 L
N 282 L
N 283 L
N 284 I 1
N 285 O TMGlyph
N 286 M 3 3 1. 0. 0. 0. 1. 0. 0. 0. 1.
N 287 O GpPort
N 288 R 20.
N 289 R 20.
N 290 R 32.
N 291 R 32.
N 292 I 12648447
N 293 R 20.
N 294 R 20.
N 295 R 32.
N 296 R 32.
N 297 L
N 298 I 10
N 299 O TMGlyph
N 300 M 3 3 1. 0. 32. 0. 1. 20. 0. 0. 1.
N 301 O MLabel
N 302 R 0.
N 303 R 0.
N 304 R 28.
N 305 R 16.
N 306 S "c-in"
N 307 R 32.
N 308 R 20.
N 309 R 60.
N 310 R 36.
N 311 S "$port_id"
N 312 L
N 313 L
N 314 O TMGlyph
N 315 M 3 3 1. 0. 0. 0. 1. 0. 0. 0. 1.
N 316 O GpPort
N 317 R 20.
N 318 R 250.
N 319 R 32.
N 320 R 262.
N 321 R 20.
N 322 R 250.
N 323 R 32.
N 324 R 262.
N 325 L
N 326 I 12
N 327 O TMGlyph
N 328 M 3 3 1. 0. 32. 0. 1. 250. 0. 0. 1.
N 329 O MLabel
N 330 R 0.
N 331 R 0.
N 332 R 28.
N 333 R 16.
N 334 S "d-in"
N 335 R 32.
N 336 R 250.
N 337 R 60.
N 338 R 266.
N 339 L
N 340 L
N 341 O TMGlyph
N 342 M 3 3 1. 0. 0. 0. 1. 0. 0. 0. 1.
N 343 O GpPort
N 344 R 338.
N 345 R 20.
N 346 R 350.
N 347 R 32.
N 348 R 338.
N 349 R 20.
N 350 R 350.
N 351 R 32.
N 352 L
N 353 I 11
N 354 O TMGlyph
N 355 M 3 3 1. 0. 350. 0. 1. 20. 0. 0. 1.
N 356 O MLabel
N 357 R 0.
N 358 R 0.
N 359 R 34.
N 360 R 16.
N 361 S "c-out"
N 362 R 350.
N 363 R 20.
N 364 R 384.
N 365 R 36.
N 366 L
N 367 L
N 368 O TMGlyph
N 369 M 3 3 1. 0. 0. 0. 1. 0. 0. 0. 1.
N 370 O GpPort
N 371 R 338.
N 372 R 250.
N 373 R 350.
N 374 R 262.
N 375 R 338.
N 376 R 250.
N 377 R 350.
N 378 R 262.
N 379 L
N 380 I 13
N 381 O TMGlyph
N 382 M 3 3 1. 0. 350. 0. 1. 250. 0. 0. 1.
N 383 O MLabel
N 384 R 0.
N 385 R 0.
N 386 R 34.
N 387 R 16.
N 388 S "d-out"
N 389 R 350.
N 390 R 250.
N 391 R 384.
N 392 R 266.
N 393 L
N 394 L
N 395 O TMGlyph
N 396 M 3 3 1. 0. 64. 0. 1. 188. 0. 0. 1.
N 397 O GpObject
N 398 I 0
N 399 I 0
N 400 I 20
N 401 I 20
N 402 I 12648384
N 403 R 64.
N 404 R 188.
N 405 R 84.
N 406 R 208.
N 407 L
N 408 I 2
N 409 O TMGlyph
N 410 M 3 3 1. 0. 64. 0. 1. 208. 0. 0. 1.
N 411 O MLabel
N 412 R 0.
N 413 R 0.
N 414 R 40.
N 415 R 16.
N 416 S "string"
N 417 R 64.
N 418 R 208.
N 419 R 104.
N 420 R 224.
N 421 L
N 422 O TMGlyph
N 423 M 3 3 1. 0. 64. 0. 1. 220. 0. 0. 1.
N 424 O MLabel
N 425 R 0.
N 426 R 0.
N 427 R 100.
N 428 R 16.
N 429 S "\"DataMapperView\""
N 430 R 64.
N 431 R 220.
N 432 R 164.
N 433 R 236.
N 434 S "$const"
N 435 L
N 436 L
N 437 O TMGlyph
N 438 M 3 3 1. 0. 104. 0. 1. 168. 0. 0. 1.
N 439 O GpClass
N 440 R 104.
N 441 R 168.
N 442 R 124.
N 443 R 188.
N 444 L
N 445 O TMGlyph
N 446 M 3 3 1. 0. 104. 0. 1. 188. 0. 0. 1.
N 447 O MLabel
N 448 R 0.
N 449 R 0.
N 450 R 64.
N 451 R 16.
N 452 S "GUIbuilder"
N 453 R 104.
N 454 R 188.
N 455 R 168.
N 456 R 204.
N 457 L
N 458 L
N 459 O TMGlyph
N 460 M 3 3 1. 0. 104. 0. 1. 58. 0. 0. 1.
N 461 O GpFunc
N 462 R 0.
N 463 R 0.
N 464 R 50.
N 465 R 84.
N 466 R 104.
N 467 R 58.
N 468 R 154.
N 469 R 142.
N 470 S "$gp_port"
N 471 L
N 472 O TMGlyph
N 473 M 3 3 1. 0. 104. 0. 1. 58. 0. 0. 1.
N 474 O GpPort
N 475 R -10.
N 476 R 2.
N 477 R 2.
N 478 R 14.
N 479 R 94.
N 480 R 60.
N 481 R 106.
N 482 R 72.
N 483 L
N 484 I 15
N 485 L
N 486 O TMGlyph
N 487 M 3 3 1. 0. 104. 0. 1. 58. 0. 0. 1.
N 488 O GpPort
N 489 R 48.
N 490 R 2.
N 491 R 60.
N 492 R 14.
N 493 R 152.
N 494 R 60.
N 495 R 164.
N 496 R 72.
N 497 L
N 498 I 16
N 499 L
N 500 O TMGlyph
N 501 M 3 3 1. 0. 104. 0. 1. 58. 0. 0. 1.
N 502 O GpPort
N 503 R -10.
N 504 R 16.
N 505 R 2.
N 506 R 84.
N 507 R 94.
N 508 R 74.
N 509 R 106.
N 510 R 142.
N 511 L
N 512 O TMGlyph
N 513 M 3 3 1. 0. 104. 0. 1. 58. 0. 0. 1.
N 514 O GpPort
N 515 R -20.
N 516 R 28.
N 517 R -8.
N 518 R 40.
N 519 R 84.
N 520 R 86.
N 521 R 96.
N 522 R 98.
N 523 L
N 524 I 17
N 525 L
N 526 O TMGlyph
N 527 M 3 3 1. 0. 104. 0. 1. 58. 0. 0. 1.
N 528 O GpPort
N 529 R -20.
N 530 R 42.
N 531 R -8.
N 532 R 54.
N 533 R 84.
N 534 R 100.
N 535 R 96.
N 536 R 112.
N 537 L
N 538 L
N 539 O TMGlyph
N 540 M 3 3 1. 0. 104. 0. 1. 58. 0. 0. 1.
N 541 O GpPort
N 542 R -20.
N 543 R 56.
N 544 R -8.
N 545 R 68.
N 546 R 84.
N 547 R 114.
N 548 R 96.
N 549 R 126.
N 550 L
N 551 L
N 552 O TMGlyph
N 553 M 3 3 1. 0. 104. 0. 1. 58. 0. 0. 1.
N 554 O GpPort
N 555 R -20.
N 556 R 70.
N 557 R -8.
N 558 R 82.
N 559 R 84.
N 560 R 128.
N 561 R 96.
N 562 R 140.
N 563 L
N 564 L
N 565 L
N 566 O TMGlyph
N 567 M 3 3 1. 0. 104. 0. 1. 58. 0. 0. 1.
N 568 O GpPort
N 569 R 48.
N 570 R 16.
N 571 R 60.
N 572 R 28.
N 573 R 152.
N 574 R 74.
N 575 R 164.
N 576 R 86.
N 577 L
N 578 I 18
N 579 L
N 580 O TMGlyph
N 581 M 3 3 1. 0. 123. 0. 1. 140. 0. 0. 1.
N 582 O GpPort
N 583 R 0.
N 584 R 0.
N 585 R 12.
N 586 R 12.
N 587 R 123.
N 588 R 140.
N 589 R 135.
N 590 R 152.
N 591 L
N 592 I 14
N 593 L
N 594 I 4
N 595 O TMGlyph
N 596 M 3 3 1. 0. 104. 0. 1. 46. 0. 0. 1.
N 597 O MLabel
N 598 R 0.
N 599 R 0.
N 600 R 76.
N 601 R 16.
N 602 S "CreateWindow"
N 603 R 104.
N 604 R 46.
N 605 R 180.
N 606 R 62.
N 607 S "$gp_func"
N 608 L
N 609 O TMGlyph
N 610 M 3 3 1. 0. 106. 0. 1. 60. 0. 0. 1.
N 611 O MLabel
N 612 R 0.
N 613 R 0.
N 614 R 28.
N 615 R 16.
N 616 R 106.
N 617 R 60.
N 618 R 134.
N 619 R 76.
N 620 L
N 621 O TMGlyph
N 622 M 3 3 1. 0. 164. 0. 1. 60. 0. 0. 1.
N 623 O MLabel
N 624 R 0.
N 625 R 0.
N 626 R 34.
N 627 R 16.
N 628 R 164.
N 629 R 60.
N 630 R 198.
N 631 R 76.
N 632 L
N 633 O TMGlyph
N 634 M 3 3 1. 0. 106. 0. 1. 74. 0. 0. 1.
N 635 O MLabel
N 636 R 0.
N 637 R 0.
N 638 R 28.
N 639 R 16.
N 640 R 106.
N 641 R 74.
N 642 R 134.
N 643 R 90.
N 644 L
N 645 O TMGlyph
N 646 M 3 3 1. 0. 164. 0. 1. 74. 0. 0. 1.
N 647 O MLabel
N 648 R 0.
N 649 R 0.
N 650 R 34.
N 651 R 16.
N 652 R 164.
N 653 R 74.
N 654 R 198.
N 655 R 90.
N 656 L
N 657 O TMGlyph
N 658 M 3 3 1. 0. 123. 0. 1. 128. 0. 0. 1.
N 659 O MLabel
N 660 R 0.
N 661 R 0.
N 662 R 34.
N 663 R 16.
N 664 S "class"
N 665 R 123.
N 666 R 128.
N 667 R 157.
N 668 R 144.
N 669 L
N 670 O TMGlyph
N 671 M 3 3 1. 0. 96. 0. 1. 86. 0. 0. 1.
N 672 O MLabel
N 673 R 0.
N 674 R 0.
N 675 R 28.
N 676 R 16.
N 677 S "name"
N 678 R 96.
N 679 R 86.
N 680 R 124.
N 681 R 102.
N 682 L
N 683 O TMGlyph
N 684 M 3 3 1. 0. 96. 0. 1. 100. 0. 0. 1.
N 685 O MLabel
N 686 R 0.
N 687 R 0.
N 688 R 34.
N 689 R 16.
N 690 S "style"
N 691 R 96.
N 692 R 100.
N 693 R 130.
N 694 R 116.
N 695 L
N 696 O TMGlyph
N 697 M 3 3 1. 0. 96. 0. 1. 114. 0. 0. 1.
N 698 O MLabel
N 699 R 0.
N 700 R 0.
N 701 R 40.
N 702 R 16.
N 703 S "parent"
N 704 R 96.
N 705 R 114.
N 706 R 136.
N 707 R 130.
N 708 L
N 709 O TMGlyph
N 710 M 3 3 1. 0. 96. 0. 1. 128. 0. 0. 1.
N 711 O MLabel
N 712 R 0.
N 713 R 0.
N 714 R 28.
N 715 R 16.
N 716 S "geom"
N 717 R 96.
N 718 R 128.
N 719 R 124.
N 720 R 144.
N 721 L
N 722 L
N 723 O TMGlyph
N 724 M 3 3 1. 0. 184. 0. 1. 168. 0. 0. 1.
N 725 O GpObject
N 726 R 184.
N 727 R 168.
N 728 R 204.
N 729 R 188.
N 730 L
N 731 O TMGlyph
N 732 M 3 3 1. 0. 184. 0. 1. 188. 0. 0. 1.
N 733 O MLabel
N 734 R 0.
N 735 R 0.
N 736 R 88.
N 737 R 16.
N 738 S "DataMapperView"
N 739 R 184.
N 740 R 188.
N 741 R 272.
N 742 R 204.
N 743 L
N 744 L
N 745 O TMGlyph
N 746 M 3 3 1. 0. 10. 0. 1. 127. 0. 0. 1.
N 747 O GpObject
N 748 R 10.
N 749 R 127.
N 750 R 30.
N 751 R 147.
N 752 L
N 753 O TMGlyph
N 754 M 3 3 1. 0. 10. 0. 1. 147. 0. 0. 1.
N 755 O MLabel
N 756 R 0.
N 757 R 0.
N 758 R 46.
N 759 R 16.
N 760 S "integer"
N 761 R 10.
N 762 R 147.
N 763 R 56.
N 764 R 163.
N 765 L
N 766 O TMGlyph
N 767 M 3 3 1. 0. 10. 0. 1. 159. 0. 0. 1.
N 768 O MLabel
N 769 R 0.
N 770 R 0.
N 771 R 76.
N 772 R 16.
N 773 S "(list)0x2000"
N 774 R 10.
N 775 R 159.
N 776 R 86.
N 777 R 175.
N 778 L
N 779 L
N 780 O TMGlyph
N 781 M 3 3 1. 0. 222. 0. 1. 86. 0. 0. 1.
N 782 O GpFunc
N 783 R 222.
N 784 R 86.
N 785 R 272.
N 786 R 136.
N 787 L
N 788 O TMGlyph
N 789 M 3 3 1. 0. 222. 0. 1. 86. 0. 0. 1.
N 790 O GpPort
N 791 R -10.
N 792 R 2.
N 793 R 2.
N 794 R 14.
N 795 R 212.
N 796 R 88.
N 797 R 224.
N 798 R 100.
N 799 L
N 800 L
N 801 O TMGlyph
N 802 M 3 3 1. 0. 222. 0. 1. 86. 0. 0. 1.
N 803 O GpPort
N 804 R -10.
N 805 R 16.
N 806 R 2.
N 807 R 28.
N 808 R 212.
N 809 R 102.
N 810 R 224.
N 811 R 114.
N 812 L
N 813 L
N 814 O TMGlyph
N 815 M 3 3 1. 0. 222. 0. 1. 86. 0. 0. 1.
N 816 O GpPort
N 817 R 48.
N 818 R 2.
N 819 R 60.
N 820 R 14.
N 821 R 270.
N 822 R 88.
N 823 R 282.
N 824 R 100.
N 825 L
N 826 L
N 827 O TMGlyph
N 828 M 3 3 1. 0. 222. 0. 1. 86. 0. 0. 1.
N 829 O GpPort
N 830 R 48.
N 831 R 16.
N 832 R 60.
N 833 R 28.
N 834 R 270.
N 835 R 102.
N 836 R 282.
N 837 R 114.
N 838 L
N 839 L
N 840 O TMGlyph
N 841 M 3 3 1. 0. 241. 0. 1. 134. 0. 0. 1.
N 842 O GpPort
N 843 R 0.
N 844 R 0.
N 845 R 12.
N 846 R 12.
N 847 R 241.
N 848 R 134.
N 849 R 253.
N 850 R 146.
N 851 L
N 852 L
N 853 I 3
N 854 O TMGlyph
N 855 M 3 3 1. 0. 222. 0. 1. 74. 0. 0. 1.
N 856 O MLabel
N 857 R 0.
N 858 R 0.
N 859 R 28.
N 860 R 16.
N 861 S "Init"
N 862 R 222.
N 863 R 74.
N 864 R 250.
N 865 R 90.
N 866 L
N 867 O TMGlyph
N 868 M 3 3 1. 0. 224. 0. 1. 88. 0. 0. 1.
N 869 O MLabel
N 870 R 0.
N 871 R 0.
N 872 R 28.
N 873 R 16.
N 874 R 224.
N 875 R 88.
N 876 R 252.
N 877 R 104.
N 878 L
N 879 O TMGlyph
N 880 M 3 3 1. 0. 224. 0. 1. 102. 0. 0. 1.
N 881 O MLabel
N 882 R 0.
N 883 R 0.
N 884 R 28.
N 885 R 16.
N 886 R 224.
N 887 R 102.
N 888 R 252.
N 889 R 118.
N 890 L
N 891 O TMGlyph
N 892 M 3 3 1. 0. 282. 0. 1. 88. 0. 0. 1.
N 893 O MLabel
N 894 R 0.
N 895 R 0.
N 896 R 34.
N 897 R 16.
N 898 R 282.
N 899 R 88.
N 900 R 316.
N 901 R 104.
N 902 L
N 903 O TMGlyph
N 904 M 3 3 1. 0. 282. 0. 1. 102. 0. 0. 1.
N 905 O MLabel
N 906 R 0.
N 907 R 0.
N 908 R 34.
N 909 R 16.
N 910 R 282.
N 911 R 102.
N 912 R 316.
N 913 R 118.
N 914 L
N 915 O TMGlyph
N 916 M 3 3 1. 0. 241. 0. 1. 122. 0. 0. 1.
N 917 O MLabel
N 918 R 0.
N 919 R 0.
N 920 R 22.
N 921 R 16.
N 922 S "obj"
N 923 R 241.
N 924 R 122.
N 925 R 263.
N 926 R 138.
N 927 L
N 928 L
N 929 L
N 930 I 2
N 931 S "$src"
N 932 S "$dst"
N 933 O TMGlyph
N 934 M 3 3 1. 0. 0. 0. 1. 0. 0. 0. 1.
N 935 O ArrowPath
N 936 S "pts"
N 937 L
N 938 L
N 939 R 74.
N 940 L
N 941 R 188.
N 942 L
N 943 R 90.
N 944 L
N 945 R 98.
N 946 R 90.
N 947 R 74.
N 948 R 188.
N 949 R 98.
N 950 S "line_style"
N 951 S "Solid"
N 952 S "line_width"
N 953 I 0
N 954 S "line_color"
N 955 I 0
N 956 R 74.
N 957 R 98.
N 958 R 90.
N 959 R 188.
N 960 L
N 961 I 23
N 962 L
N 963 O TMGlyph
N 964 M 3 3 1. 0. 0. 0. 1. 0. 0. 0. 1.
N 965 O ArrowPath
N 966 L
N 967 L
N 968 R 114.
N 969 L
N 970 R 168.
N 971 L
N 972 R 123.
N 973 L
N 974 R 146.
N 975 R 123.
N 976 R 114.
N 977 R 168.
N 978 R 146.
N 979 R 114.
N 980 R 146.
N 981 R 123.
N 982 R 168.
N 983 L
N 984 I 22
N 985 L
N 986 O TMGlyph
N 987 M 3 3 1. 0. 0. 0. 1. 0. 0. 0. 1.
N 988 O ArrowPath
N 989 L
N 990 L
N 991 R 158.
N 992 L
N 993 R 86.
N 994 L
N 995 R 194.
N 996 L
N 997 R 168.
N 998 R 194.
N 999 R 158.
N 1000 R 168.
N 1001 R 86.
N 1002 R 158.
N 1003 R 86.
N 1004 R 194.
N 1005 R 168.
N 1006 L
N 1007 L
N 1008 O TMGlyph
N 1009 M 3 3 1. 0. 0. 0. 1. 0. 0. 0. 1.
N 1010 O ArrowPath
N 1011 L
N 1012 L
N 1013 R 32.
N 1014 L
N 1015 R 26.
N 1016 L
N 1017 R 94.
N 1018 L
N 1019 R 66.
N 1020 R 94.
N 1021 R 32.
N 1022 R 66.
N 1023 R 26.
N 1024 S "Dot"
N 1025 R 32.
N 1026 R 26.
N 1027 R 94.
N 1028 R 66.
N 1029 L
N 1030 I 24
N 1031 L
N 1032 O TMGlyph
N 1033 M 3 3 1. 0. 0. 0. 1. 0. 0. 0. 1.
N 1034 O ArrowPath
N 1035 L
N 1036 L
N 1037 R 30.
N 1038 L
N 1039 R 137.
N 1040 L
N 1041 R 84.
N 1042 L
N 1043 R 106.
N 1044 R 84.
N 1045 R 30.
N 1046 R 137.
N 1047 R 106.
N 1048 R 30.
N 1049 R 106.
N 1050 R 84.
N 1051 R 137.
N 1052 L
N 1053 L
N 1054 O TMGlyph
N 1055 M 3 3 1. 0. 0. 0. 1. 0. 0. 0. 1.
N 1056 O ArrowPath
N 1057 L
N 1058 L
N 1059 R 194.
N 1060 L
N 1061 L
N 1062 R 241.
N 1063 L
N 1064 R 140.
N 1065 R 241.
N 1066 R 194.
N 1067 R 168.
N 1068 R 140.
N 1069 R 194.
N 1070 R 140.
N 1071 R 241.
N 1072 R 168.
N 1073 L
N 1074 L
N 1075 O TMGlyph
N 1076 M 3 3 1. 0. 0. 0. 1. 0. 0. 0. 1.
N 1077 O ArrowPath
N 1078 L
N 1079 L
N 1080 R 164.
N 1081 L
N 1082 R 66.
N 1083 L
N 1084 R 212.
N 1085 L
N 1086 R 94.
N 1087 R 212.
N 1088 R 164.
N 1089 R 94.
N 1090 R 66.
N 1091 R 164.
N 1092 R 66.
N 1093 R 212.
N 1094 R 94.
N 1095 L
N 1096 L
N 1097 O TMGlyph
N 1098 M 3 3 1. 0. 0. 0. 1. 0. 0. 0. 1.
N 1099 O ArrowPath
N 1100 L
N 1101 L
N 1102 R 282.
N 1103 L
N 1104 R 94.
N 1105 L
N 1106 R 344.
N 1107 L
N 1108 R 32.
N 1109 R 344.
N 1110 R 282.
N 1111 R 94.
N 1112 R 32.
N 1113 R 282.
N 1114 R 32.
N 1115 R 344.
N 1116 R 94.
N 1117 L
N 1118 L
N 1119 L
N 1120 L
N 1121 O SpIdxGlyph
N 1122 R 0.
N 1123 R 0.
N 1124 R 10000.
N 1125 R 10000.
N 1126 R 90.
N 1127 R 77.
N 1128 R 140.
N 1129 R 127.
N 1130 L
N 1131 O TMGlyph
N 1132 M 3 3 1. 0. 90. 0. 1. 77. 0. 0. 1.
N 1133 O GpPort
N 1134 R -10.
N 1135 R 2.
N 1136 R 2.
N 1137 R 14.
N 1138 R 80.
N 1139 R 79.
N 1140 R 92.
N 1141 R 91.
N 1142 L
N 1143 L
N 1144 O TMGlyph
N 1145 M 3 3 1. 0. 90. 0. 1. 77. 0. 0. 1.
N 1146 O GpPort
N 1147 R -10.
N 1148 R 16.
N 1149 R 2.
N 1150 R 28.
N 1151 R 80.
N 1152 R 93.
N 1153 R 92.
N 1154 R 105.
N 1155 L
N 1156 L
N 1157 O TMGlyph
N 1158 M 3 3 1. 0. 90. 0. 1. 77. 0. 0. 1.
N 1159 O GpPort
N 1160 R 48.
N 1161 R 2.
N 1162 R 60.
N 1163 R 14.
N 1164 R 138.
N 1165 R 79.
N 1166 R 150.
N 1167 R 91.
N 1168 L
N 1169 L
N 1170 O TMGlyph
N 1171 M 3 3 1. 0. 90. 0. 1. 77. 0. 0. 1.
N 1172 O GpPort
N 1173 R 48.
N 1174 R 16.
N 1175 R 60.
N 1176 R 28.
N 1177 R 138.
N 1178 R 93.
N 1179 R 150.
N 1180 R 105.
N 1181 L
N 1182 L
N 1183 O TMGlyph
N 1184 M 3 3 1. 0. 109. 0. 1. 125. 0. 0. 1.
N 1185 O GpPort
N 1186 R 0.
N 1187 R 0.
N 1188 R 12.
N 1189 R 12.
N 1190 R 109.
N 1191 R 125.
N 1192 R 121.
N 1193 R 137.
N 1194 L
N 1195 S "$gp_macro"
N 1196 O GpEditor
N 1197 I 30
N 1198 L
N 1199 S "type"
N 1200 I 3
N 1201 S "class_name"
N 1202 S "DataMapperApp"
N 1203 S "cache_tm"
N 1204 M 3 3 1. 0. 0. 0. 1. 0. 0. 0. 1.
N 1205 S "$gp_ext_port"
N 1206 L
N 1207 O TMGlyph
N 1208 M 3 3 1. 0. 90. 0. 1. 65. 0. 0. 1.
N 1209 O MLabel
N 1210 R 0.
N 1211 R -2.
N 1212 R 71.
N 1213 R 16.
N 1214 S "main"
N 1215 R 90.
N 1216 R 63.
N 1217 R 161.
N 1218 R 81.
N 1219 L
N 1220 O TMGlyph
N 1221 M 3 3 1. 0. 92. 0. 1. 79. 0. 0. 1.
N 1222 O MLabel
N 1223 R 0.
N 1224 R 0.
N 1225 R 28.
N 1226 R 16.
N 1227 R 92.
N 1228 R 79.
N 1229 R 120.
N 1230 R 95.
N 1231 L
N 1232 O TMGlyph
N 1233 M 3 3 1. 0. 92. 0. 1. 93. 0. 0. 1.
N 1234 O MLabel
N 1235 R 0.
N 1236 R 0.
N 1237 R 28.
N 1238 R 16.
N 1239 R 92.
N 1240 R 93.
N 1241 R 120.
N 1242 R 109.
N 1243 L
N 1244 O TMGlyph
N 1245 M 3 3 1. 0. 150. 0. 1. 79. 0. 0. 1.
N 1246 O MLabel
N 1247 R 0.
N 1248 R 0.
N 1249 R 34.
N 1250 R 16.
N 1251 R 150.
N 1252 R 79.
N 1253 R 184.
N 1254 R 95.
N 1255 L
N 1256 O TMGlyph
N 1257 M 3 3 1. 0. 150. 0. 1. 93. 0. 0. 1.
N 1258 O MLabel
N 1259 R 0.
N 1260 R 0.
N 1261 R 34.
N 1262 R 16.
N 1263 R 150.
N 1264 R 93.
N 1265 R 184.
N 1266 R 109.
N 1267 L
N 1268 O TMGlyph
N 1269 M 3 3 1. 0. 109. 0. 1. 113. 0. 0. 1.
N 1270 O MLabel
N 1271 R 0.
N 1272 R 0.
N 1273 R 34.
N 1274 R 16.
N 1275 R 109.
N 1276 R 113.
N 1277 R 143.
N 1278 R 129.
N 1279 L
N 1280 L
N 1281 L
N 1282 L
N 1283 L
N 1284 O SpIdxGlyph
N 1285 R 0.
N 1286 R 0.
N 1287 R 8000.
N 1288 R 8000.
N 1289 R 147.
N 1290 R 106.
N 1291 R 167.
N 1292 R 126.
N 1293 O GpEditor
N 1294 L
N 1295 S "$select"
N 1296 I 2
N 1297 M 3 3 1. 0. 0. 0. 1. 0. 0. 0. 1.
N 1298 L
N 1299 O TMGlyph
N 1300 M 3 3 1. 0. 147. 0. 1. 126. 0. 0. 1.
N 1301 O MLabel
N 1302 R 0.
N 1303 R 0.
N 1304 R 82.
N 1305 R 16.
N 1306 R 147.
N 1307 R 126.
N 1308 R 229.
N 1309 R 142.
N 1310 L
N 1311 L
N 1312 L
N 1313 O TMGlyph
N 1314 M 3 3 1. 0. 0. 0. 1. 0. 0. 0. 1.
N 1315 O ArrowPath
N 1316 L
N 1317 L
N 1318 R 117.
N 1319 L
N 1320 R 66.
N 1321 L
N 1322 R 157.
N 1323 L
N 1324 R 106.
N 1325 R 157.
N 1326 R 117.
N 1327 R 106.
N 1328 R 66.
N 1329 R 117.
N 1330 R 66.
N 1331 R 157.
N 1332 R 106.
N 1333 L
N 1334 I 20
N 1335 L
N 1336 L
N 1337 L
N 1338 O SpIdxGlyph
N 1339 R 0.
N 1340 R 0.
N 1341 R 6000.
N 1342 R 6000.
N 1343 L
N 1344 S ""
N 1345 S "$exec"
N 1346 L
N 1347 S "DataMapperApp"
N 1348 L
N 1349 S "main"
N 1350 L
N 1351 S "C:/altair/sample/gbgp/xml_mapper"
N 1352 L
N 1353 S "xml_mapper.gpr"
N 1354 L
N 1355 L
N 1356 L
N 1357 L
N 1358 S "DataMapper"
h 1 2
t 1 1350
a 1 4 3 0
a 4 5 0 0
h 5 6
t 5 16
a 5 8 7 0
h 8 9
t 8 10
h 10 11
t 10 12
h 12 13
t 12 14
h 14 15
h 16 17
t 16 204
h 17 18
t 17 195
a 18 19 0 0
h 19 20
t 19 91
a 20 22 21 0
a 20 24 23 0
a 24 26 25 0
a 24 28 27 0
a 24 30 29 0
a 24 32 31 0
a 24 34 33 0
a 24 36 35 0
a 24 38 37 0
a 24 40 39 0
a 24 42 41 0
a 24 44 43 0
a 24 46 45 0
a 24 48 47 0
a 24 50 49 0
a 24 52 51 0
a 24 54 53 0
a 24 56 55 0
a 24 58 57 0
a 58 60 59 0
a 60 26 25 0
a 60 61 27 0
a 60 62 29 0
a 60 63 31 0
a 60 64 33 0
a 60 65 23 0
a 65 66 25 0
a 65 67 23 0
a 67 68 27 0
a 67 69 29 0
a 67 70 31 0
a 67 71 33 0
a 65 73 72 0
a 65 68 27 0
a 65 69 29 0
a 65 70 31 0
a 65 71 33 0
a 65 75 74 0
a 65 77 76 0
a 65 79 78 0
a 65 81 80 0
a 60 68 82 0
a 60 69 83 0
a 60 70 84 0
a 60 71 85 0
a 60 86 21 0
a 20 87 27 0
a 20 88 29 0
a 20 89 31 0
a 20 90 33 0
h 91 92
t 91 93
h 93 94
t 93 95
h 95 96
a 18 97 0 0
h 97 20
t 97 98
h 98 99
t 98 100
h 100 101
t 100 102
h 102 103
a 18 104 0 0
h 104 20
t 104 105
h 105 106
t 105 107
h 107 108
t 107 109
h 109 110
a 18 111 0 0
h 111 20
t 111 112
h 112 113
t 112 114
h 114 115
t 114 116
h 116 117
a 18 118 0 0
h 118 119
t 118 136
a 119 120 21 0
a 119 121 23 0
a 121 26 25 0
a 121 122 27 0
a 121 123 29 0
a 121 124 31 0
a 121 125 33 0
a 121 36 35 0
a 121 38 37 0
a 121 40 39 0
a 121 42 41 0
a 121 44 43 0
a 121 46 45 0
a 121 126 47 0
a 121 127 49 0
a 121 128 51 0
a 121 129 53 0
a 121 130 55 0
a 121 131 57 0
a 131 60 59 0
a 119 132 27 0
a 119 133 29 0
a 119 134 31 0
a 119 135 33 0
h 136 113
t 136 137
h 137 138
t 137 139
h 139 140
a 18 141 0 0
h 141 119
t 141 142
h 142 99
t 142 143
h 143 101
t 143 144
h 144 145
a 18 146 0 0
h 146 119
t 146 147
h 147 106
t 147 148
h 148 108
t 148 149
h 149 150
a 18 151 0 0
h 151 119
t 151 152
h 152 92
t 152 153
h 153 154
t 153 155
h 155 156
a 18 157 0 0
h 157 158
t 157 164
a 158 159 21 0
a 158 60 23 0
a 158 160 27 0
a 158 161 29 0
a 158 162 31 0
a 158 163 33 0
h 164 113
t 164 165
h 165 138
t 165 166
h 166 167
a 18 168 0 0
h 168 158
t 168 169
h 169 92
t 169 170
h 170 94
t 170 171
h 171 172
a 18 173 0 0
h 173 158
t 173 174
h 174 99
t 174 175
h 175 101
t 175 176
h 176 177
a 18 178 0 0
h 178 158
t 178 179
h 179 106
t 179 180
h 180 108
t 180 181
h 181 182
a 18 183 0 0
h 183 20
t 183 184
h 184 185
t 184 186
h 186 187
t 186 188
h 188 189
a 18 190 0 0
h 190 119
t 190 191
h 191 185
t 191 192
h 192 193
t 192 194
h 194 189
h 195 196
t 195 197
a 196 121 193 0
a 196 24 187 0
a 196 60 189 0
h 197 198
a 198 199 27 0
a 198 200 29 0
a 198 201 31 0
a 198 202 33 0
a 198 119 23 0
a 198 20 23 0
a 198 158 23 0
a 198 158 203 0
h 204 205
a 1 207 206 0
a 207 208 0 0
h 208 209
t 208 210
h 210 211
t 210 1343
h 211 212
t 211 1310
a 212 213 0 0
h 213 214
a 213 216 215 0
h 216 217
t 216 234
a 216 219 218 0
a 219 220 21 0
a 219 221 23 0
a 221 26 25 0
a 221 222 37 0
a 221 223 39 0
a 221 224 41 0
a 221 225 27 0
a 221 226 29 0
a 221 227 31 0
a 221 228 33 0
a 221 229 35 0
a 219 230 27 0
a 219 231 29 0
a 219 232 31 0
a 219 233 33 0
h 234 235
a 213 236 218 0
a 236 237 21 0
a 236 238 23 0
a 238 26 25 0
a 238 239 27 0
a 238 240 29 0
a 238 241 31 0
a 238 242 33 0
a 238 244 243 0
a 238 246 245 0
a 238 248 247 0
a 238 250 249 0
a 238 252 251 0
a 238 254 253 0
a 238 256 255 0
a 236 257 27 0
a 236 258 29 0
a 236 259 31 0
a 236 260 33 0
a 213 216 261 0
a 212 262 0 0
h 262 214
a 262 263 215 0
h 263 217
t 263 1298
a 263 264 218 0
a 264 265 21 0
a 264 266 23 0
a 266 26 25 0
a 266 222 37 0
a 266 223 39 0
a 266 224 41 0
a 266 225 27 0
a 266 226 29 0
a 266 227 31 0
a 266 228 33 0
a 266 229 35 0
a 266 268 267 0
h 268 269
t 268 1279
a 269 270 0 0
h 270 214
a 270 271 215 0
h 271 217
t 271 1206
a 271 272 218 0
a 272 273 21 0
a 272 274 23 0
a 274 26 25 0
a 274 222 37 0
a 274 223 39 0
a 274 224 41 0
a 274 275 27 0
a 274 276 29 0
a 274 277 31 0
a 274 278 33 0
a 274 279 35 0
a 274 280 267 0
h 280 281
t 280 927
a 281 282 0 0
h 282 214
a 282 283 215 0
h 283 284
t 283 297
a 283 285 218 0
a 285 286 21 0
a 285 287 23 0
a 287 26 25 0
a 287 222 37 0
a 287 223 39 0
a 287 224 41 0
a 287 288 27 0
a 287 289 29 0
a 287 290 31 0
a 287 291 33 0
a 287 292 35 0
a 285 293 27 0
a 285 294 29 0
a 285 295 31 0
a 285 296 33 0
h 297 298
a 282 299 218 0
a 299 300 21 0
a 299 301 23 0
a 301 26 25 0
a 301 302 27 0
a 301 303 29 0
a 301 304 31 0
a 301 305 33 0
a 301 306 243 0
a 301 246 245 0
a 301 248 247 0
a 301 250 249 0
a 301 252 251 0
a 301 254 253 0
a 301 256 255 0
a 299 307 27 0
a 299 308 29 0
a 299 309 31 0
a 299 310 33 0
a 282 283 311 0
a 281 312 0 0
h 312 214
a 312 313 215 0
h 313 284
t 313 325
a 313 314 218 0
a 314 315 21 0
a 314 316 23 0
a 316 26 25 0
a 316 222 37 0
a 316 223 39 0
a 316 224 41 0
a 316 317 27 0
a 316 318 29 0
a 316 319 31 0
a 316 320 33 0
a 316 292 35 0
a 314 321 27 0
a 314 322 29 0
a 314 323 31 0
a 314 324 33 0
h 325 326
a 312 327 218 0
a 327 328 21 0
a 327 329 23 0
a 329 26 25 0
a 329 330 27 0
a 329 331 29 0
a 329 332 31 0
a 329 333 33 0
a 329 334 243 0
a 329 246 245 0
a 329 248 247 0
a 329 250 249 0
a 329 252 251 0
a 329 254 253 0
a 329 256 255 0
a 327 335 27 0
a 327 336 29 0
a 327 337 31 0
a 327 338 33 0
a 312 313 311 0
a 281 339 0 0
h 339 214
a 339 340 215 0
h 340 284
t 340 352
a 340 341 218 0
a 341 342 21 0
a 341 343 23 0
a 343 26 25 0
a 343 222 37 0
a 343 223 39 0
a 343 224 41 0
a 343 344 27 0
a 343 345 29 0
a 343 346 31 0
a 343 347 33 0
a 343 292 35 0
a 341 348 27 0
a 341 349 29 0
a 341 350 31 0
a 341 351 33 0
h 352 353
a 339 354 218 0
a 354 355 21 0
a 354 356 23 0
a 356 26 25 0
a 356 357 27 0
a 356 358 29 0
a 356 359 31 0
a 356 360 33 0
a 356 361 243 0
a 356 246 245 0
a 356 248 247 0
a 356 250 249 0
a 356 252 251 0
a 356 254 253 0
a 356 256 255 0
a 354 362 27 0
a 354 363 29 0
a 354 364 31 0
a 354 365 33 0
a 339 340 311 0
a 281 366 0 0
h 366 214
a 366 367 215 0
h 367 284
t 367 379
a 367 368 218 0
a 368 369 21 0
a 368 370 23 0
a 370 26 25 0
a 370 222 37 0
a 370 223 39 0
a 370 224 41 0
a 370 371 27 0
a 370 372 29 0
a 370 373 31 0
a 370 374 33 0
a 370 292 35 0
a 368 375 27 0
a 368 376 29 0
a 368 377 31 0
a 368 378 33 0
h 379 380
a 366 381 218 0
a 381 382 21 0
a 381 383 23 0
a 383 26 25 0
a 383 384 27 0
a 383 385 29 0
a 383 386 31 0
a 383 387 33 0
a 383 388 243 0
a 383 246 245 0
a 383 248 247 0
a 383 250 249 0
a 383 252 251 0
a 383 254 253 0
a 383 256 255 0
a 381 389 27 0
a 381 390 29 0
a 381 391 31 0
a 381 392 33 0
a 366 367 311 0
a 281 393 0 0
h 393 214
a 393 394 215 0
h 394 217
t 394 407
a 394 395 218 0
a 395 396 21 0
a 395 397 23 0
a 397 26 25 0
a 397 222 37 0
a 397 223 39 0
a 397 224 41 0
a 397 398 27 0
a 397 399 29 0
a 397 400 31 0
a 397 401 33 0
a 397 402 35 0
a 395 403 27 0
a 395 404 29 0
a 395 405 31 0
a 395 406 33 0
h 407 408
a 393 409 218 0
a 409 410 21 0
a 409 411 23 0
a 411 26 25 0
a 411 412 27 0
a 411 413 29 0
a 411 414 31 0
a 411 415 33 0
a 411 416 243 0
a 411 246 245 0
a 411 248 247 0
a 411 250 249 0
a 411 252 251 0
a 411 254 253 0
a 411 256 255 0
a 409 417 27 0
a 409 418 29 0
a 409 419 31 0
a 409 420 33 0
a 393 394 261 0
a 281 421 0 0
h 421 214
a 421 394 215 0
a 421 422 218 0
a 422 423 21 0
a 422 424 23 0
a 424 26 25 0
a 424 425 27 0
a 424 426 29 0
a 424 427 31 0
a 424 428 33 0
a 424 429 243 0
a 424 246 245 0
a 424 248 247 0
a 424 250 249 0
a 424 252 251 0
a 424 254 253 0
a 424 256 255 0
a 422 430 27 0
a 422 431 29 0
a 422 432 31 0
a 422 433 33 0
a 421 394 434 0
a 281 435 0 0
h 435 214
a 435 436 215 0
h 436 217
t 436 444
a 436 437 218 0
a 437 438 21 0
a 437 439 23 0
a 439 26 25 0
a 439 222 37 0
a 439 223 39 0
a 439 224 41 0
a 439 225 27 0
a 439 226 29 0
a 439 227 31 0
a 439 228 33 0
a 439 229 35 0
a 437 440 27 0
a 437 441 29 0
a 437 442 31 0
a 437 443 33 0
h 444 235
a 435 445 218 0
a 445 446 21 0
a 445 447 23 0
a 447 26 25 0
a 447 448 27 0
a 447 449 29 0
a 447 450 31 0
a 447 451 33 0
a 447 452 243 0
a 447 246 245 0
a 447 248 247 0
a 447 250 249 0
a 447 252 251 0
a 447 254 253 0
a 447 256 255 0
a 445 453 27 0
a 445 454 29 0
a 445 455 31 0
a 445 456 33 0
a 435 436 261 0
a 281 457 0 0
h 457 214
a 457 458 215 0
h 458 217
t 458 593
a 458 459 218 0
a 459 460 21 0
a 459 461 23 0
a 461 26 25 0
a 461 222 37 0
a 461 223 39 0
a 461 224 41 0
a 461 462 27 0
a 461 463 29 0
a 461 464 31 0
a 461 465 33 0
a 461 279 35 0
a 459 466 27 0
a 459 467 29 0
a 459 468 31 0
a 459 469 33 0
a 458 471 470 0
h 471 284
t 471 483
a 471 472 218 0
a 472 473 21 0
a 472 474 23 0
a 474 26 25 0
a 474 222 37 0
a 474 223 39 0
a 474 224 41 0
a 474 475 27 0
a 474 476 29 0
a 474 477 31 0
a 474 478 33 0
a 474 292 35 0
a 472 479 27 0
a 472 480 29 0
a 472 481 31 0
a 472 482 33 0
h 483 484
a 458 485 470 0
h 485 284
t 485 497
a 485 486 218 0
a 486 487 21 0
a 486 488 23 0
a 488 26 25 0
a 488 222 37 0
a 488 223 39 0
a 488 224 41 0
a 488 489 27 0
a 488 490 29 0
a 488 491 31 0
a 488 492 33 0
a 488 292 35 0
a 486 493 27 0
a 486 494 29 0
a 486 495 31 0
a 486 496 33 0
h 497 498
a 458 499 470 0
h 499 284
t 499 564
a 499 500 218 0
a 500 501 21 0
a 500 502 23 0
a 502 26 25 0
a 502 222 37 0
a 502 223 39 0
a 502 224 41 0
a 502 503 27 0
a 502 504 29 0
a 502 505 31 0
a 502 506 33 0
a 502 292 35 0
a 500 507 27 0
a 500 508 29 0
a 500 509 31 0
a 500 510 33 0
a 499 511 470 0
h 511 284
t 511 523
a 511 512 218 0
a 512 513 21 0
a 512 514 23 0
a 514 26 25 0
a 514 222 37 0
a 514 223 39 0
a 514 224 41 0
a 514 515 27 0
a 514 516 29 0
a 514 517 31 0
a 514 518 33 0
a 514 292 35 0
a 512 519 27 0
a 512 520 29 0
a 512 521 31 0
a 512 522 33 0
h 523 524
a 499 525 470 0
h 525 284
t 525 537
a 525 526 218 0
a 526 527 21 0
a 526 528 23 0
a 528 26 25 0
a 528 222 37 0
a 528 223 39 0
a 528 224 41 0
a 528 529 27 0
a 528 530 29 0
a 528 531 31 0
a 528 532 33 0
a 528 292 35 0
a 526 533 27 0
a 526 534 29 0
a 526 535 31 0
a 526 536 33 0
h 537 524
a 499 538 470 0
h 538 284
t 538 550
a 538 539 218 0
a 539 540 21 0
a 539 541 23 0
a 541 26 25 0
a 541 222 37 0
a 541 223 39 0
a 541 224 41 0
a 541 542 27 0
a 541 543 29 0
a 541 544 31 0
a 541 545 33 0
a 541 292 35 0
a 539 546 27 0
a 539 547 29 0
a 539 548 31 0
a 539 549 33 0
h 550 524
a 499 551 470 0
h 551 284
t 551 563
a 551 552 218 0
a 552 553 21 0
a 552 554 23 0
a 554 26 25 0
a 554 222 37 0
a 554 223 39 0
a 554 224 41 0
a 554 555 27 0
a 554 556 29 0
a 554 557 31 0
a 554 558 33 0
a 554 292 35 0
a 552 559 27 0
a 552 560 29 0
a 552 561 31 0
a 552 562 33 0
h 563 524
h 564 524
a 458 565 470 0
h 565 284
t 565 577
a 565 566 218 0
a 566 567 21 0
a 566 568 23 0
a 568 26 25 0
a 568 222 37 0
a 568 223 39 0
a 568 224 41 0
a 568 569 27 0
a 568 570 29 0
a 568 571 31 0
a 568 572 33 0
a 568 292 35 0
a 566 573 27 0
a 566 574 29 0
a 566 575 31 0
a 566 576 33 0
h 577 578
a 458 579 470 0
h 579 284
t 579 591
a 579 580 218 0
a 580 581 21 0
a 580 582 23 0
a 582 26 25 0
a 582 222 37 0
a 582 223 39 0
a 582 224 41 0
a 582 583 27 0
a 582 584 29 0
a 582 585 31 0
a 582 586 33 0
a 582 292 35 0
a 580 587 27 0
a 580 588 29 0
a 580 589 31 0
a 580 590 33 0
h 591 592
h 593 594
a 457 595 218 0
a 595 596 21 0
a 595 597 23 0
a 597 26 25 0
a 597 598 27 0
a 597 599 29 0
a 597 600 31 0
a 597 601 33 0
a 597 602 243 0
a 597 246 245 0
a 597 248 247 0
a 597 250 249 0
a 597 252 251 0
a 597 254 253 0
a 597 256 255 0
a 595 603 27 0
a 595 604 29 0
a 595 605 31 0
a 595 606 33 0
a 457 458 607 0
a 281 608 0 0
h 608 214
a 608 471 215 0
a 608 609 218 0
a 609 610 21 0
a 609 611 23 0
a 611 26 25 0
a 611 612 27 0
a 611 613 29 0
a 611 614 31 0
a 611 615 33 0
a 611 306 243 0
a 611 246 245 0
a 611 248 247 0
a 611 250 249 0
a 611 252 251 0
a 611 254 253 0
a 611 256 255 0
a 609 616 27 0
a 609 617 29 0
a 609 618 31 0
a 609 619 33 0
a 608 471 311 0
a 281 620 0 0
h 620 214
a 620 485 215 0
a 620 621 218 0
a 621 622 21 0
a 621 623 23 0
a 623 26 25 0
a 623 624 27 0
a 623 625 29 0
a 623 626 31 0
a 623 627 33 0
a 623 361 243 0
a 623 246 245 0
a 623 248 247 0
a 623 250 249 0
a 623 252 251 0
a 623 254 253 0
a 623 256 255 0
a 621 628 27 0
a 621 629 29 0
a 621 630 31 0
a 621 631 33 0
a 620 485 311 0
a 281 632 0 0
h 632 214
a 632 499 215 0
a 632 633 218 0
a 633 634 21 0
a 633 635 23 0
a 635 26 25 0
a 635 636 27 0
a 635 637 29 0
a 635 638 31 0
a 635 639 33 0
a 635 334 243 0
a 635 246 245 0
a 635 248 247 0
a 635 250 249 0
a 635 252 251 0
a 635 254 253 0
a 635 256 255 0
a 633 640 27 0
a 633 641 29 0
a 633 642 31 0
a 633 643 33 0
a 632 499 311 0
a 281 644 0 0
h 644 214
a 644 565 215 0
a 644 645 218 0
a 645 646 21 0
a 645 647 23 0
a 647 26 25 0
a 647 648 27 0
a 647 649 29 0
a 647 650 31 0
a 647 651 33 0
a 647 388 243 0
a 647 246 245 0
a 647 248 247 0
a 647 250 249 0
a 647 252 251 0
a 647 254 253 0
a 647 256 255 0
a 645 652 27 0
a 645 653 29 0
a 645 654 31 0
a 645 655 33 0
a 644 565 311 0
a 281 656 0 0
h 656 214
a 656 579 215 0
a 656 657 218 0
a 657 658 21 0
a 657 659 23 0
a 659 26 25 0
a 659 660 27 0
a 659 661 29 0
a 659 662 31 0
a 659 663 33 0
a 659 664 243 0
a 659 246 245 0
a 659 248 247 0
a 659 250 249 0
a 659 252 251 0
a 659 254 253 0
a 659 256 255 0
a 657 665 27 0
a 657 666 29 0
a 657 667 31 0
a 657 668 33 0
a 656 579 311 0
a 281 669 0 0
h 669 214
a 669 511 215 0
a 669 670 218 0
a 670 671 21 0
a 670 672 23 0
a 672 26 25 0
a 672 673 27 0
a 672 674 29 0
a 672 675 31 0
a 672 676 33 0
a 672 677 243 0
a 672 246 245 0
a 672 248 247 0
a 672 250 249 0
a 672 252 251 0
a 672 254 253 0
a 672 256 255 0
a 670 678 27 0
a 670 679 29 0
a 670 680 31 0
a 670 681 33 0
a 669 511 311 0
a 281 682 0 0
h 682 214
a 682 525 215 0
a 682 683 218 0
a 683 684 21 0
a 683 685 23 0
a 685 26 25 0
a 685 686 27 0
a 685 687 29 0
a 685 688 31 0
a 685 689 33 0
a 685 690 243 0
a 685 246 245 0
a 685 248 247 0
a 685 250 249 0
a 685 252 251 0
a 685 254 253 0
a 685 256 255 0
a 683 691 27 0
a 683 692 29 0
a 683 693 31 0
a 683 694 33 0
a 682 525 311 0
a 281 695 0 0
h 695 214
a 695 538 215 0
a 695 696 218 0
a 696 697 21 0
a 696 698 23 0
a 698 26 25 0
a 698 699 27 0
a 698 700 29 0
a 698 701 31 0
a 698 702 33 0
a 698 703 243 0
a 698 246 245 0
a 698 248 247 0
a 698 250 249 0
a 698 252 251 0
a 698 254 253 0
a 698 256 255 0
a 696 704 27 0
a 696 705 29 0
a 696 706 31 0
a 696 707 33 0
a 695 538 311 0
a 281 708 0 0
h 708 214
a 708 551 215 0
a 708 709 218 0
a 709 710 21 0
a 709 711 23 0
a 711 26 25 0
a 711 712 27 0
a 711 713 29 0
a 711 714 31 0
a 711 715 33 0
a 711 716 243 0
a 711 246 245 0
a 711 248 247 0
a 711 250 249 0
a 711 252 251 0
a 711 254 253 0
a 711 256 255 0
a 709 717 27 0
a 709 718 29 0
a 709 719 31 0
a 709 720 33 0
a 708 551 311 0
a 281 721 0 0
h 721 214
a 721 722 215 0
h 722 217
t 722 730
a 722 723 218 0
a 723 724 21 0
a 723 725 23 0
a 725 26 25 0
a 725 222 37 0
a 725 223 39 0
a 725 224 41 0
a 725 398 27 0
a 725 399 29 0
a 725 400 31 0
a 725 401 33 0
a 725 402 35 0
a 723 726 27 0
a 723 727 29 0
a 723 728 31 0
a 723 729 33 0
h 730 408
a 721 731 218 0
a 731 732 21 0
a 731 733 23 0
a 733 26 25 0
a 733 734 27 0
a 733 735 29 0
a 733 736 31 0
a 733 737 33 0
a 733 738 243 0
a 733 246 245 0
a 733 248 247 0
a 733 250 249 0
a 733 252 251 0
a 733 254 253 0
a 733 256 255 0
a 731 739 27 0
a 731 740 29 0
a 731 741 31 0
a 731 742 33 0
a 721 722 261 0
a 281 743 0 0
h 743 214
a 743 744 215 0
h 744 217
t 744 752
a 744 745 218 0
a 745 746 21 0
a 745 747 23 0
a 747 26 25 0
a 747 222 37 0
a 747 223 39 0
a 747 224 41 0
a 747 398 27 0
a 747 399 29 0
a 747 400 31 0
a 747 401 33 0
a 747 402 35 0
a 745 748 27 0
a 745 749 29 0
a 745 750 31 0
a 745 751 33 0
h 752 408
a 743 753 218 0
a 753 754 21 0
a 753 755 23 0
a 755 26 25 0
a 755 756 27 0
a 755 757 29 0
a 755 758 31 0
a 755 759 33 0
a 755 760 243 0
a 755 246 245 0
a 755 248 247 0
a 755 250 249 0
a 755 252 251 0
a 755 254 253 0
a 755 256 255 0
a 753 761 27 0
a 753 762 29 0
a 753 763 31 0
a 753 764 33 0
a 743 744 261 0
a 281 765 0 0
h 765 214
a 765 744 215 0
a 765 766 218 0
a 766 767 21 0
a 766 768 23 0
a 768 26 25 0
a 768 769 27 0
a 768 770 29 0
a 768 771 31 0
a 768 772 33 0
a 768 773 243 0
a 768 246 245 0
a 768 248 247 0
a 768 250 249 0
a 768 252 251 0
a 768 254 253 0
a 768 256 255 0
a 766 774 27 0
a 766 775 29 0
a 766 776 31 0
a 766 777 33 0
a 765 744 434 0
a 281 778 0 0
h 778 214
a 778 779 215 0
h 779 217
t 779 852
a 779 780 218 0
a 780 781 21 0
a 780 782 23 0
a 782 26 25 0
a 782 222 37 0
a 782 223 39 0
a 782 224 41 0
a 782 275 27 0
a 782 276 29 0
a 782 277 31 0
a 782 278 33 0
a 782 279 35 0
a 780 783 27 0
a 780 784 29 0
a 780 785 31 0
a 780 786 33 0
a 779 787 470 0
h 787 284
t 787 799
a 787 788 218 0
a 788 789 21 0
a 788 790 23 0
a 790 26 25 0
a 790 222 37 0
a 790 223 39 0
a 790 224 41 0
a 790 791 27 0
a 790 792 29 0
a 790 793 31 0
a 790 794 33 0
a 790 292 35 0
a 788 795 27 0
a 788 796 29 0
a 788 797 31 0
a 788 798 33 0
h 799 484
a 779 800 470 0
h 800 284
t 800 812
a 800 801 218 0
a 801 802 21 0
a 801 803 23 0
a 803 26 25 0
a 803 222 37 0
a 803 223 39 0
a 803 224 41 0
a 803 804 27 0
a 803 805 29 0
a 803 806 31 0
a 803 807 33 0
a 803 292 35 0
a 801 808 27 0
a 801 809 29 0
a 801 810 31 0
a 801 811 33 0
h 812 524
a 779 813 470 0
h 813 284
t 813 825
a 813 814 218 0
a 814 815 21 0
a 814 816 23 0
a 816 26 25 0
a 816 222 37 0
a 816 223 39 0
a 816 224 41 0
a 816 817 27 0
a 816 818 29 0
a 816 819 31 0
a 816 820 33 0
a 816 292 35 0
a 814 821 27 0
a 814 822 29 0
a 814 823 31 0
a 814 824 33 0
h 825 498
a 779 826 470 0
h 826 284
t 826 838
a 826 827 218 0
a 827 828 21 0
a 827 829 23 0
a 829 26 25 0
a 829 222 37 0
a 829 223 39 0
a 829 224 41 0
a 829 830 27 0
a 829 831 29 0
a 829 832 31 0
a 829 833 33 0
a 829 292 35 0
a 827 834 27 0
a 827 835 29 0
a 827 836 31 0
a 827 837 33 0
h 838 578
a 779 839 470 0
h 839 284
t 839 851
a 839 840 218 0
a 840 841 21 0
a 840 842 23 0
a 842 26 25 0
a 842 222 37 0
a 842 223 39 0
a 842 224 41 0
a 842 843 27 0
a 842 844 29 0
a 842 845 31 0
a 842 846 33 0
a 842 292 35 0
a 840 847 27 0
a 840 848 29 0
a 840 849 31 0
a 840 850 33 0
h 851 592
h 852 853
a 778 854 218 0
a 854 855 21 0
a 854 856 23 0
a 856 26 25 0
a 856 857 27 0
a 856 858 29 0
a 856 859 31 0
a 856 860 33 0
a 856 861 243 0
a 856 246 245 0
a 856 248 247 0
a 856 250 249 0
a 856 252 251 0
a 856 254 253 0
a 856 256 255 0
a 854 862 27 0
a 854 863 29 0
a 854 864 31 0
a 854 865 33 0
a 778 779 607 0
a 281 866 0 0
h 866 214
a 866 787 215 0
a 866 867 218 0
a 867 868 21 0
a 867 869 23 0
a 869 26 25 0
a 869 870 27 0
a 869 871 29 0
a 869 872 31 0
a 869 873 33 0
a 869 306 243 0
a 869 246 245 0
a 869 248 247 0
a 869 250 249 0
a 869 252 251 0
a 869 254 253 0
a 869 256 255 0
a 867 874 27 0
a 867 875 29 0
a 867 876 31 0
a 867 877 33 0
a 866 787 311 0
a 281 878 0 0
h 878 214
a 878 800 215 0
a 878 879 218 0
a 879 880 21 0
a 879 881 23 0
a 881 26 25 0
a 881 882 27 0
a 881 883 29 0
a 881 884 31 0
a 881 885 33 0
a 881 334 243 0
a 881 246 245 0
a 881 248 247 0
a 881 250 249 0
a 881 252 251 0
a 881 254 253 0
a 881 256 255 0
a 879 886 27 0
a 879 887 29 0
a 879 888 31 0
a 879 889 33 0
a 878 800 311 0
a 281 890 0 0
h 890 214
a 890 813 215 0
a 890 891 218 0
a 891 892 21 0
a 891 893 23 0
a 893 26 25 0
a 893 894 27 0
a 893 895 29 0
a 893 896 31 0
a 893 897 33 0
a 893 361 243 0
a 893 246 245 0
a 893 248 247 0
a 893 250 249 0
a 893 252 251 0
a 893 254 253 0
a 893 256 255 0
a 891 898 27 0
a 891 899 29 0
a 891 900 31 0
a 891 901 33 0
a 890 813 311 0
a 281 902 0 0
h 902 214
a 902 826 215 0
a 902 903 218 0
a 903 904 21 0
a 903 905 23 0
a 905 26 25 0
a 905 906 27 0
a 905 907 29 0
a 905 908 31 0
a 905 909 33 0
a 905 388 243 0
a 905 246 245 0
a 905 248 247 0
a 905 250 249 0
a 905 252 251 0
a 905 254 253 0
a 905 256 255 0
a 903 910 27 0
a 903 911 29 0
a 903 912 31 0
a 903 913 33 0
a 902 826 311 0
a 281 914 0 0
h 914 214
a 914 839 215 0
a 914 915 218 0
a 915 916 21 0
a 915 917 23 0
a 917 26 25 0
a 917 918 27 0
a 917 919 29 0
a 917 920 31 0
a 917 921 33 0
a 917 922 243 0
a 917 246 245 0
a 917 248 247 0
a 917 250 249 0
a 917 252 251 0
a 917 254 253 0
a 917 256 255 0
a 915 923 27 0
a 915 924 29 0
a 915 925 31 0
a 915 926 33 0
a 914 839 311 0
h 927 928
t 927 1118
a 928 929 0 0
h 929 930
t 929 960
a 929 394 931 0
a 929 511 932 0
a 929 933 218 0
a 933 934 21 0
a 933 935 23 0
a 935 26 25 0
a 935 937 936 0
a 937 938 0 0
h 938 939
t 938 940
h 940 941
a 937 942 0 0
h 942 943
t 942 944
h 944 945
a 935 946 31 0
a 935 947 27 0
a 935 948 33 0
a 935 949 29 0
a 935 951 950 0
a 935 953 952 0
a 935 955 954 0
a 933 956 27 0
a 933 957 29 0
a 933 958 31 0
a 933 959 33 0
h 960 961
a 928 962 0 0
h 962 930
t 962 983
a 962 436 931 0
a 962 579 932 0
a 962 963 218 0
a 963 964 21 0
a 963 965 23 0
a 965 26 25 0
a 965 966 936 0
a 966 967 0 0
h 967 968
t 967 969
h 969 970
a 966 971 0 0
h 971 972
t 971 973
h 973 974
a 965 975 31 0
a 965 976 27 0
a 965 977 33 0
a 965 978 29 0
a 965 951 950 0
a 965 953 952 0
a 965 955 954 0
a 963 979 27 0
a 963 980 29 0
a 963 981 31 0
a 963 982 33 0
h 983 984
a 928 985 0 0
h 985 930
t 985 1006
a 985 565 931 0
a 985 722 932 0
a 985 986 218 0
a 986 987 21 0
a 986 988 23 0
a 988 26 25 0
a 988 989 936 0
a 989 990 0 0
h 990 991
t 990 992
h 992 993
a 989 994 0 0
h 994 995
t 994 996
h 996 997
a 988 998 31 0
a 988 999 27 0
a 988 1000 33 0
a 988 1001 29 0
a 988 951 950 0
a 988 953 952 0
a 988 955 954 0
a 986 1002 27 0
a 986 1003 29 0
a 986 1004 31 0
a 986 1005 33 0
h 1006 961
a 928 1007 0 0
h 1007 930
t 1007 1029
a 1007 283 931 0
a 1007 471 932 0
a 1007 1008 218 0
a 1008 1009 21 0
a 1008 1010 23 0
a 1010 26 25 0
a 1010 1011 936 0
a 1011 1012 0 0
h 1012 1013
t 1012 1014
h 1014 1015
a 1011 1016 0 0
h 1016 1017
t 1016 1018
h 1018 1019
a 1010 1020 31 0
a 1010 1021 27 0
a 1010 1022 33 0
a 1010 1023 29 0
a 1010 1024 950 0
a 1010 953 952 0
a 1010 955 954 0
a 1008 1025 27 0
a 1008 1026 29 0
a 1008 1027 31 0
a 1008 1028 33 0
h 1029 1030
a 928 1031 0 0
h 1031 930
t 1031 1052
a 1031 744 931 0
a 1031 525 932 0
a 1031 1032 218 0
a 1032 1033 21 0
a 1032 1034 23 0
a 1034 26 25 0
a 1034 1035 936 0
a 1035 1036 0 0
h 1036 1037
t 1036 1038
h 1038 1039
a 1035 1040 0 0
h 1040 1041
t 1040 1042
h 1042 1043
a 1034 1044 31 0
a 1034 1045 27 0
a 1034 1046 33 0
a 1034 1047 29 0
a 1034 951 950 0
a 1034 953 952 0
a 1034 955 954 0
a 1032 1048 27 0
a 1032 1049 29 0
a 1032 1050 31 0
a 1032 1051 33 0
h 1052 961
a 928 1053 0 0
h 1053 930
t 1053 1073
a 1053 722 931 0
a 1053 839 932 0
a 1053 1054 218 0
a 1054 1055 21 0
a 1054 1056 23 0
a 1056 26 25 0
a 1056 1057 936 0
a 1057 1058 0 0
h 1058 1059
t 1058 1060
h 1060 997
a 1057 1061 0 0
h 1061 1062
t 1061 1063
h 1063 1064
a 1056 1065 31 0
a 1056 1066 27 0
a 1056 1067 33 0
a 1056 1068 29 0
a 1056 951 950 0
a 1056 953 952 0
a 1056 955 954 0
a 1054 1069 27 0
a 1054 1070 29 0
a 1054 1071 31 0
a 1054 1072 33 0
h 1073 984
a 928 1074 0 0
h 1074 930
t 1074 1095
a 1074 485 931 0
a 1074 787 932 0
a 1074 1075 218 0
a 1075 1076 21 0
a 1075 1077 23 0
a 1077 26 25 0
a 1077 1078 936 0
a 1078 1079 0 0
h 1079 1080
t 1079 1081
h 1081 1082
a 1078 1083 0 0
h 1083 1084
t 1083 1085
h 1085 1086
a 1077 1087 31 0
a 1077 1088 27 0
a 1077 1089 33 0
a 1077 1090 29 0
a 1077 1024 950 0
a 1077 953 952 0
a 1077 955 954 0
a 1075 1091 27 0
a 1075 1092 29 0
a 1075 1093 31 0
a 1075 1094 33 0
h 1095 1030
a 928 1096 0 0
h 1096 930
t 1096 1117
a 1096 813 931 0
a 1096 340 932 0
a 1096 1097 218 0
a 1097 1098 21 0
a 1097 1099 23 0
a 1099 26 25 0
a 1099 1100 936 0
a 1100 1101 0 0
h 1101 1102
t 1101 1103
h 1103 1104
a 1100 1105 0 0
h 1105 1106
t 1105 1107
h 1107 1108
a 1099 1109 31 0
a 1099 1110 27 0
a 1099 1111 33 0
a 1099 1112 29 0
a 1099 1024 950 0
a 1099 953 952 0
a 1099 955 954 0
a 1097 1113 27 0
a 1097 1114 29 0
a 1097 1115 31 0
a 1097 1116 33 0
h 1117 1030
h 1118 1119
t 1118 1120
a 1119 283 0 0
a 1119 313 0 0
a 1119 340 0 0
a 1119 367 0 0
a 1119 394 0 0
a 1119 436 0 0
a 1119 458 0 0
a 1119 471 0 0
a 1119 485 0 0
a 1119 499 0 0
a 1119 565 0 0
a 1119 579 0 0
a 1119 511 0 0
a 1119 525 0 0
a 1119 538 0 0
a 1119 551 0 0
a 1119 722 0 0
a 1119 744 0 0
a 1119 779 0 0
a 1119 787 0 0
a 1119 800 0 0
a 1119 813 0 0
a 1119 826 0 0
a 1119 839 0 0
h 1120 1121
a 1121 1122 27 0
a 1121 1123 29 0
a 1121 1124 31 0
a 1121 1125 33 0
a 1121 285 23 0
a 1121 299 23 0
a 1121 314 23 0
a 1121 327 23 0
a 1121 341 23 0
a 1121 354 23 0
a 1121 368 23 0
a 1121 381 23 0
a 1121 395 23 0
a 1121 409 23 0
a 1121 422 23 0
a 1121 437 23 0
a 1121 445 23 0
a 1121 459 23 0
a 1121 595 23 0
a 1121 472 23 0
a 1121 609 23 0
a 1121 486 23 0
a 1121 621 23 0
a 1121 500 23 0
a 1121 633 23 0
a 1121 566 23 0
a 1121 645 23 0
a 1121 580 23 0
a 1121 657 23 0
a 1121 512 23 0
a 1121 670 23 0
a 1121 526 23 0
a 1121 683 23 0
a 1121 539 23 0
a 1121 696 23 0
a 1121 552 23 0
a 1121 709 23 0
a 1121 723 23 0
a 1121 731 23 0
a 1121 933 23 0
a 1121 963 23 0
a 1121 986 23 0
a 1121 745 23 0
a 1121 753 23 0
a 1121 766 23 0
a 1121 1008 23 0
a 1121 1032 23 0
a 1121 780 23 0
a 1121 854 23 0
a 1121 788 23 0
a 1121 867 23 0
a 1121 801 23 0
a 1121 879 23 0
a 1121 814 23 0
a 1121 891 23 0
a 1121 827 23 0
a 1121 903 23 0
a 1121 840 23 0
a 1121 915 23 0
a 1121 1054 23 0
a 1121 1075 23 0
a 1121 1097 23 0
a 272 1126 27 0
a 272 1127 29 0
a 272 1128 31 0
a 272 1129 33 0
a 271 1130 470 0
h 1130 284
t 1130 1142
a 1130 1131 218 0
a 1131 1132 21 0
a 1131 1133 23 0
a 1133 26 25 0
a 1133 222 37 0
a 1133 223 39 0
a 1133 224 41 0
a 1133 1134 27 0
a 1133 1135 29 0
a 1133 1136 31 0
a 1133 1137 33 0
a 1133 292 35 0
a 1131 1138 27 0
a 1131 1139 29 0
a 1131 1140 31 0
a 1131 1141 33 0
h 1142 484
a 271 1143 470 0
h 1143 284
t 1143 1155
a 1143 1144 218 0
a 1144 1145 21 0
a 1144 1146 23 0
a 1146 26 25 0
a 1146 222 37 0
a 1146 223 39 0
a 1146 224 41 0
a 1146 1147 27 0
a 1146 1148 29 0
a 1146 1149 31 0
a 1146 1150 33 0
a 1146 292 35 0
a 1144 1151 27 0
a 1144 1152 29 0
a 1144 1153 31 0
a 1144 1154 33 0
h 1155 524
a 271 1156 470 0
h 1156 284
t 1156 1168
a 1156 1157 218 0
a 1157 1158 21 0
a 1157 1159 23 0
a 1159 26 25 0
a 1159 222 37 0
a 1159 223 39 0
a 1159 224 41 0
a 1159 1160 27 0
a 1159 1161 29 0
a 1159 1162 31 0
a 1159 1163 33 0
a 1159 292 35 0
a 1157 1164 27 0
a 1157 1165 29 0
a 1157 1166 31 0
a 1157 1167 33 0
h 1168 498
a 271 1169 470 0
h 1169 284
t 1169 1181
a 1169 1170 218 0
a 1170 1171 21 0
a 1170 1172 23 0
a 1172 26 25 0
a 1172 222 37 0
a 1172 223 39 0
a 1172 224 41 0
a 1172 1173 27 0
a 1172 1174 29 0
a 1172 1175 31 0
a 1172 1176 33 0
a 1172 292 35 0
a 1170 1177 27 0
a 1170 1178 29 0
a 1170 1179 31 0
a 1170 1180 33 0
h 1181 578
a 271 1182 470 0
h 1182 284
t 1182 1194
a 1182 1183 218 0
a 1183 1184 21 0
a 1183 1185 23 0
a 1185 26 25 0
a 1185 222 37 0
a 1185 223 39 0
a 1185 224 41 0
a 1185 1186 27 0
a 1185 1187 29 0
a 1185 1188 31 0
a 1185 1189 33 0
a 1185 292 35 0
a 1183 1190 27 0
a 1183 1191 29 0
a 1183 1192 31 0
a 1183 1193 33 0
h 1194 592
a 271 1196 1195 0
a 1196 1197 25 0
a 1196 1121 23 0
a 1196 1198 72 0
a 1196 1122 27 0
a 1196 1123 29 0
a 1196 1124 31 0
a 1196 1125 33 0
a 1196 1119 74 0
a 1196 928 76 0
a 1196 281 78 0
a 1196 1200 1199 0
a 1196 1202 1201 0
a 1196 1204 1203 0
a 271 283 1205 0
a 271 313 1205 0
a 271 340 1205 0
a 271 367 1205 0
h 1206 594
a 270 1207 218 0
a 1207 1208 21 0
a 1207 1209 23 0
a 1209 26 25 0
a 1209 1210 27 0
a 1209 1211 29 0
a 1209 1212 31 0
a 1209 1213 33 0
a 1209 1214 243 0
a 1209 246 245 0
a 1209 248 247 0
a 1209 250 249 0
a 1209 252 251 0
a 1209 254 253 0
a 1209 256 255 0
a 1207 1215 27 0
a 1207 1216 29 0
a 1207 1217 31 0
a 1207 1218 33 0
a 270 271 607 0
a 269 1219 0 0
h 1219 214
a 1219 1130 215 0
a 1219 1220 218 0
a 1220 1221 21 0
a 1220 1222 23 0
a 1222 26 25 0
a 1222 1223 27 0
a 1222 1224 29 0
a 1222 1225 31 0
a 1222 1226 33 0
a 1222 306 243 0
a 1222 246 245 0
a 1222 248 247 0
a 1222 250 249 0
a 1222 252 251 0
a 1222 254 253 0
a 1222 256 255 0
a 1220 1227 27 0
a 1220 1228 29 0
a 1220 1229 31 0
a 1220 1230 33 0
a 1219 1130 311 0
a 269 1231 0 0
h 1231 214
a 1231 1143 215 0
a 1231 1232 218 0
a 1232 1233 21 0
a 1232 1234 23 0
a 1234 26 25 0
a 1234 1235 27 0
a 1234 1236 29 0
a 1234 1237 31 0
a 1234 1238 33 0
a 1234 334 243 0
a 1234 246 245 0
a 1234 248 247 0
a 1234 250 249 0
a 1234 252 251 0
a 1234 254 253 0
a 1234 256 255 0
a 1232 1239 27 0
a 1232 1240 29 0
a 1232 1241 31 0
a 1232 1242 33 0
a 1231 1143 311 0
a 269 1243 0 0
h 1243 214
a 1243 1156 215 0
a 1243 1244 218 0
a 1244 1245 21 0
a 1244 1246 23 0
a 1246 26 25 0
a 1246 1247 27 0
a 1246 1248 29 0
a 1246 1249 31 0
a 1246 1250 33 0
a 1246 361 243 0
a 1246 246 245 0
a 1246 248 247 0
a 1246 250 249 0
a 1246 252 251 0
a 1246 254 253 0
a 1246 256 255 0
a 1244 1251 27 0
a 1244 1252 29 0
a 1244 1253 31 0
a 1244 1254 33 0
a 1243 1156 311 0
a 269 1255 0 0
h 1255 214
a 1255 1169 215 0
a 1255 1256 218 0
a 1256 1257 21 0
a 1256 1258 23 0
a 1258 26 25 0
a 1258 1259 27 0
a 1258 1260 29 0
a 1258 1261 31 0
a 1258 1262 33 0
a 1258 388 243 0
a 1258 246 245 0
a 1258 248 247 0
a 1258 250 249 0
a 1258 252 251 0
a 1258 254 253 0
a 1258 256 255 0
a 1256 1263 27 0
a 1256 1264 29 0
a 1256 1265 31 0
a 1256 1266 33 0
a 1255 1169 311 0
a 269 1267 0 0
h 1267 214
a 1267 1182 215 0
a 1267 1268 218 0
a 1268 1269 21 0
a 1268 1270 23 0
a 1270 26 25 0
a 1270 1271 27 0
a 1270 1272 29 0
a 1270 1273 31 0
a 1270 1274 33 0
a 1270 664 243 0
a 1270 246 245 0
a 1270 248 247 0
a 1270 250 249 0
a 1270 252 251 0
a 1270 254 253 0
a 1270 256 255 0
a 1268 1275 27 0
a 1268 1276 29 0
a 1268 1277 31 0
a 1268 1278 33 0
a 1267 1182 311 0
h 1279 1280
t 1279 1281
h 1281 1282
t 1281 1283
a 1282 271 0 0
a 1282 1130 0 0
a 1282 1143 0 0
a 1282 1156 0 0
a 1282 1169 0 0
a 1282 1182 0 0
h 1283 1284
a 1284 1285 27 0
a 1284 1286 29 0
a 1284 1287 31 0
a 1284 1288 33 0
a 1284 272 23 0
a 1284 1207 23 0
a 1284 1131 23 0
a 1284 1220 23 0
a 1284 1144 23 0
a 1284 1232 23 0
a 1284 1157 23 0
a 1284 1244 23 0
a 1284 1170 23 0
a 1284 1256 23 0
a 1284 1183 23 0
a 1284 1268 23 0
a 1284 1207 203 0
a 264 1289 27 0
a 264 1290 29 0
a 264 1291 31 0
a 264 1292 33 0
a 263 1293 1195 0
a 1293 1197 25 0
a 1293 1284 23 0
a 1293 1294 72 0
a 1294 272 1295 0
a 1293 1285 27 0
a 1293 1286 29 0
a 1293 1287 31 0
a 1293 1288 33 0
a 1293 1282 74 0
a 1293 1280 76 0
a 1293 269 78 0
a 1293 1296 1199 0
a 1293 1202 1201 0
a 1293 1297 1203 0
h 1298 235
a 262 1299 218 0
a 1299 1300 21 0
a 1299 1301 23 0
a 1301 26 25 0
a 1301 1302 27 0
a 1301 1303 29 0
a 1301 1304 31 0
a 1301 1305 33 0
a 1301 1202 243 0
a 1301 246 245 0
a 1301 248 247 0
a 1301 250 249 0
a 1301 252 251 0
a 1301 254 253 0
a 1301 256 255 0
a 1299 1306 27 0
a 1299 1307 29 0
a 1299 1308 31 0
a 1299 1309 33 0
a 262 263 261 0
h 1310 1311
t 1310 1335
a 1311 1312 0 0
h 1312 930
t 1312 1333
a 1312 216 931 0
a 1312 263 932 0
a 1312 1313 218 0
a 1313 1314 21 0
a 1313 1315 23 0
a 1315 26 25 0
a 1315 1316 936 0
a 1316 1317 0 0
h 1317 1318
t 1317 1319
h 1319 1320
a 1316 1321 0 0
h 1321 1322
t 1321 1323
h 1323 1324
a 1315 1325 31 0
a 1315 1326 27 0
a 1315 1327 33 0
a 1315 1328 29 0
a 1315 1024 950 0
a 1315 953 952 0
a 1315 955 954 0
a 1313 1329 27 0
a 1313 1330 29 0
a 1313 1331 31 0
a 1313 1332 33 0
h 1333 1334
h 1335 1336
t 1335 1337
a 1336 216 0 0
a 1336 263 0 0
h 1337 1338
a 1338 1339 27 0
a 1338 1340 29 0
a 1338 1341 31 0
a 1338 1342 33 0
a 1338 219 23 0
a 1338 236 23 0
a 1338 264 23 0
a 1338 1299 23 0
a 1338 1313 23 0
h 1343 1344
a 1 1346 1345 0
h 1346 1347
t 1346 1348
h 1348 1349
h 1350 1351
t 1350 1352
h 1352 1353
t 1352 1354
h 1354 1355
t 1354 1356
a 1355 738 0 0
a 1355 1202 0 0
h 1356 1357
a 1357 1358 0 0
a 1357 738 0 0
a 1357 1202 0 0
E
